{"traceEvents": [{"ph": "M", "pid": 1, "tid": 1, "name": "process_name", "args": {"name": "MainProcess"}}, {"ph": "M", "pid": 1, "tid": 1, "name": "thread_name", "args": {"name": "MainThread"}}, {"pid": 1, "tid": 1, "ts": 38292215618.019, "ph": "X", "dur": 32.08185852525189, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292215612.018, "ph": "X", "dur": 38.28431802591492, "name": "FinnhubProvider.get_company_profile (/app/app/providers/finnhub_provider.py:124)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292215597.423, "ph": "X", "dur": 53.003488639272476, "name": "MarketDataService.get_company_profile (/app/app/services/market_data.py:280)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292233817.366, "ph": "X", "dur": 27.993660404212747, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292233869.39, "ph": "X", "dur": 4.288188353446732, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292233882.214, "ph": "X", "dur": 9.876865676748348, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292233900.222, "ph": "X", "dur": 45.19503022808771, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292233866.549, "ph": "X", "dur": 79.12375987747932, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292233865.532, "ph": "X", "dur": 80.35905866107979, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292233863.588, "ph": "X", "dur": 82.50039054177543, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292334187.08, "ph": "X", "dur": 31.002905696820886, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292334242.553, "ph": "X", "dur": 4.425750695627644, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292334254.811, "ph": "X", "dur": 8.000161755509163, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292334271.024, "ph": "X", "dur": 46.03697805733955, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292334240.944, "ph": "X", "dur": 76.39350648367183, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292334239.684, "ph": "X", "dur": 77.87906928738455, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292334237.577, "ph": "X", "dur": 80.18503401133286, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292434659.361, "ph": "X", "dur": 28.156083410643223, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292434712.399, "ph": "X", "dur": 3.7197078309400733, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292434724.233, "ph": "X", "dur": 6.715694102615109, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292434738.602, "ph": "X", "dur": 43.16529510691233, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292434710.622, "ph": "X", "dur": 71.4688851254363, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292434709.159, "ph": "X", "dur": 73.14725619188452, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292434707.39, "ph": "X", "dur": 75.13389949502734, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292534929.942, "ph": "X", "dur": 20.296798752548245, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292534966.289, "ph": "X", "dur": 2.7562189764681455, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292534974.677, "ph": "X", "dur": 4.089855498655779, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292534983.563, "ph": "X", "dur": 26.173859781144788, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292534964.98, "ph": "X", "dur": 44.86134486793803, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292534964.469, "ph": "X", "dur": 45.44032211535006, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292534963.273, "ph": "X", "dur": 46.70213894081674, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292635237.109, "ph": "X", "dur": 87.46589388122135, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292635349.42, "ph": "X", "dur": 3.432981503261787, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292635401.518, "ph": "X", "dur": 8.484668478772855, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292635418.608, "ph": "X", "dur": 44.259164333893075, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292635347.572, "ph": "X", "dur": 115.62529204709784, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292635346.624, "ph": "X", "dur": 117.37824510629477, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292635344.807, "ph": "X", "dur": 120.31843299820967, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292735626.675, "ph": "X", "dur": 30.716731828348145, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292735680.982, "ph": "X", "dur": 3.94400626839168, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292735694.631, "ph": "X", "dur": 7.100205709675007, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292735709.846, "ph": "X", "dur": 45.33922208073517, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292735679.397, "ph": "X", "dur": 76.14987197402611, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292735677.55, "ph": "X", "dur": 78.19673333057341, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292735676.15, "ph": "X", "dur": 79.78615846492876, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836009.993, "ph": "X", "dur": 31.132733610124156, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836066.61, "ph": "X", "dur": 4.76938032147715, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836296.068, "ph": "X", "dur": 15.749507031700519, "name": "_format_timetuple_and_zone (/usr/local/lib/python3.11/email/utils.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836267.566, "ph": "X", "dur": 44.68124316693009, "name": "format_datetime (/usr/local/lib/python3.11/email/utils.py:271)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836238.88, "ph": "X", "dur": 74.63226653639173, "name": "formatdate (/usr/local/lib/python3.11/email/utils.py:242)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836224.673, "ph": "X", "dur": 100.93540177163422, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836332.094, "ph": "X", "dur": 45.17016956383815, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836064.712, "ph": "X", "dur": 312.90736942910263, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836063.331, "ph": "X", "dur": 314.43712896925905, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292836061.751, "ph": "X", "dur": 316.3060984616206, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292936643.156, "ph": "X", "dur": 33.73205417221729, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292936704.546, "ph": "X", "dur": 4.6301606016796, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292936717.993, "ph": "X", "dur": 7.390246792586567, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292936733.93, "ph": "X", "dur": 49.62520059735972, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292936702.727, "ph": "X", "dur": 81.06786382179509, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292936701.814, "ph": "X", "dur": 82.19709043793077, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38292936698.949, "ph": "X", "dur": 85.26047673268239, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293037052.711, "ph": "X", "dur": 31.79568465677915, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293037111.338, "ph": "X", "dur": 4.583754028413751, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293037124.584, "ph": "X", "dur": 7.343840219320717, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293037139.892, "ph": "X", "dur": 46.839701282997645, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293037109.422, "ph": "X", "dur": 77.5685872138678, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293037108.026, "ph": "X", "dur": 79.18784514532263, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293037106.391, "ph": "X", "dur": 81.01427527885714, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293137384.438, "ph": "X", "dur": 36.05348775392086, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293137447.783, "ph": "X", "dur": 4.797555740959987, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293137461.336, "ph": "X", "dur": 9.511690141882555, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293137479.822, "ph": "X", "dur": 51.716811149556236, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293137445.846, "ph": "X", "dur": 85.94165893312041, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293137443.653, "ph": "X", "dur": 88.33601712995603, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293137442.139, "ph": "X", "dur": 90.05029804476474, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215836.289, "ph": "X", "dur": 37.6318637041653, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215989.321, "ph": "X", "dur": 5.733974094360169, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216061.902, "ph": "X", "dur": 7.75155511301354, "name": "ABCMeta.__instancecheck__ (<frozen abc>:117)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216048.641, "ph": "X", "dur": 22.214384654997822, "name": "iscoroutine (/usr/local/lib/python3.11/asyncio/coroutines.py:34)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216081.025, "ph": "X", "dur": 3.130786317828218, "name": "ismethod (/usr/local/lib/python3.11/inspect.py:300)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216086.522, "ph": "X", "dur": 3.3534273776631878, "name": "_unwrap_partial (/usr/local/lib/python3.11/functools.py:421)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216091.114, "ph": "X", "dur": 1.5711939805723405, "name": "isfunction (/usr/local/lib/python3.11/inspect.py:378)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216100.945, "ph": "X", "dur": 1.3640217784926543, "name": "isclass (/usr/local/lib/python3.11/inspect.py:292)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216094.356, "ph": "X", "dur": 19.308449233826757, "name": "_signature_is_functionlike (/usr/local/lib/python3.11/inspect.py:2075)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216079.298, "ph": "X", "dur": 118.66437013680545, "name": "_has_code_flag (/usr/local/lib/python3.11/inspect.py:391)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216076.364, "ph": "X", "dur": 122.64815346799642, "name": "iscoroutinefunction (/usr/local/lib/python3.11/inspect.py:409)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216072.233, "ph": "X", "dur": 131.07094651574815, "name": "iscoroutinefunction (/usr/local/lib/python3.11/asyncio/coroutines.py:21)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216256.983, "ph": "X", "dur": 5.120744376204297, "name": "RLock (/usr/local/lib/python3.11/threading.py:90)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216254.334, "ph": "X", "dur": 24.212629601457092, "name": "Condition.__init__ (/usr/local/lib/python3.11/threading.py:243)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216246.358, "ph": "X", "dur": 34.84415455298104, "name": "Future.__init__ (/usr/local/lib/python3.11/concurrent/futures/_base.py:328)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216286.279, "ph": "X", "dur": 1.7971497956405849, "name": "_WorkItem.__init__ (/usr/local/lib/python3.11/concurrent/futures/thread.py:47)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216370.482, "ph": "X", "dur": 3.417512645506504, "name": "Condition.__enter__ (/usr/local/lib/python3.11/threading.py:271)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216379.149, "ph": "X", "dur": 2.4120368914130936, "name": "Condition.__exit__ (/usr/local/lib/python3.11/threading.py:274)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216367.054, "ph": "X", "dur": 36.02034020158811, "name": "Semaphore.acquire (/usr/local/lib/python3.11/threading.py:440)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216361.073, "ph": "X", "dur": 42.83271466517374, "name": "ThreadPoolExecutor._adjust_thread_count (/usr/local/lib/python3.11/concurrent/futures/thread.py:180)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216218.569, "ph": "X", "dur": 188.0549037309783, "name": "ThreadPoolExecutor.submit (/usr/local/lib/python3.11/concurrent/futures/thread.py:161)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216415.987, "ph": "X", "dur": 11.7845073134981, "name": "isfuture (/usr/local/lib/python3.11/asyncio/base_futures.py:14)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216448.691, "ph": "X", "dur": 4.187088318831845, "name": "isfuture (/usr/local/lib/python3.11/asyncio/base_futures.py:14)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216456.455, "ph": "X", "dur": 3.3849175523793003, "name": "isfuture (/usr/local/lib/python3.11/asyncio/base_futures.py:14)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216461.496, "ph": "X", "dur": 3.119184674511756, "name": "isfuture (/usr/local/lib/python3.11/asyncio/base_futures.py:14)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216465.98, "ph": "X", "dur": 0.8386330740185699, "name": "isfuture (/usr/local/lib/python3.11/asyncio/base_futures.py:14)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216468.923, "ph": "X", "dur": 3.0042731597582235, "name": "_get_loop (/usr/local/lib/python3.11/asyncio/futures.py:299)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216485.04, "ph": "X", "dur": 4.095932549916783, "name": "Condition.__enter__ (/usr/local/lib/python3.11/threading.py:271)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216501.443, "ph": "X", "dur": 3.1462551755835015, "name": "Condition.__exit__ (/usr/local/lib/python3.11/threading.py:274)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216482.905, "ph": "X", "dur": 23.23090959320215, "name": "Future.add_done_callback (/usr/local/lib/python3.11/concurrent/futures/_base.py:408)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216446.832, "ph": "X", "dur": 59.87829099308478, "name": "_chain_future (/usr/local/lib/python3.11/asyncio/futures.py:365)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216413.123, "ph": "X", "dur": 94.19153224953628, "name": "wrap_future (/usr/local/lib/python3.11/asyncio/futures.py:409)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293216018.522, "ph": "X", "dur": 492.5173817441074, "name": "to_thread (/usr/local/lib/python3.11/asyncio/threads.py:12)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215988.135, "ph": "X", "dur": 523.9904302248478, "name": "FinnhubProvider.get_company_profile (/app/app/providers/finnhub_provider.py:124)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215985.856, "ph": "X", "dur": 526.7913983969651, "name": "MarketDataService.get_company_profile (/app/app/services/market_data.py:280)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215984.348, "ph": "X", "dur": 528.8736171426674, "name": "get_company_profile (/app/app/main.py:596)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215983.289, "ph": "X", "dur": 530.5619324748154, "name": "run_endpoint_function (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:280)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215982.273, "ph": "X", "dur": 532.2458281333192, "name": "get_request_handler.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:316)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215981.185, "ph": "X", "dur": 533.7275237225931, "name": "request_response.<locals>.app.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:103)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215973.952, "ph": "X", "dur": 541.9867888455033, "name": "wrap_app_handling_exceptions.<locals>.wrapped_app (/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:31)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215973.424, "ph": "X", "dur": 543.3745663698344, "name": "request_response.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:100)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215971.557, "ph": "X", "dur": 545.8208557319913, "name": "Route.handle (/usr/local/lib/python3.11/site-packages/starlette/routing.py:281)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215970.789, "ph": "X", "dur": 547.493702206384, "name": "Router.app (/usr/local/lib/python3.11/site-packages/starlette/routing.py:718)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215970.03, "ph": "X", "dur": 548.6417124355082, "name": "Router.__call__ (/usr/local/lib/python3.11/site-packages/starlette/routing.py:712)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215969.111, "ph": "X", "dur": 550.2565506933187, "name": "AsyncExitStackMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py:15)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215967.295, "ph": "X", "dur": 552.375231746587, "name": "wrap_app_handling_exceptions.<locals>.wrapped_app (/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:31)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215963.855, "ph": "X", "dur": 556.4347019889377, "name": "ExceptionMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py:47)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215962.419, "ph": "X", "dur": 558.8975651272611, "name": "CORSMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/cors.py:75)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215961.02, "ph": "X", "dur": 560.673721473091, "name": "ServerErrorMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:149)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215957.868, "ph": "X", "dur": 564.2370833488616, "name": "Starlette.__call__ (/usr/local/lib/python3.11/site-packages/starlette/applications.py:109)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215956.11, "ph": "X", "dur": 566.7126530489124, "name": "FastAPI.__call__ (/usr/local/lib/python3.11/site-packages/fastapi/applications.py:1130)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215954.004, "ph": "X", "dur": 569.8959229912674, "name": "ProxyHeadersMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/uvicorn/middleware/proxy_headers.py:27)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293215950.011, "ph": "X", "dur": 574.3531638616112, "name": "RequestResponseCycle.run_asgi (/usr/local/lib/python3.11/site-packages/uvicorn/protocols/http/httptools_impl.py:407)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293237796.527, "ph": "X", "dur": 29.522867485163605, "name": "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293237848.774, "ph": "X", "dur": 3.9196980633476635, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293237859.689, "ph": "X", "dur": 9.80228368399966, "name": "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293237877.285, "ph": "X", "dur": 45.52319099618193, "name": "sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293237847.073, "ph": "X", "dur": 75.94932928241298, "name": "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293237845.967, "ph": "X", "dur": 77.20727889344083, "name": "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293237844.264, "ph": "X", "dur": 79.06961887533582, "name": "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243253.695, "ph": "X", "dur": 6.999105675060119, "name": "isfuture (/usr/local/lib/python3.11/asyncio/base_futures.py:14)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243272.407, "ph": "X", "dur": 7.447702549963334, "name": "Condition.__enter__ (/usr/local/lib/python3.11/threading.py:271)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243284.707, "ph": "X", "dur": 2.1352548294346327, "name": "Condition.__exit__ (/usr/local/lib/python3.11/threading.py:274)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243268.818, "ph": "X", "dur": 18.54771290779015, "name": "Future.done (/usr/local/lib/python3.11/concurrent/futures/_base.py:393)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243307.385, "ph": "X", "dur": 0.6513494033385335, "name": "Condition.__enter__ (/usr/local/lib/python3.11/threading.py:271)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243309.341, "ph": "X", "dur": 0.4955559073746094, "name": "Condition.__exit__ (/usr/local/lib/python3.11/threading.py:274)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243306.896, "ph": "X", "dur": 3.1490174716112307, "name": "Future.cancelled (/usr/local/lib/python3.11/concurrent/futures/_base.py:383)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243312.345, "ph": "X", "dur": 0.44141490523111815, "name": "Condition.__enter__ (/usr/local/lib/python3.11/threading.py:271)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243313.863, "ph": "X", "dur": 0.357441105988152, "name": "Condition.__exit__ (/usr/local/lib/python3.11/threading.py:274)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243311.772, "ph": "X", "dur": 2.611474664615138, "name": "Future.exception (/usr/local/lib/python3.11/concurrent/futures/_base.py:463)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243316.596, "ph": "X", "dur": 0.43036572112020155, "name": "Condition.__enter__ (/usr/local/lib/python3.11/threading.py:271)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243319.22, "ph": "X", "dur": 0.5331231333517259, "name": "Future.__get_result (/usr/local/lib/python3.11/concurrent/futures/_base.py:398)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243320.282, "ph": "X", "dur": 0.3662804532768853, "name": "Condition.__exit__ (/usr/local/lib/python3.11/threading.py:274)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243316.14, "ph": "X", "dur": 4.848381987870203, "name": "Future.result (/usr/local/lib/python3.11/concurrent/futures/_base.py:428)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243264.506, "ph": "X", "dur": 70.34628801976716, "name": "_copy_future_state (/usr/local/lib/python3.11/asyncio/futures.py:345)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243248.673, "ph": "X", "dur": 86.59079849963675, "name": "_chain_future.<locals>._set_state (/usr/local/lib/python3.11/asyncio/futures.py:381)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243343.158, "ph": "X", "dur": 1.0104478869433229, "name": "_chain_future.<locals>._call_check_cancel (/usr/local/lib/python3.11/asyncio/futures.py:387)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243448.04, "ph": "X", "dur": 1.2789430608385963, "name": "to_thread (/usr/local/lib/python3.11/asyncio/threads.py:12)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243447.58, "ph": "X", "dur": 21.228244973098516, "name": "FinnhubProvider.get_company_profile (/app/app/providers/finnhub_provider.py:124)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243446.353, "ph": "X", "dur": 24.733598632286807, "name": "MarketDataService.get_company_profile (/app/app/services/market_data.py:280)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243477.984, "ph": "B", "name": "maybe_trace (/app/app/observability/trace.py:6)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243474.195, "ph": "B", "name": "_GeneratorContextManager.__exit__ (/usr/local/lib/python3.11/contextlib.py:141)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243445.378, "ph": "B", "name": "get_company_profile (/app/app/main.py:596)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243444.507, "ph": "B", "name": "run_endpoint_function (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:280)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243444.052, "ph": "B", "name": "get_request_handler.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:316)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243443.258, "ph": "B", "name": "request_response.<locals>.app.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:103)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243442.353, "ph": "B", "name": "wrap_app_handling_exceptions.<locals>.wrapped_app (/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:31)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243441.913, "ph": "B", "name": "request_response.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:100)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243441.137, "ph": "B", "name": "Route.handle (/usr/local/lib/python3.11/site-packages/starlette/routing.py:281)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243440.405, "ph": "B", "name": "Router.app (/usr/local/lib/python3.11/site-packages/starlette/routing.py:718)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243439.398, "ph": "B", "name": "Router.__call__ (/usr/local/lib/python3.11/site-packages/starlette/routing.py:712)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243438.244, "ph": "B", "name": "AsyncExitStackMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py:15)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243437.128, "ph": "B", "name": "wrap_app_handling_exceptions.<locals>.wrapped_app (/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:31)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243436.387, "ph": "B", "name": "ExceptionMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py:47)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243435.433, "ph": "B", "name": "CORSMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/cors.py:75)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243434.429, "ph": "B", "name": "ServerErrorMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:149)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243432.695, "ph": "B", "name": "Starlette.__call__ (/usr/local/lib/python3.11/site-packages/starlette/applications.py:109)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243431.709, "ph": "B", "name": "FastAPI.__call__ (/usr/local/lib/python3.11/site-packages/fastapi/applications.py:1130)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243429.881, "ph": "B", "name": "ProxyHeadersMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/uvicorn/middleware/proxy_headers.py:27)", "cat": "FEE"}, {"pid": 1, "tid": 1, "ts": 38293243428.537, "ph": "B", "name": "RequestResponseCycle.run_asgi (/usr/local/lib/python3.11/site-packages/uvicorn/protocols/http/httptools_impl.py:407)", "cat": "FEE"}], "viztracer_metadata": {"version": "1.0.4", "overflow": false, "baseTimeNanoseconds": 1759980240576414830}, "file_info": {"files": {"/usr/local/lib/python3.11/asyncio/tasks.py": ["\"\"\"Support for tasks, coroutines and the scheduler.\"\"\"\n\n__all__ = (\n    'Task', 'create_task',\n    'FIRST_COMPLETED', 'FIRST_EXCEPTION', 'ALL_COMPLETED',\n    'wait', 'wait_for', 'as_completed', 'sleep',\n    'gather', 'shield', 'ensure_future', 'run_coroutine_threadsafe',\n    'current_task', 'all_tasks',\n    '_register_task', '_unregister_task', '_enter_task', '_leave_task',\n)\n\nimport concurrent.futures\nimport contextvars\nimport functools\nimport inspect\nimport itertools\nimport types\nimport warnings\nimport weakref\nfrom types import GenericAlias\n\nfrom . import base_tasks\nfrom . import coroutines\nfrom . import events\nfrom . import exceptions\nfrom . import futures\nfrom .coroutines import _is_coroutine\n\n# Helper to generate new task names\n# This uses itertools.count() instead of a \"+= 1\" operation because the latter\n# is not thread safe. See bpo-11866 for a longer explanation.\n_task_name_counter = itertools.count(1).__next__\n\n\ndef current_task(loop=None):\n    \"\"\"Return a currently executed task.\"\"\"\n    if loop is None:\n        loop = events.get_running_loop()\n    return _current_tasks.get(loop)\n\n\ndef all_tasks(loop=None):\n    \"\"\"Return a set of all tasks for the loop.\"\"\"\n    if loop is None:\n        loop = events.get_running_loop()\n    # Looping over a WeakSet (_all_tasks) isn't safe as it can be updated from another\n    # thread while we do so. Therefore we cast it to list prior to filtering. The list\n    # cast itself requires iteration, so we repeat it several times ignoring\n    # RuntimeErrors (which are not very likely to occur). See issues 34970 and 36607 for\n    # details.\n    i = 0\n    while True:\n        try:\n            tasks = list(_all_tasks)\n        except RuntimeError:\n            i += 1\n            if i >= 1000:\n                raise\n        else:\n            break\n    return {t for t in tasks\n            if futures._get_loop(t) is loop and not t.done()}\n\n\ndef _set_task_name(task, name):\n    if name is not None:\n        try:\n            set_name = task.set_name\n        except AttributeError:\n            warnings.warn(\"Task.set_name() was added in Python 3.8, \"\n                      \"the method support will be mandatory for third-party \"\n                      \"task implementations since 3.13.\",\n                      DeprecationWarning, stacklevel=3)\n        else:\n            set_name(name)\n\n\nclass Task(futures._PyFuture):  # Inherit Python Task implementation\n                                # from a Python Future implementation.\n\n    \"\"\"A coroutine wrapped in a Future.\"\"\"\n\n    # An important invariant maintained while a Task not done:\n    # _fut_waiter is either None or a Future.  The Future\n    # can be either done() or not done().\n    # The task can be in any of 3 states:\n    #\n    # - 1: _fut_waiter is not None and not _fut_waiter.done():\n    #      __step() is *not* scheduled and the Task is waiting for _fut_waiter.\n    # - 2: (_fut_waiter is None or _fut_waiter.done()) and __step() is scheduled:\n    #       the Task is waiting for __step() to be executed.\n    # - 3:  _fut_waiter is None and __step() is *not* scheduled:\n    #       the Task is currently executing (in __step()).\n    #\n    # * In state 1, one of the callbacks of __fut_waiter must be __wakeup().\n    # * The transition from 1 to 2 happens when _fut_waiter becomes done(),\n    #   as it schedules __wakeup() to be called (which calls __step() so\n    #   we way that __step() is scheduled).\n    # * It transitions from 2 to 3 when __step() is executed, and it clears\n    #   _fut_waiter to None.\n\n    # If False, don't log a message if the task is destroyed while its\n    # status is still pending\n    _log_destroy_pending = True\n\n    def __init__(self, coro, *, loop=None, name=None, context=None):\n        super().__init__(loop=loop)\n        if self._source_traceback:\n            del self._source_traceback[-1]\n        if not coroutines.iscoroutine(coro):\n            # raise after Future.__init__(), attrs are required for __del__\n            # prevent logging for pending task in __del__\n            self._log_destroy_pending = False\n            raise TypeError(f\"a coroutine was expected, got {coro!r}\")\n\n        if name is None:\n            self._name = f'Task-{_task_name_counter()}'\n        else:\n            self._name = str(name)\n\n        self._num_cancels_requested = 0\n        self._must_cancel = False\n        self._fut_waiter = None\n        self._coro = coro\n        if context is None:\n            self._context = contextvars.copy_context()\n        else:\n            self._context = context\n\n        self._loop.call_soon(self.__step, context=self._context)\n        _register_task(self)\n\n    def __del__(self):\n        if self._state == futures._PENDING and self._log_destroy_pending:\n            context = {\n                'task': self,\n                'message': 'Task was destroyed but it is pending!',\n            }\n            if self._source_traceback:\n                context['source_traceback'] = self._source_traceback\n            self._loop.call_exception_handler(context)\n        super().__del__()\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n    def __repr__(self):\n        return base_tasks._task_repr(self)\n\n    def get_coro(self):\n        return self._coro\n\n    def get_name(self):\n        return self._name\n\n    def set_name(self, value):\n        self._name = str(value)\n\n    def set_result(self, result):\n        raise RuntimeError('Task does not support set_result operation')\n\n    def set_exception(self, exception):\n        raise RuntimeError('Task does not support set_exception operation')\n\n    def get_stack(self, *, limit=None):\n        \"\"\"Return the list of stack frames for this task's coroutine.\n\n        If the coroutine is not done, this returns the stack where it is\n        suspended.  If the coroutine has completed successfully or was\n        cancelled, this returns an empty list.  If the coroutine was\n        terminated by an exception, this returns the list of traceback\n        frames.\n\n        The frames are always ordered from oldest to newest.\n\n        The optional limit gives the maximum number of frames to\n        return; by default all available frames are returned.  Its\n        meaning differs depending on whether a stack or a traceback is\n        returned: the newest frames of a stack are returned, but the\n        oldest frames of a traceback are returned.  (This matches the\n        behavior of the traceback module.)\n\n        For reasons beyond our control, only one stack frame is\n        returned for a suspended coroutine.\n        \"\"\"\n        return base_tasks._task_get_stack(self, limit)\n\n    def print_stack(self, *, limit=None, file=None):\n        \"\"\"Print the stack or traceback for this task's coroutine.\n\n        This produces output similar to that of the traceback module,\n        for the frames retrieved by get_stack().  The limit argument\n        is passed to get_stack().  The file argument is an I/O stream\n        to which the output is written; by default output is written\n        to sys.stderr.\n        \"\"\"\n        return base_tasks._task_print_stack(self, limit, file)\n\n    def cancel(self, msg=None):\n        \"\"\"Request that this task cancel itself.\n\n        This arranges for a CancelledError to be thrown into the\n        wrapped coroutine on the next cycle through the event loop.\n        The coroutine then has a chance to clean up or even deny\n        the request using try/except/finally.\n\n        Unlike Future.cancel, this does not guarantee that the\n        task will be cancelled: the exception might be caught and\n        acted upon, delaying cancellation of the task or preventing\n        cancellation completely.  The task may also return a value or\n        raise a different exception.\n\n        Immediately after this method is called, Task.cancelled() will\n        not return True (unless the task was already cancelled).  A\n        task will be marked as cancelled when the wrapped coroutine\n        terminates with a CancelledError exception (even if cancel()\n        was not called).\n\n        This also increases the task's count of cancellation requests.\n        \"\"\"\n        self._log_traceback = False\n        if self.done():\n            return False\n        self._num_cancels_requested += 1\n        # These two lines are controversial.  See discussion starting at\n        # https://github.com/python/cpython/pull/31394#issuecomment-1053545331\n        # Also remember that this is duplicated in _asynciomodule.c.\n        # if self._num_cancels_requested > 1:\n        #     return False\n        if self._fut_waiter is not None:\n            if self._fut_waiter.cancel(msg=msg):\n                # Leave self._fut_waiter; it may be a Task that\n                # catches and ignores the cancellation so we may have\n                # to cancel it again later.\n                return True\n        # It must be the case that self.__step is already scheduled.\n        self._must_cancel = True\n        self._cancel_message = msg\n        return True\n\n    def cancelling(self):\n        \"\"\"Return the count of the task's cancellation requests.\n\n        This count is incremented when .cancel() is called\n        and may be decremented using .uncancel().\n        \"\"\"\n        return self._num_cancels_requested\n\n    def uncancel(self):\n        \"\"\"Decrement the task's count of cancellation requests.\n\n        This should be called by the party that called `cancel()` on the task\n        beforehand.\n\n        Returns the remaining number of cancellation requests.\n        \"\"\"\n        if self._num_cancels_requested > 0:\n            self._num_cancels_requested -= 1\n        return self._num_cancels_requested\n\n    def __step(self, exc=None):\n        if self.done():\n            raise exceptions.InvalidStateError(\n                f'_step(): already done: {self!r}, {exc!r}')\n        if self._must_cancel:\n            if not isinstance(exc, exceptions.CancelledError):\n                exc = self._make_cancelled_error()\n            self._must_cancel = False\n        coro = self._coro\n        self._fut_waiter = None\n\n        _enter_task(self._loop, self)\n        # Call either coro.throw(exc) or coro.send(None).\n        try:\n            if exc is None:\n                # We use the `send` method directly, because coroutines\n                # don't have `__iter__` and `__next__` methods.\n                result = coro.send(None)\n            else:\n                result = coro.throw(exc)\n        except StopIteration as exc:\n            if self._must_cancel:\n                # Task is cancelled right before coro stops.\n                self._must_cancel = False\n                super().cancel(msg=self._cancel_message)\n            else:\n                super().set_result(exc.value)\n        except exceptions.CancelledError as exc:\n            # Save the original exception so we can chain it later.\n            self._cancelled_exc = exc\n            super().cancel()  # I.e., Future.cancel(self).\n        except (KeyboardInterrupt, SystemExit) as exc:\n            super().set_exception(exc)\n            raise\n        except BaseException as exc:\n            super().set_exception(exc)\n        else:\n            blocking = getattr(result, '_asyncio_future_blocking', None)\n            if blocking is not None:\n                # Yielded Future must come from Future.__iter__().\n                if futures._get_loop(result) is not self._loop:\n                    new_exc = RuntimeError(\n                        f'Task {self!r} got Future '\n                        f'{result!r} attached to a different loop')\n                    self._loop.call_soon(\n                        self.__step, new_exc, context=self._context)\n                elif blocking:\n                    if result is self:\n                        new_exc = RuntimeError(\n                            f'Task cannot await on itself: {self!r}')\n                        self._loop.call_soon(\n                            self.__step, new_exc, context=self._context)\n                    else:\n                        result._asyncio_future_blocking = False\n                        result.add_done_callback(\n                            self.__wakeup, context=self._context)\n                        self._fut_waiter = result\n                        if self._must_cancel:\n                            if self._fut_waiter.cancel(\n                                    msg=self._cancel_message):\n                                self._must_cancel = False\n                else:\n                    new_exc = RuntimeError(\n                        f'yield was used instead of yield from '\n                        f'in task {self!r} with {result!r}')\n                    self._loop.call_soon(\n                        self.__step, new_exc, context=self._context)\n\n            elif result is None:\n                # Bare yield relinquishes control for one event loop iteration.\n                self._loop.call_soon(self.__step, context=self._context)\n            elif inspect.isgenerator(result):\n                # Yielding a generator is just wrong.\n                new_exc = RuntimeError(\n                    f'yield was used instead of yield from for '\n                    f'generator in task {self!r} with {result!r}')\n                self._loop.call_soon(\n                    self.__step, new_exc, context=self._context)\n            else:\n                # Yielding something else is an error.\n                new_exc = RuntimeError(f'Task got bad yield: {result!r}')\n                self._loop.call_soon(\n                    self.__step, new_exc, context=self._context)\n        finally:\n            _leave_task(self._loop, self)\n            self = None  # Needed to break cycles when an exception occurs.\n\n    def __wakeup(self, future):\n        try:\n            future.result()\n        except BaseException as exc:\n            # This may also be a cancellation.\n            self.__step(exc)\n        else:\n            # Don't pass the value of `future.result()` explicitly,\n            # as `Future.__iter__` and `Future.__await__` don't need it.\n            # If we call `_step(value, None)` instead of `_step()`,\n            # Python eval loop would use `.send(value)` method call,\n            # instead of `__next__()`, which is slower for futures\n            # that return non-generator iterators from their `__iter__`.\n            self.__step()\n        self = None  # Needed to break cycles when an exception occurs.\n\n\n_PyTask = Task\n\n\ntry:\n    import _asyncio\nexcept ImportError:\n    pass\nelse:\n    # _CTask is needed for tests.\n    Task = _CTask = _asyncio.Task\n\n\ndef create_task(coro, *, name=None, context=None):\n    \"\"\"Schedule the execution of a coroutine object in a spawn task.\n\n    Return a Task object.\n    \"\"\"\n    loop = events.get_running_loop()\n    if context is None:\n        # Use legacy API if context is not needed\n        task = loop.create_task(coro)\n    else:\n        task = loop.create_task(coro, context=context)\n\n    _set_task_name(task, name)\n    return task\n\n\n# wait() and as_completed() similar to those in PEP 3148.\n\nFIRST_COMPLETED = concurrent.futures.FIRST_COMPLETED\nFIRST_EXCEPTION = concurrent.futures.FIRST_EXCEPTION\nALL_COMPLETED = concurrent.futures.ALL_COMPLETED\n\n\nasync def wait(fs, *, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the Futures or Tasks given by fs to complete.\n\n    The fs iterable must not be empty.\n\n    Coroutines will be wrapped in Tasks.\n\n    Returns two sets of Future: (done, pending).\n\n    Usage:\n\n        done, pending = await asyncio.wait(fs)\n\n    Note: This does not raise TimeoutError! Futures that aren't done\n    when the timeout occurs are returned in the second set.\n    \"\"\"\n    if futures.isfuture(fs) or coroutines.iscoroutine(fs):\n        raise TypeError(f\"expect a list of futures, not {type(fs).__name__}\")\n    if not fs:\n        raise ValueError('Set of Tasks/Futures is empty.')\n    if return_when not in (FIRST_COMPLETED, FIRST_EXCEPTION, ALL_COMPLETED):\n        raise ValueError(f'Invalid return_when value: {return_when}')\n\n    fs = set(fs)\n\n    if any(coroutines.iscoroutine(f) for f in fs):\n        raise TypeError(\"Passing coroutines is forbidden, use tasks explicitly.\")\n\n    loop = events.get_running_loop()\n    return await _wait(fs, timeout, return_when, loop)\n\n\ndef _release_waiter(waiter, *args):\n    if not waiter.done():\n        waiter.set_result(None)\n\n\nasync def wait_for(fut, timeout):\n    \"\"\"Wait for the single Future or coroutine to complete, with timeout.\n\n    Coroutine will be wrapped in Task.\n\n    Returns result of the Future or coroutine.  When a timeout occurs,\n    it cancels the task and raises TimeoutError.  To avoid the task\n    cancellation, wrap it in shield().\n\n    If the wait is cancelled, the task is also cancelled.\n\n    This function is a coroutine.\n    \"\"\"\n    loop = events.get_running_loop()\n\n    if timeout is None:\n        return await fut\n\n    if timeout <= 0:\n        fut = ensure_future(fut, loop=loop)\n\n        if fut.done():\n            return fut.result()\n\n        await _cancel_and_wait(fut, loop=loop)\n        try:\n            return fut.result()\n        except exceptions.CancelledError as exc:\n            raise exceptions.TimeoutError() from exc\n\n    waiter = loop.create_future()\n    timeout_handle = loop.call_later(timeout, _release_waiter, waiter)\n    cb = functools.partial(_release_waiter, waiter)\n\n    fut = ensure_future(fut, loop=loop)\n    fut.add_done_callback(cb)\n\n    try:\n        # wait until the future completes or the timeout\n        try:\n            await waiter\n        except exceptions.CancelledError:\n            if fut.done():\n                return fut.result()\n            else:\n                fut.remove_done_callback(cb)\n                # We must ensure that the task is not running\n                # after wait_for() returns.\n                # See https://bugs.python.org/issue32751\n                await _cancel_and_wait(fut, loop=loop)\n                raise\n\n        if fut.done():\n            return fut.result()\n        else:\n            fut.remove_done_callback(cb)\n            # We must ensure that the task is not running\n            # after wait_for() returns.\n            # See https://bugs.python.org/issue32751\n            await _cancel_and_wait(fut, loop=loop)\n            # In case task cancellation failed with some\n            # exception, we should re-raise it\n            # See https://bugs.python.org/issue40607\n            try:\n                return fut.result()\n            except exceptions.CancelledError as exc:\n                raise exceptions.TimeoutError() from exc\n    finally:\n        timeout_handle.cancel()\n\n\nasync def _wait(fs, timeout, return_when, loop):\n    \"\"\"Internal helper for wait().\n\n    The fs argument must be a collection of Futures.\n    \"\"\"\n    assert fs, 'Set of Futures is empty.'\n    waiter = loop.create_future()\n    timeout_handle = None\n    if timeout is not None:\n        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)\n    counter = len(fs)\n\n    def _on_completion(f):\n        nonlocal counter\n        counter -= 1\n        if (counter <= 0 or\n            return_when == FIRST_COMPLETED or\n            return_when == FIRST_EXCEPTION and (not f.cancelled() and\n                                                f.exception() is not None)):\n            if timeout_handle is not None:\n                timeout_handle.cancel()\n            if not waiter.done():\n                waiter.set_result(None)\n\n    for f in fs:\n        f.add_done_callback(_on_completion)\n\n    try:\n        await waiter\n    finally:\n        if timeout_handle is not None:\n            timeout_handle.cancel()\n        for f in fs:\n            f.remove_done_callback(_on_completion)\n\n    done, pending = set(), set()\n    for f in fs:\n        if f.done():\n            done.add(f)\n        else:\n            pending.add(f)\n    return done, pending\n\n\nasync def _cancel_and_wait(fut, loop):\n    \"\"\"Cancel the *fut* future or task and wait until it completes.\"\"\"\n\n    waiter = loop.create_future()\n    cb = functools.partial(_release_waiter, waiter)\n    fut.add_done_callback(cb)\n\n    try:\n        fut.cancel()\n        # We cannot wait on *fut* directly to make\n        # sure _cancel_and_wait itself is reliably cancellable.\n        await waiter\n    finally:\n        fut.remove_done_callback(cb)\n\n\n# This is *not* a @coroutine!  It is just an iterator (yielding Futures).\ndef as_completed(fs, *, timeout=None):\n    \"\"\"Return an iterator whose values are coroutines.\n\n    When waiting for the yielded coroutines you'll get the results (or\n    exceptions!) of the original Futures (or coroutines), in the order\n    in which and as soon as they complete.\n\n    This differs from PEP 3148; the proper way to use this is:\n\n        for f in as_completed(fs):\n            result = await f  # The 'await' may raise.\n            # Use result.\n\n    If a timeout is specified, the 'await' will raise\n    TimeoutError when the timeout occurs before all Futures are done.\n\n    Note: The futures 'f' are not necessarily members of fs.\n    \"\"\"\n    if futures.isfuture(fs) or coroutines.iscoroutine(fs):\n        raise TypeError(f\"expect an iterable of futures, not {type(fs).__name__}\")\n\n    from .queues import Queue  # Import here to avoid circular import problem.\n    done = Queue()\n\n    loop = events._get_event_loop()\n    todo = {ensure_future(f, loop=loop) for f in set(fs)}\n    timeout_handle = None\n\n    def _on_timeout():\n        for f in todo:\n            f.remove_done_callback(_on_completion)\n            done.put_nowait(None)  # Queue a dummy value for _wait_for_one().\n        todo.clear()  # Can't do todo.remove(f) in the loop.\n\n    def _on_completion(f):\n        if not todo:\n            return  # _on_timeout() was here first.\n        todo.remove(f)\n        done.put_nowait(f)\n        if not todo and timeout_handle is not None:\n            timeout_handle.cancel()\n\n    async def _wait_for_one():\n        f = await done.get()\n        if f is None:\n            # Dummy value from _on_timeout().\n            raise exceptions.TimeoutError\n        return f.result()  # May raise f.exception().\n\n    for f in todo:\n        f.add_done_callback(_on_completion)\n    if todo and timeout is not None:\n        timeout_handle = loop.call_later(timeout, _on_timeout)\n    for _ in range(len(todo)):\n        yield _wait_for_one()\n\n\n@types.coroutine\ndef __sleep0():\n    \"\"\"Skip one event loop run cycle.\n\n    This is a private helper for 'asyncio.sleep()', used\n    when the 'delay' is set to 0.  It uses a bare 'yield'\n    expression (which Task.__step knows how to handle)\n    instead of creating a Future object.\n    \"\"\"\n    yield\n\n\nasync def sleep(delay, result=None):\n    \"\"\"Coroutine that completes after a given time (in seconds).\"\"\"\n    if delay <= 0:\n        await __sleep0()\n        return result\n\n    loop = events.get_running_loop()\n    future = loop.create_future()\n    h = loop.call_later(delay,\n                        futures._set_result_unless_cancelled,\n                        future, result)\n    try:\n        return await future\n    finally:\n        h.cancel()\n\n\ndef ensure_future(coro_or_future, *, loop=None):\n    \"\"\"Wrap a coroutine or an awaitable in a future.\n\n    If the argument is a Future, it is returned directly.\n    \"\"\"\n    return _ensure_future(coro_or_future, loop=loop)\n\n\ndef _ensure_future(coro_or_future, *, loop=None):\n    if futures.isfuture(coro_or_future):\n        if loop is not None and loop is not futures._get_loop(coro_or_future):\n            raise ValueError('The future belongs to a different loop than '\n                            'the one specified as the loop argument')\n        return coro_or_future\n    called_wrap_awaitable = False\n    if not coroutines.iscoroutine(coro_or_future):\n        if inspect.isawaitable(coro_or_future):\n            coro_or_future = _wrap_awaitable(coro_or_future)\n            called_wrap_awaitable = True\n        else:\n            raise TypeError('An asyncio.Future, a coroutine or an awaitable '\n                            'is required')\n\n    if loop is None:\n        loop = events._get_event_loop(stacklevel=4)\n    try:\n        return loop.create_task(coro_or_future)\n    except RuntimeError:\n        if not called_wrap_awaitable:\n            coro_or_future.close()\n        raise\n\n\n@types.coroutine\ndef _wrap_awaitable(awaitable):\n    \"\"\"Helper for asyncio.ensure_future().\n\n    Wraps awaitable (an object with __await__) into a coroutine\n    that will later be wrapped in a Task by ensure_future().\n    \"\"\"\n    return (yield from awaitable.__await__())\n\n_wrap_awaitable._is_coroutine = _is_coroutine\n\n\nclass _GatheringFuture(futures.Future):\n    \"\"\"Helper for gather().\n\n    This overrides cancel() to cancel all the children and act more\n    like Task.cancel(), which doesn't immediately mark itself as\n    cancelled.\n    \"\"\"\n\n    def __init__(self, children, *, loop):\n        assert loop is not None\n        super().__init__(loop=loop)\n        self._children = children\n        self._cancel_requested = False\n\n    def cancel(self, msg=None):\n        if self.done():\n            return False\n        ret = False\n        for child in self._children:\n            if child.cancel(msg=msg):\n                ret = True\n        if ret:\n            # If any child tasks were actually cancelled, we should\n            # propagate the cancellation request regardless of\n            # *return_exceptions* argument.  See issue 32684.\n            self._cancel_requested = True\n        return ret\n\n\ndef gather(*coros_or_futures, return_exceptions=False):\n    \"\"\"Return a future aggregating results from the given coroutines/futures.\n\n    Coroutines will be wrapped in a future and scheduled in the event\n    loop. They will not necessarily be scheduled in the same order as\n    passed in.\n\n    All futures must share the same event loop.  If all the tasks are\n    done successfully, the returned future's result is the list of\n    results (in the order of the original sequence, not necessarily\n    the order of results arrival).  If *return_exceptions* is True,\n    exceptions in the tasks are treated the same as successful\n    results, and gathered in the result list; otherwise, the first\n    raised exception will be immediately propagated to the returned\n    future.\n\n    Cancellation: if the outer Future is cancelled, all children (that\n    have not completed yet) are also cancelled.  If any child is\n    cancelled, this is treated as if it raised CancelledError --\n    the outer Future is *not* cancelled in this case.  (This is to\n    prevent the cancellation of one child to cause other children to\n    be cancelled.)\n\n    If *return_exceptions* is False, cancelling gather() after it\n    has been marked done won't cancel any submitted awaitables.\n    For instance, gather can be marked done after propagating an\n    exception to the caller, therefore, calling ``gather.cancel()``\n    after catching an exception (raised by one of the awaitables) from\n    gather won't cancel any other awaitables.\n    \"\"\"\n    if not coros_or_futures:\n        loop = events._get_event_loop()\n        outer = loop.create_future()\n        outer.set_result([])\n        return outer\n\n    def _done_callback(fut):\n        nonlocal nfinished\n        nfinished += 1\n\n        if outer is None or outer.done():\n            if not fut.cancelled():\n                # Mark exception retrieved.\n                fut.exception()\n            return\n\n        if not return_exceptions:\n            if fut.cancelled():\n                # Check if 'fut' is cancelled first, as\n                # 'fut.exception()' will *raise* a CancelledError\n                # instead of returning it.\n                exc = fut._make_cancelled_error()\n                outer.set_exception(exc)\n                return\n            else:\n                exc = fut.exception()\n                if exc is not None:\n                    outer.set_exception(exc)\n                    return\n\n        if nfinished == nfuts:\n            # All futures are done; create a list of results\n            # and set it to the 'outer' future.\n            results = []\n\n            for fut in children:\n                if fut.cancelled():\n                    # Check if 'fut' is cancelled first, as 'fut.exception()'\n                    # will *raise* a CancelledError instead of returning it.\n                    # Also, since we're adding the exception return value\n                    # to 'results' instead of raising it, don't bother\n                    # setting __context__.  This also lets us preserve\n                    # calling '_make_cancelled_error()' at most once.\n                    res = exceptions.CancelledError(\n                        '' if fut._cancel_message is None else\n                        fut._cancel_message)\n                else:\n                    res = fut.exception()\n                    if res is None:\n                        res = fut.result()\n                results.append(res)\n\n            if outer._cancel_requested:\n                # If gather is being cancelled we must propagate the\n                # cancellation regardless of *return_exceptions* argument.\n                # See issue 32684.\n                exc = fut._make_cancelled_error()\n                outer.set_exception(exc)\n            else:\n                outer.set_result(results)\n\n    arg_to_fut = {}\n    children = []\n    nfuts = 0\n    nfinished = 0\n    loop = None\n    outer = None  # bpo-46672\n    for arg in coros_or_futures:\n        if arg not in arg_to_fut:\n            fut = _ensure_future(arg, loop=loop)\n            if loop is None:\n                loop = futures._get_loop(fut)\n            if fut is not arg:\n                # 'arg' was not a Future, therefore, 'fut' is a new\n                # Future created specifically for 'arg'.  Since the caller\n                # can't control it, disable the \"destroy pending task\"\n                # warning.\n                fut._log_destroy_pending = False\n\n            nfuts += 1\n            arg_to_fut[arg] = fut\n            fut.add_done_callback(_done_callback)\n\n        else:\n            # There's a duplicate Future object in coros_or_futures.\n            fut = arg_to_fut[arg]\n\n        children.append(fut)\n\n    outer = _GatheringFuture(children, loop=loop)\n    return outer\n\n\ndef shield(arg):\n    \"\"\"Wait for a future, shielding it from cancellation.\n\n    The statement\n\n        task = asyncio.create_task(something())\n        res = await shield(task)\n\n    is exactly equivalent to the statement\n\n        res = await something()\n\n    *except* that if the coroutine containing it is cancelled, the\n    task running in something() is not cancelled.  From the POV of\n    something(), the cancellation did not happen.  But its caller is\n    still cancelled, so the yield-from expression still raises\n    CancelledError.  Note: If something() is cancelled by other means\n    this will still cancel shield().\n\n    If you want to completely ignore cancellation (not recommended)\n    you can combine shield() with a try/except clause, as follows:\n\n        task = asyncio.create_task(something())\n        try:\n            res = await shield(task)\n        except CancelledError:\n            res = None\n\n    Save a reference to tasks passed to this function, to avoid\n    a task disappearing mid-execution. The event loop only keeps\n    weak references to tasks. A task that isn't referenced elsewhere\n    may get garbage collected at any time, even before it's done.\n    \"\"\"\n    inner = _ensure_future(arg)\n    if inner.done():\n        # Shortcut.\n        return inner\n    loop = futures._get_loop(inner)\n    outer = loop.create_future()\n\n    def _inner_done_callback(inner):\n        if outer.cancelled():\n            if not inner.cancelled():\n                # Mark inner's result as retrieved.\n                inner.exception()\n            return\n\n        if inner.cancelled():\n            outer.cancel()\n        else:\n            exc = inner.exception()\n            if exc is not None:\n                outer.set_exception(exc)\n            else:\n                outer.set_result(inner.result())\n\n\n    def _outer_done_callback(outer):\n        if not inner.done():\n            inner.remove_done_callback(_inner_done_callback)\n\n    inner.add_done_callback(_inner_done_callback)\n    outer.add_done_callback(_outer_done_callback)\n    return outer\n\n\ndef run_coroutine_threadsafe(coro, loop):\n    \"\"\"Submit a coroutine object to a given event loop.\n\n    Return a concurrent.futures.Future to access the result.\n    \"\"\"\n    if not coroutines.iscoroutine(coro):\n        raise TypeError('A coroutine object is required')\n    future = concurrent.futures.Future()\n\n    def callback():\n        try:\n            futures._chain_future(ensure_future(coro, loop=loop), future)\n        except (SystemExit, KeyboardInterrupt):\n            raise\n        except BaseException as exc:\n            if future.set_running_or_notify_cancel():\n                future.set_exception(exc)\n            raise\n\n    loop.call_soon_threadsafe(callback)\n    return future\n\n\n# WeakSet containing all alive tasks.\n_all_tasks = weakref.WeakSet()\n\n# Dictionary containing tasks that are currently active in\n# all running event loops.  {EventLoop: Task}\n_current_tasks = {}\n\n\ndef _register_task(task):\n    \"\"\"Register a new task in asyncio as executed by loop.\"\"\"\n    _all_tasks.add(task)\n\n\ndef _enter_task(loop, task):\n    current_task = _current_tasks.get(loop)\n    if current_task is not None:\n        raise RuntimeError(f\"Cannot enter into task {task!r} while another \"\n                           f\"task {current_task!r} is being executed.\")\n    _current_tasks[loop] = task\n\n\ndef _leave_task(loop, task):\n    current_task = _current_tasks.get(loop)\n    if current_task is not task:\n        raise RuntimeError(f\"Leaving task {task!r} does not match \"\n                           f\"the current task {current_task!r}.\")\n    del _current_tasks[loop]\n\n\ndef _unregister_task(task):\n    \"\"\"Unregister a task.\"\"\"\n    _all_tasks.discard(task)\n\n\n_py_register_task = _register_task\n_py_unregister_task = _unregister_task\n_py_enter_task = _enter_task\n_py_leave_task = _leave_task\n\n\ntry:\n    from _asyncio import (_register_task, _unregister_task,\n                          _enter_task, _leave_task,\n                          _all_tasks, _current_tasks)\nexcept ImportError:\n    pass\nelse:\n    _c_register_task = _register_task\n    _c_unregister_task = _unregister_task\n    _c_enter_task = _enter_task\n    _c_leave_task = _leave_task\n", 990], "/app/app/providers/finnhub_provider.py": ["import finnhub\nimport logging\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Optional\nfrom .base import DataProvider\n\nlogger = logging.getLogger(__name__)\n\nclass FinnhubProvider(DataProvider):\n    def __init__(self, api_key: str = \"demo\"):\n        super().__init__(\"Finnhub\")\n        self.api_key = api_key\n        self.client = finnhub.Client(api_key=api_key)\n        self.rate_limit_delay = 1.0  # 60 calls/minute = 1 call/second for free tier\n        \n    async def get_price(self, symbol: str) -> Optional[Dict]:\n        \"\"\"Get current stock price from Finnhub\"\"\"\n        try:\n            # Add rate limiting\n            await asyncio.sleep(self.rate_limit_delay)\n            \n            # Get current price quote\n            quote = await asyncio.to_thread(self.client.quote, symbol)\n            \n            if not quote or 'c' not in quote:\n                return None\n            \n            current_price = float(quote['c'])  # Current price\n            previous_close = float(quote['pc'])  # Previous close\n            \n            if current_price == 0:\n                return None\n            \n            change = current_price - previous_close\n            change_percent = (change / previous_close * 100) if previous_close != 0 else 0\n            \n            self.mark_available()\n            return {\n                \"symbol\": symbol.upper(),\n                \"price\": round(current_price, 2),\n                \"change\": round(change, 2),\n                \"change_percent\": round(change_percent, 2),\n                \"high\": round(float(quote.get('h', current_price)), 2),  # Day high\n                \"low\": round(float(quote.get('l', current_price)), 2),   # Day low\n                \"open\": round(float(quote.get('o', current_price)), 2),  # Day open\n                \"previous_close\": round(previous_close, 2),\n                \"timestamp\": datetime.now().isoformat(),\n                \"source\": self.name\n            }\n            \n        except Exception as e:\n            error_msg = f\"Finnhub error for {symbol}: {e}\"\n            self.mark_unavailable(error_msg)\n            logger.error(error_msg)\n            return None\n    \n    async def get_historical(self, symbol: str, period: str = \"1mo\") -> Optional[Dict]:\n        \"\"\"Get historical data from Finnhub\"\"\"\n        try:\n            await asyncio.sleep(self.rate_limit_delay)\n            \n            # Convert period to date range\n            end_date = datetime.now()\n            \n            period_map = {\n                \"1d\": 1,\n                \"5d\": 5,\n                \"1mo\": 30,\n                \"3mo\": 90,\n                \"6mo\": 180,\n                \"1y\": 365\n            }\n            \n            days = period_map.get(period, 30)\n            start_date = end_date - timedelta(days=days)\n            \n            # Convert to Unix timestamps\n            start_ts = int(start_date.timestamp())\n            end_ts = int(end_date.timestamp())\n            \n            # Get candle data (daily resolution)\n            candles = await asyncio.to_thread(\n                self.client.stock_candles, \n                symbol, \n                'D',  # Daily resolution\n                start_ts, \n                end_ts\n            )\n            \n            if not candles or candles['s'] != 'ok':\n                return None\n            \n            data = []\n            timestamps = candles['t']\n            opens = candles['o']\n            highs = candles['h']\n            lows = candles['l']\n            closes = candles['c']\n            volumes = candles['v']\n            \n            for i in range(len(timestamps)):\n                date = datetime.fromtimestamp(timestamps[i])\n                data.append({\n                    \"date\": date.strftime(\"%Y-%m-%d\"),\n                    \"open\": round(float(opens[i]), 2),\n                    \"high\": round(float(highs[i]), 2),\n                    \"low\": round(float(lows[i]), 2),\n                    \"close\": round(float(closes[i]), 2),\n                    \"volume\": int(volumes[i])\n                })\n            \n            return {\n                \"symbol\": symbol.upper(),\n                \"period\": period,\n                \"data\": data,\n                \"source\": self.name\n            }\n            \n        except Exception as e:\n            logger.error(f\"Finnhub historical error for {symbol}: {e}\")\n            return None\n\n    async def get_company_profile(self, symbol: str) -> Optional[Dict]:\n        \"\"\"Get company profile data\"\"\"\n        try:\n            await asyncio.sleep(self.rate_limit_delay)\n            \n            profile = await asyncio.to_thread(self.client.company_profile2, symbol=symbol)\n            \n            if not profile:\n                return None\n                \n            return {\n                \"symbol\": symbol.upper(),\n                \"name\": profile.get('name'),\n                \"country\": profile.get('country'),\n                \"currency\": profile.get('currency'),\n                \"exchange\": profile.get('exchange'),\n                \"ipo\": profile.get('ipo'),\n                \"market_cap\": profile.get('marketCapitalization'),\n                \"shares_outstanding\": profile.get('shareOutstanding'),\n                \"logo\": profile.get('logo'),\n                \"phone\": profile.get('phone'),\n                \"weburl\": profile.get('weburl'),\n                \"industry\": profile.get('finnhubIndustry'),\n                \"source\": self.name\n            }\n            \n        except Exception as e:\n            logger.error(f\"Finnhub company profile error for {symbol}: {e}\")\n            return None\n\n    async def get_news_sentiment(self, symbol: str) -> Optional[Dict]:\n        \"\"\"Get news sentiment for a symbol\"\"\"\n        try:\n            await asyncio.sleep(self.rate_limit_delay)\n            \n            sentiment = await asyncio.to_thread(self.client.news_sentiment, symbol)\n            \n            if not sentiment:\n                return None\n                \n            return {\n                \"symbol\": symbol.upper(),\n                \"sentiment\": {\n                    \"buzz\": sentiment.get('buzz', {}),\n                    \"sentiment\": sentiment.get('sentiment', {}),\n                    \"company_news_score\": sentiment.get('companyNewsScore'),\n                    \"sector_average_bullishness\": sentiment.get('sectorAverageBullishness'),\n                    \"sector_average_news_score\": sentiment.get('sectorAverageNewsScore')\n                },\n                \"source\": self.name\n            }\n            \n        except Exception as e:\n            logger.error(f\"Finnhub news sentiment error for {symbol}: {e}\")\n            return None\n\n    async def get_intraday(self, symbol: str, interval: str = \"1m\") -> Optional[Dict]:\n        \"\"\"Get intraday minute data from Finnhub\"\"\"\n        try:\n            await asyncio.sleep(self.rate_limit_delay)\n\n            end_date = datetime.now()\n            # fetch last trading day window (~6.5h = 390 minutes)\n            start_date = end_date - timedelta(hours=8)\n            start_ts = int(start_date.timestamp())\n            end_ts = int(end_date.timestamp())\n\n            resolution = '1'  # 1-minute\n            candles = await asyncio.to_thread(self.client.stock_candles, symbol, resolution, start_ts, end_ts)\n            if not candles or candles.get('s') != 'ok':\n                return None\n\n            data = []\n            for i, ts in enumerate(candles['t']):\n                date = datetime.fromtimestamp(ts)\n                data.append({\n                    \"timestamp\": date.isoformat(),\n                    \"open\": round(float(candles['o'][i]), 4),\n                    \"high\": round(float(candles['h'][i]), 4),\n                    \"low\": round(float(candles['l'][i]), 4),\n                    \"close\": round(float(candles['c'][i]), 4),\n                    \"volume\": int(candles['v'][i])\n                })\n\n            return {\"symbol\": symbol.upper(), \"interval\": interval, \"data\": data, \"source\": self.name}\n        except Exception as e:\n            logger.error(f\"Finnhub intraday error for {symbol}: {e}\")\n            return None\n", 211], "/app/app/services/market_data.py": ["import asyncio\nimport logging\nimport os\nimport time\nfrom datetime import datetime, timezone\nfrom typing import Dict, List, Optional\n\nfrom fastapi import HTTPException\n\nfrom ..circuit_breaker import CircuitBreakerManager\nfrom ..core.config import get_settings\nfrom ..providers import FinnhubProvider, YahooFinanceProvider\nfrom ..providers.registry import ProviderRegistry\nfrom .cache import DataCache\nfrom .database import db_service\nfrom .data_collector import DataCollectorService\nfrom .macro_data_service import MacroFactorService\nfrom .options_service import options_service\nfrom .websocket import ConnectionManager\n\nlogger = logging.getLogger(__name__)\n\nclass MarketDataService:\n    SUPPORTED_INTRADAY_INTERVALS = {\n        \"1m\",\n        \"2m\",\n        \"5m\",\n        \"15m\",\n        \"30m\",\n        \"60m\",\n        \"90m\",\n    }\n\n    def __init__(self):\n        self.settings = get_settings()\n        self.breakers = CircuitBreakerManager()\n        self.registry = ProviderRegistry(self.breakers)\n\n        self._init_providers()\n        self.providers = [entry.adapter for entry in self.registry.providers.values()]\n\n        # Cache TTL configurable via env/settings\n        cache_ttl = int(os.getenv(\"CACHE_TTL_SECONDS\", self.settings.cache_ttl_seconds))\n        self.cache = DataCache(ttl_seconds=cache_ttl)\n        self.metrics_cache = DataCache(ttl_seconds=int(os.getenv(\"OPTIONS_METRICS_CACHE_TTL\", \"300\")))\n        self.options_metrics_ttl = int(os.getenv(\"OPTIONS_METRICS_TTL\", \"900\"))\n        self.update_interval = int(os.getenv(\"WEBSOCKET_UPDATE_INTERVAL\", \"5\"))\n        self.connection_manager = ConnectionManager()\n        self.macro_service = MacroFactorService(\n            providers=self.providers,\n            cache_ttl_seconds=getattr(self.settings, \"macro_cache_ttl_seconds\", 300),\n            refresh_interval_seconds=getattr(self.settings, \"macro_refresh_interval_seconds\", 900),\n        )\n        self.data_collector = DataCollectorService(db=db_service, registry=self.registry)\n        self.background_tasks_running = False\n\n    def _init_providers(self) -> None:\n        \"\"\"Register provider adapters with the routing registry.\"\"\"\n        finnhub_key = (\n            os.getenv(\"FINNHUB_API_KEY\")\n            or self.settings.finnhub.api_key\n            or self.settings.finnhub_api_key\n        )\n\n        if finnhub_key and finnhub_key not in {\"your_finnhub_api_key_here\", \"\"}:\n            try:\n                finnhub_provider = FinnhubProvider(api_key=finnhub_key)\n                self.registry.register(\"finnhub\", finnhub_provider, {\"bars_1m\", \"eod\", \"quotes_l1\"})\n                logger.info(\"Finnhub provider registered\")\n            except Exception as exc:  # pragma: no cover - defensive\n                logger.warning(\"Failed to initialize Finnhub provider: %s\", exc)\n        else:\n            logger.warning(\"No valid Finnhub API key provided; Finnhub disabled\")\n\n        if self.settings.yfinance_enabled:\n            try:\n                yahoo_provider = YahooFinanceProvider()\n                self.registry.register(\"yfinance\", yahoo_provider, {\"bars_1m\", \"eod\", \"options_chain\"})\n                logger.info(\"Yahoo Finance provider registered\")\n            except Exception as exc:  # pragma: no cover\n                logger.warning(\"Failed to initialize Yahoo Finance provider: %s\", exc)\n\n    def reload_configuration(self) -> None:\n        \"\"\"Reload providers and settings after a hot reload.\"\"\"\n        self.settings = get_settings()\n        self.registry.providers.clear()\n        self._init_providers()\n        self.providers = [entry.adapter for entry in self.registry.providers.values()]\n        if hasattr(self.macro_service, \"providers\"):\n            self.macro_service.providers = self.providers\n\n    async def _try_providers(\n        self,\n        *,\n        capability: str,\n        endpoint: str,\n        executor,\n        provider_hint: Optional[str] = None,\n    ):\n        ranked = self.registry.rank(capability, provider_hint=provider_hint)\n        if not ranked:\n            raise HTTPException(status_code=503, detail=f\"No providers available for {capability}\")\n\n        last_error: Optional[str] = None\n        for provider_name in ranked:\n            entry = self.registry.providers[provider_name]\n            adapter = entry.adapter\n            if not adapter.enabled:\n                continue\n\n            self.registry.record_selection(capability, provider_name)\n            started = time.perf_counter()\n\n            try:\n                result = await executor(adapter)\n                elapsed_ms = (time.perf_counter() - started) * 1000.0\n                self.registry.record_outcome(provider_name, elapsed_ms, error=False, endpoint=endpoint)\n                if result:\n                    return result, provider_name\n                last_error = f\"{provider_name}: empty result\"\n            except HTTPException:\n                raise\n            except Exception as exc:  # pragma: no cover - provider failure paths\n                elapsed_ms = (time.perf_counter() - started) * 1000.0\n                self.registry.record_outcome(provider_name, elapsed_ms, error=True, endpoint=endpoint)\n                self.registry.record_error(provider_name, endpoint, exc.__class__.__name__)\n                last_error = f\"{provider_name}: {exc}\"\n\n        raise HTTPException(\n            status_code=502,\n            detail=f\"All providers failed for {endpoint}. last_error={last_error}\",\n        )\n    \n    async def get_stock_price(self, symbol: str) -> Dict:\n        \"\"\"Get stock price with caching and health-aware routing.\"\"\"\n        symbol = symbol.upper()\n        cache_key = f\"price:{symbol}\"\n\n        cached_data = self.cache.get(cache_key)\n        if cached_data:\n            logger.info(\"Cache hit for %s\", symbol)\n            return cached_data\n\n        data, provider_used = await self._try_providers(\n            capability=\"quotes_l1\",\n            endpoint=\"quotes\",\n            executor=lambda adapter: adapter.get_price_safe(symbol),\n        )\n\n        if isinstance(data, dict):\n            data[\"provider_used\"] = provider_used\n        self.cache.set(cache_key, data)\n        logger.info(\"Fetched %s from %s\", symbol, provider_used)\n        return data\n    \n    async def get_historical_data(self, symbol: str, period: str = \"1mo\") -> Dict:\n        \"\"\"Get historical data.\"\"\"\n        symbol = symbol.upper()\n        data, provider_used = await self._try_providers(\n            capability=\"eod\",\n            endpoint=\"historical\",\n            executor=lambda adapter: adapter.get_historical_safe(symbol, period),\n        )\n\n        if isinstance(data, dict):\n            data[\"provider_used\"] = provider_used\n        return data\n\n    def _normalize_intraday_interval(self, interval: str) -> str:\n        interval_normalized = (interval or \"1m\").strip().lower()\n\n        # Map common aliases to supported values\n        alias_map = {\n            \"1\": \"1m\",\n            \"5\": \"5m\",\n            \"15\": \"15m\",\n            \"30\": \"30m\",\n            \"60\": \"60m\",\n            \"1min\": \"1m\",\n            \"5min\": \"5m\",\n            \"15min\": \"15m\",\n            \"30min\": \"30m\",\n            \"60min\": \"60m\",\n            \"1hour\": \"60m\",\n            \"1hr\": \"60m\",\n            \"1h\": \"60m\",\n        }\n\n        resolved = alias_map.get(interval_normalized, interval_normalized)\n        if resolved not in self.SUPPORTED_INTRADAY_INTERVALS:\n            raise HTTPException(\n                status_code=400,\n                detail=f\"Unsupported intraday interval '{interval}'\"\n            )\n        return resolved\n\n    async def get_intraday_data(self, symbol: str, interval: str = \"1m\") -> Dict:\n        \"\"\"Get intraday data with provider fallback and validation.\"\"\"\n        normalized_interval = self._normalize_intraday_interval(interval)\n\n        capability = \"bars_1m\" if normalized_interval.endswith(\"m\") else \"eod\"\n        data, provider_used = await self._try_providers(\n            capability=capability,\n            endpoint=\"intraday\",\n            executor=lambda adapter: adapter.get_intraday_safe(symbol, normalized_interval),\n        )\n\n        if isinstance(data, dict):\n            data[\"provider_used\"] = provider_used\n        return data\n    \n    async def start_background_tasks(self):\n        \"\"\"Start background tasks for cache cleanup and real-time updates\"\"\"\n        if self.background_tasks_running:\n            return\n\n        self.background_tasks_running = True\n\n        # Initialize database connections for macro storage\n        try:\n            await db_service.initialize()\n            logger.info(\"Database service initialized\")\n        except Exception as exc:\n            logger.error(f\"Failed to initialize database service: {exc}\")\n\n        # Start cache cleanup task\n        asyncio.create_task(self._cache_cleanup_task())\n\n        # Start macro refresh task\n        asyncio.create_task(self._macro_refresh_task())\n\n        # Start real-time data broadcasting\n        asyncio.create_task(self._real_time_broadcast_task())\n\n        # Start data collector (M2/M3: RLC consumer + gap detection + backfill)\n        asyncio.create_task(self.data_collector.run())\n\n        logger.info(\"Background tasks started (including data collector)\")\n    \n    async def _cache_cleanup_task(self):\n        \"\"\"Clean up expired cache entries\"\"\"\n        while self.background_tasks_running:\n            self.cache.clear_expired()\n            await asyncio.sleep(60)  # Clean up every minute\n    \n    async def _real_time_broadcast_task(self):\n        \"\"\"Broadcast real-time data to WebSocket clients\"\"\"\n        while self.background_tasks_running:\n            if self.connection_manager.symbol_subscribers:\n                for symbol in list(self.connection_manager.symbol_subscribers.keys()):\n                    try:\n                        data = await self.get_stock_price(symbol)\n                        await self.connection_manager.broadcast_to_symbol(symbol, data)\n                    except Exception as e:\n                        logger.error(f\"Error broadcasting {symbol}: {e}\")\n\n            await asyncio.sleep(self.update_interval)  # Update interval configurable\n\n    async def _macro_refresh_task(self):\n        \"\"\"Periodically refresh macro factors from configured providers.\"\"\"\n        interval = getattr(\n            self.macro_service,\n            \"refresh_interval_seconds\",\n            getattr(self.settings, \"macro_refresh_interval_seconds\", 900),\n        )\n        interval = max(60, interval or 900)\n\n        try:\n            await self.macro_service.refresh_all()\n        except Exception as exc:\n            logger.error(f\"Initial macro refresh failed: {exc}\")\n\n        while self.background_tasks_running:\n            await asyncio.sleep(interval)\n            try:\n                await self.macro_service.refresh_all()\n            except Exception as exc:\n                logger.error(f\"Macro refresh task failed: {exc}\")\n\n    async def get_company_profile(self, symbol: str) -> Dict:\n        \"\"\"Get company profile data (Finnhub only)\"\"\"\n        for provider in self.providers:\n            if hasattr(provider, 'get_company_profile'):\n                data = await provider.get_company_profile(symbol)\n                if data:\n                    return data\n        \n        raise HTTPException(\n            status_code=503,\n            detail=f\"Unable to fetch company profile for {symbol}\"\n        )\n    \n    async def get_news_sentiment(self, symbol: str) -> Dict:\n        \"\"\"Get news sentiment data (Finnhub only)\"\"\"\n        for provider in self.providers:\n            if hasattr(provider, 'get_news_sentiment'):\n                data = await provider.get_news_sentiment(symbol)\n                if data:\n                    return data\n        \n        raise HTTPException(\n            status_code=503,\n            detail=f\"Unable to fetch news sentiment for {symbol}\"\n        )\n    \n\n    async def get_options_metrics(self, symbol: str) -> Dict:\n        \"\"\"Return cached or freshly computed options metrics for a symbol.\"\"\"\n        symbol = symbol.upper()\n        cache_key = f\"options_metrics:{symbol}\"\n        cached = self.metrics_cache.get(cache_key)\n        if cached:\n            return cached\n\n        latest = await db_service.get_latest_options_metrics(symbol)\n        if latest:\n            try:\n                timestamp = datetime.fromisoformat(latest['as_of'])\n                if timestamp.tzinfo is None:\n                    timestamp = timestamp.replace(tzinfo=timezone.utc)\n                if (datetime.now(timezone.utc) - timestamp).total_seconds() < self.options_metrics_ttl:\n                    self.metrics_cache.set(cache_key, latest)\n                    return latest\n            except Exception:\n                pass\n\n        chain = await options_service.fetch_options_chain(symbol)\n        metrics = options_service.calculate_chain_metrics(chain)\n        record = metrics.to_db_record()\n        await db_service.store_options_metrics(record)\n        result = metrics.to_dict()\n        result['metadata'].setdefault('source', 'provider')\n        self.metrics_cache.set(cache_key, result)\n        return result\n\n    async def get_options_metrics_history(self, symbol: str, limit: int = 50) -> List[Dict]:\n        \"\"\"Return recent history of stored options metrics for a symbol.\"\"\"\n        history = await db_service.get_options_metrics_history(symbol.upper(), limit)\n        return history\n\n    async def get_stats(self) -> Dict:\n        macro_stats = await self.macro_service.stats()\n        return {\n            \"providers\": [\n                {\n                    \"name\": provider.name,\n                    \"available\": provider.is_available,\n                    \"last_error\": provider.last_error,\n                }\n                for provider in self.providers\n            ],\n            \"cache\": self.cache.stats(),\n            \"websocket\": self.connection_manager.stats(),\n            \"database\": {\n                \"connected\": db_service.pool is not None,\n                \"storage_enabled\": self.settings.store_historical_data,\n            },\n            \"macro\": macro_stats,\n            \"options_metrics\": {\n                \"cache\": self.metrics_cache.stats(),\n                \"ttl_seconds\": self.options_metrics_ttl,\n            },\n        }\n\n    async def get_macro_snapshot(self, factors: Optional[List[str]] = None) -> Dict:\n        \"\"\"Return the latest macro factor snapshot.\"\"\"\n        return await self.macro_service.get_snapshot(factors)\n\n    async def get_macro_history(self, factor_key: str, lookback_days: int = 30) -> Dict:\n        \"\"\"Return macro factor history for the requested lookback window.\"\"\"\n        return await self.macro_service.get_history(factor_key, lookback_days)\n\n    def list_macro_factors(self) -> List[str]:\n        \"\"\"List available macro factor keys.\"\"\"\n        return self.macro_service.available_factors()\n\n    async def refresh_macro_factors(self, factor_key: Optional[str] = None) -> Dict:\n        \"\"\"Refresh macro factors from providers.\"\"\"\n        if factor_key:\n            return await self.macro_service.refresh_factor(factor_key)\n        return await self.macro_service.refresh_all()\n    \n    async def get_unusual_options_activity(self, symbol: str, lookback_days: int = 20) -> Dict:\n        \"\"\"Get unusual options activity for a symbol\"\"\"\n        try:\n            unusual_activities = await options_service.detect_unusual_activity(symbol.upper(), lookback_days)\n            \n            return {\n                \"symbol\": symbol.upper(),\n                \"lookback_days\": lookback_days,\n                \"unusual_activities_count\": len(unusual_activities),\n                \"unusual_activities\": [\n                    {\n                        \"contract_symbol\": activity.contract_symbol,\n                        \"strike\": activity.strike,\n                        \"expiry\": activity.expiry.isoformat(),\n                        \"option_type\": activity.option_type,\n                        \"volume\": activity.volume,\n                        \"avg_volume_20d\": activity.avg_volume_20d,\n                        \"volume_ratio\": activity.volume_ratio,\n                        \"open_interest\": activity.open_interest,\n                        \"volume_spike\": activity.volume_spike,\n                        \"large_single_trades\": activity.large_single_trades,\n                        \"sweep_activity\": activity.sweep_activity,\n                        \"unusual_volume_vs_oi\": activity.unusual_volume_vs_oi,\n                        \"underlying_price\": activity.underlying_price,\n                        \"strike_distance_pct\": activity.strike_distance_pct,\n                        \"days_to_expiration\": activity.days_to_expiration,\n                        \"unusual_score\": activity.unusual_score,\n                        \"confidence_level\": activity.confidence_level,\n                        \"large_trades\": activity.large_trades,\n                        \"timestamp\": activity.timestamp.isoformat()\n                    }\n                    for activity in unusual_activities\n                ],\n                \"analysis_timestamp\": datetime.now().isoformat()\n            }\n        except Exception as e:\n            logger.error(f\"Error getting unusual options activity for {symbol}: {e}\")\n            return {\n                \"symbol\": symbol.upper(),\n                \"error\": str(e),\n                \"unusual_activities_count\": 0,\n                \"unusual_activities\": []\n            }\n    \n    async def get_options_flow_analysis(self, symbol: str) -> Dict:\n        \"\"\"Get comprehensive options flow analysis\"\"\"\n        try:\n            flow_analysis = await options_service.analyze_options_flow(symbol.upper())\n            \n            return {\n                \"symbol\": symbol.upper(),\n                \"timestamp\": flow_analysis.timestamp.isoformat(),\n                \"flow_metrics\": {\n                    \"total_call_volume\": flow_analysis.total_call_volume,\n                    \"total_put_volume\": flow_analysis.total_put_volume,\n                    \"call_put_ratio\": flow_analysis.call_put_ratio,\n                    \"large_trades_count\": flow_analysis.large_trades_count,\n                    \"block_trades_value\": flow_analysis.block_trades_value,\n                    \"sweep_trades_count\": flow_analysis.sweep_trades_count\n                },\n                \"sentiment_analysis\": {\n                    \"flow_sentiment\": flow_analysis.flow_sentiment,\n                    \"smart_money_score\": flow_analysis.smart_money_score,\n                    \"call_premium_bought\": flow_analysis.call_premium_bought,\n                    \"put_premium_bought\": flow_analysis.put_premium_bought,\n                    \"net_premium_flow\": flow_analysis.net_premium_flow\n                },\n                \"unusual_activities_summary\": {\n                    \"count\": len(flow_analysis.unusual_activities),\n                    \"top_activities\": [\n                        {\n                            \"contract_symbol\": activity.contract_symbol,\n                            \"unusual_score\": activity.unusual_score,\n                            \"volume_ratio\": activity.volume_ratio,\n                            \"volume\": activity.volume,\n                            \"strike\": activity.strike,\n                            \"option_type\": activity.option_type\n                        }\n                        for activity in flow_analysis.unusual_activities[:5]  # Top 5\n                    ]\n                }\n            }\n        except Exception as e:\n            logger.error(f\"Error getting options flow analysis for {symbol}: {e}\")\n            return {\n                \"symbol\": symbol.upper(),\n                \"error\": str(e),\n                \"flow_metrics\": {},\n                \"sentiment_analysis\": {},\n                \"unusual_activities_summary\": {\"count\": 0, \"top_activities\": []}\n            }\n\n", 474], "/usr/local/lib/python3.11/asyncio/futures.py": ["\"\"\"A Future class similar to the one in PEP 3148.\"\"\"\n\n__all__ = (\n    'Future', 'wrap_future', 'isfuture',\n)\n\nimport concurrent.futures\nimport contextvars\nimport logging\nimport sys\nfrom types import GenericAlias\n\nfrom . import base_futures\nfrom . import events\nfrom . import exceptions\nfrom . import format_helpers\n\n\nisfuture = base_futures.isfuture\n\n\n_PENDING = base_futures._PENDING\n_CANCELLED = base_futures._CANCELLED\n_FINISHED = base_futures._FINISHED\n\n\nSTACK_DEBUG = logging.DEBUG - 1  # heavy-duty debugging\n\n\nclass Future:\n    \"\"\"This class is *almost* compatible with concurrent.futures.Future.\n\n    Differences:\n\n    - This class is not thread-safe.\n\n    - result() and exception() do not take a timeout argument and\n      raise an exception when the future isn't done yet.\n\n    - Callbacks registered with add_done_callback() are always called\n      via the event loop's call_soon().\n\n    - This class is not compatible with the wait() and as_completed()\n      methods in the concurrent.futures package.\n\n    (In Python 3.4 or later we may be able to unify the implementations.)\n    \"\"\"\n\n    # Class variables serving as defaults for instance variables.\n    _state = _PENDING\n    _result = None\n    _exception = None\n    _loop = None\n    _source_traceback = None\n    _cancel_message = None\n    # A saved CancelledError for later chaining as an exception context.\n    _cancelled_exc = None\n\n    # This field is used for a dual purpose:\n    # - Its presence is a marker to declare that a class implements\n    #   the Future protocol (i.e. is intended to be duck-type compatible).\n    #   The value must also be not-None, to enable a subclass to declare\n    #   that it is not compatible by setting this to None.\n    # - It is set by __iter__() below so that Task._step() can tell\n    #   the difference between\n    #   `await Future()` or`yield from Future()` (correct) vs.\n    #   `yield Future()` (incorrect).\n    _asyncio_future_blocking = False\n\n    __log_traceback = False\n\n    def __init__(self, *, loop=None):\n        \"\"\"Initialize the future.\n\n        The optional event_loop argument allows explicitly setting the event\n        loop object used by the future. If it's not provided, the future uses\n        the default event loop.\n        \"\"\"\n        if loop is None:\n            self._loop = events._get_event_loop()\n        else:\n            self._loop = loop\n        self._callbacks = []\n        if self._loop.get_debug():\n            self._source_traceback = format_helpers.extract_stack(\n                sys._getframe(1))\n\n    def __repr__(self):\n        return base_futures._future_repr(self)\n\n    def __del__(self):\n        if not self.__log_traceback:\n            # set_exception() was not called, or result() or exception()\n            # has consumed the exception\n            return\n        exc = self._exception\n        context = {\n            'message':\n                f'{self.__class__.__name__} exception was never retrieved',\n            'exception': exc,\n            'future': self,\n        }\n        if self._source_traceback:\n            context['source_traceback'] = self._source_traceback\n        self._loop.call_exception_handler(context)\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n    @property\n    def _log_traceback(self):\n        return self.__log_traceback\n\n    @_log_traceback.setter\n    def _log_traceback(self, val):\n        if val:\n            raise ValueError('_log_traceback can only be set to False')\n        self.__log_traceback = False\n\n    def get_loop(self):\n        \"\"\"Return the event loop the Future is bound to.\"\"\"\n        loop = self._loop\n        if loop is None:\n            raise RuntimeError(\"Future object is not initialized.\")\n        return loop\n\n    def _make_cancelled_error(self):\n        \"\"\"Create the CancelledError to raise if the Future is cancelled.\n\n        This should only be called once when handling a cancellation since\n        it erases the saved context exception value.\n        \"\"\"\n        if self._cancelled_exc is not None:\n            exc = self._cancelled_exc\n            self._cancelled_exc = None\n            return exc\n\n        if self._cancel_message is None:\n            exc = exceptions.CancelledError()\n        else:\n            exc = exceptions.CancelledError(self._cancel_message)\n        exc.__context__ = self._cancelled_exc\n        # Remove the reference since we don't need this anymore.\n        self._cancelled_exc = None\n        return exc\n\n    def cancel(self, msg=None):\n        \"\"\"Cancel the future and schedule callbacks.\n\n        If the future is already done or cancelled, return False.  Otherwise,\n        change the future's state to cancelled, schedule the callbacks and\n        return True.\n        \"\"\"\n        self.__log_traceback = False\n        if self._state != _PENDING:\n            return False\n        self._state = _CANCELLED\n        self._cancel_message = msg\n        self.__schedule_callbacks()\n        return True\n\n    def __schedule_callbacks(self):\n        \"\"\"Internal: Ask the event loop to call all callbacks.\n\n        The callbacks are scheduled to be called as soon as possible. Also\n        clears the callback list.\n        \"\"\"\n        callbacks = self._callbacks[:]\n        if not callbacks:\n            return\n\n        self._callbacks[:] = []\n        for callback, ctx in callbacks:\n            self._loop.call_soon(callback, self, context=ctx)\n\n    def cancelled(self):\n        \"\"\"Return True if the future was cancelled.\"\"\"\n        return self._state == _CANCELLED\n\n    # Don't implement running(); see http://bugs.python.org/issue18699\n\n    def done(self):\n        \"\"\"Return True if the future is done.\n\n        Done means either that a result / exception are available, or that the\n        future was cancelled.\n        \"\"\"\n        return self._state != _PENDING\n\n    def result(self):\n        \"\"\"Return the result this future represents.\n\n        If the future has been cancelled, raises CancelledError.  If the\n        future's result isn't yet available, raises InvalidStateError.  If\n        the future is done and has an exception set, this exception is raised.\n        \"\"\"\n        if self._state == _CANCELLED:\n            exc = self._make_cancelled_error()\n            raise exc\n        if self._state != _FINISHED:\n            raise exceptions.InvalidStateError('Result is not ready.')\n        self.__log_traceback = False\n        if self._exception is not None:\n            raise self._exception.with_traceback(self._exception_tb)\n        return self._result\n\n    def exception(self):\n        \"\"\"Return the exception that was set on this future.\n\n        The exception (or None if no exception was set) is returned only if\n        the future is done.  If the future has been cancelled, raises\n        CancelledError.  If the future isn't done yet, raises\n        InvalidStateError.\n        \"\"\"\n        if self._state == _CANCELLED:\n            exc = self._make_cancelled_error()\n            raise exc\n        if self._state != _FINISHED:\n            raise exceptions.InvalidStateError('Exception is not set.')\n        self.__log_traceback = False\n        return self._exception\n\n    def add_done_callback(self, fn, *, context=None):\n        \"\"\"Add a callback to be run when the future becomes done.\n\n        The callback is called with a single argument - the future object. If\n        the future is already done when this is called, the callback is\n        scheduled with call_soon.\n        \"\"\"\n        if self._state != _PENDING:\n            self._loop.call_soon(fn, self, context=context)\n        else:\n            if context is None:\n                context = contextvars.copy_context()\n            self._callbacks.append((fn, context))\n\n    # New method not in PEP 3148.\n\n    def remove_done_callback(self, fn):\n        \"\"\"Remove all instances of a callback from the \"call when done\" list.\n\n        Returns the number of callbacks removed.\n        \"\"\"\n        filtered_callbacks = [(f, ctx)\n                              for (f, ctx) in self._callbacks\n                              if f != fn]\n        removed_count = len(self._callbacks) - len(filtered_callbacks)\n        if removed_count:\n            self._callbacks[:] = filtered_callbacks\n        return removed_count\n\n    # So-called internal methods (note: no set_running_or_notify_cancel()).\n\n    def set_result(self, result):\n        \"\"\"Mark the future done and set its result.\n\n        If the future is already done when this method is called, raises\n        InvalidStateError.\n        \"\"\"\n        if self._state != _PENDING:\n            raise exceptions.InvalidStateError(f'{self._state}: {self!r}')\n        self._result = result\n        self._state = _FINISHED\n        self.__schedule_callbacks()\n\n    def set_exception(self, exception):\n        \"\"\"Mark the future done and set an exception.\n\n        If the future is already done when this method is called, raises\n        InvalidStateError.\n        \"\"\"\n        if self._state != _PENDING:\n            raise exceptions.InvalidStateError(f'{self._state}: {self!r}')\n        if isinstance(exception, type):\n            exception = exception()\n        if type(exception) is StopIteration:\n            raise TypeError(\"StopIteration interacts badly with generators \"\n                            \"and cannot be raised into a Future\")\n        self._exception = exception\n        self._exception_tb = exception.__traceback__\n        self._state = _FINISHED\n        self.__schedule_callbacks()\n        self.__log_traceback = True\n\n    def __await__(self):\n        if not self.done():\n            self._asyncio_future_blocking = True\n            yield self  # This tells Task to wait for completion.\n        if not self.done():\n            raise RuntimeError(\"await wasn't used with future\")\n        return self.result()  # May raise too.\n\n    __iter__ = __await__  # make compatible with 'yield from'.\n\n\n# Needed for testing purposes.\n_PyFuture = Future\n\n\ndef _get_loop(fut):\n    # Tries to call Future.get_loop() if it's available.\n    # Otherwise fallbacks to using the old '_loop' property.\n    try:\n        get_loop = fut.get_loop\n    except AttributeError:\n        pass\n    else:\n        return get_loop()\n    return fut._loop\n\n\ndef _set_result_unless_cancelled(fut, result):\n    \"\"\"Helper setting the result only if the future was not cancelled.\"\"\"\n    if fut.cancelled():\n        return\n    fut.set_result(result)\n\n\ndef _convert_future_exc(exc):\n    exc_class = type(exc)\n    if exc_class is concurrent.futures.CancelledError:\n        return exceptions.CancelledError(*exc.args)\n    elif exc_class is concurrent.futures.TimeoutError:\n        return exceptions.TimeoutError(*exc.args)\n    elif exc_class is concurrent.futures.InvalidStateError:\n        return exceptions.InvalidStateError(*exc.args)\n    else:\n        return exc\n\n\ndef _set_concurrent_future_state(concurrent, source):\n    \"\"\"Copy state from a future to a concurrent.futures.Future.\"\"\"\n    assert source.done()\n    if source.cancelled():\n        concurrent.cancel()\n    if not concurrent.set_running_or_notify_cancel():\n        return\n    exception = source.exception()\n    if exception is not None:\n        concurrent.set_exception(_convert_future_exc(exception))\n    else:\n        result = source.result()\n        concurrent.set_result(result)\n\n\ndef _copy_future_state(source, dest):\n    \"\"\"Internal helper to copy state from another Future.\n\n    The other Future may be a concurrent.futures.Future.\n    \"\"\"\n    assert source.done()\n    if dest.cancelled():\n        return\n    assert not dest.done()\n    if source.cancelled():\n        dest.cancel()\n    else:\n        exception = source.exception()\n        if exception is not None:\n            dest.set_exception(_convert_future_exc(exception))\n        else:\n            result = source.result()\n            dest.set_result(result)\n\n\ndef _chain_future(source, destination):\n    \"\"\"Chain two futures so that when one completes, so does the other.\n\n    The result (or exception) of source will be copied to destination.\n    If destination is cancelled, source gets cancelled too.\n    Compatible with both asyncio.Future and concurrent.futures.Future.\n    \"\"\"\n    if not isfuture(source) and not isinstance(source,\n                                               concurrent.futures.Future):\n        raise TypeError('A future is required for source argument')\n    if not isfuture(destination) and not isinstance(destination,\n                                                    concurrent.futures.Future):\n        raise TypeError('A future is required for destination argument')\n    source_loop = _get_loop(source) if isfuture(source) else None\n    dest_loop = _get_loop(destination) if isfuture(destination) else None\n\n    def _set_state(future, other):\n        if isfuture(future):\n            _copy_future_state(other, future)\n        else:\n            _set_concurrent_future_state(future, other)\n\n    def _call_check_cancel(destination):\n        if destination.cancelled():\n            if source_loop is None or source_loop is dest_loop:\n                source.cancel()\n            else:\n                source_loop.call_soon_threadsafe(source.cancel)\n\n    def _call_set_state(source):\n        if (destination.cancelled() and\n                dest_loop is not None and dest_loop.is_closed()):\n            return\n        if dest_loop is None or dest_loop is source_loop:\n            _set_state(destination, source)\n        else:\n            if dest_loop.is_closed():\n                return\n            dest_loop.call_soon_threadsafe(_set_state, destination, source)\n\n    destination.add_done_callback(_call_check_cancel)\n    source.add_done_callback(_call_set_state)\n\n\ndef wrap_future(future, *, loop=None):\n    \"\"\"Wrap concurrent.futures.Future object.\"\"\"\n    if isfuture(future):\n        return future\n    assert isinstance(future, concurrent.futures.Future), \\\n        f'concurrent.futures.Future is expected, got {future!r}'\n    if loop is None:\n        loop = events._get_event_loop()\n    new_future = loop.create_future()\n    _chain_future(future, new_future)\n    return new_future\n\n\ntry:\n    import _asyncio\nexcept ImportError:\n    pass\nelse:\n    # _CFuture is needed for tests.\n    Future = _CFuture = _asyncio.Future\n", 428], "/usr/local/lib/python3.11/site-packages/uvicorn/server.py": ["from __future__ import annotations\n\nimport asyncio\nimport contextlib\nimport logging\nimport os\nimport platform\nimport signal\nimport socket\nimport sys\nimport threading\nimport time\nfrom collections.abc import Generator, Sequence\nfrom email.utils import formatdate\nfrom types import FrameType\nfrom typing import TYPE_CHECKING, Union\n\nimport click\n\nfrom uvicorn._compat import asyncio_run\nfrom uvicorn.config import Config\n\nif TYPE_CHECKING:\n    from uvicorn.protocols.http.h11_impl import H11Protocol\n    from uvicorn.protocols.http.httptools_impl import HttpToolsProtocol\n    from uvicorn.protocols.websockets.websockets_impl import WebSocketProtocol\n    from uvicorn.protocols.websockets.websockets_sansio_impl import WebSocketsSansIOProtocol\n    from uvicorn.protocols.websockets.wsproto_impl import WSProtocol\n\n    Protocols = Union[H11Protocol, HttpToolsProtocol, WSProtocol, WebSocketProtocol, WebSocketsSansIOProtocol]\n\nHANDLED_SIGNALS = (\n    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.\n    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.\n)\nif sys.platform == \"win32\":  # pragma: py-not-win32\n    HANDLED_SIGNALS += (signal.SIGBREAK,)  # Windows signal 21. Sent by Ctrl+Break.\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n\nclass ServerState:\n    \"\"\"\n    Shared servers state that is available between all protocol instances.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.total_requests = 0\n        self.connections: set[Protocols] = set()\n        self.tasks: set[asyncio.Task[None]] = set()\n        self.default_headers: list[tuple[bytes, bytes]] = []\n\n\nclass Server:\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.server_state = ServerState()\n\n        self.started = False\n        self.should_exit = False\n        self.force_exit = False\n        self.last_notified = 0.0\n\n        self._captured_signals: list[int] = []\n\n    def run(self, sockets: list[socket.socket] | None = None) -> None:\n        return asyncio_run(self.serve(sockets=sockets), loop_factory=self.config.get_loop_factory())\n\n    async def serve(self, sockets: list[socket.socket] | None = None) -> None:\n        with self.capture_signals():\n            await self._serve(sockets)\n\n    async def _serve(self, sockets: list[socket.socket] | None = None) -> None:\n        process_id = os.getpid()\n\n        config = self.config\n        if not config.loaded:\n            config.load()\n\n        self.lifespan = config.lifespan_class(config)\n\n        message = \"Started server process [%d]\"\n        color_message = \"Started server process [\" + click.style(\"%d\", fg=\"cyan\") + \"]\"\n        logger.info(message, process_id, extra={\"color_message\": color_message})\n\n        await self.startup(sockets=sockets)\n        if self.should_exit:\n            return\n        await self.main_loop()\n        await self.shutdown(sockets=sockets)\n\n        message = \"Finished server process [%d]\"\n        color_message = \"Finished server process [\" + click.style(\"%d\", fg=\"cyan\") + \"]\"\n        logger.info(message, process_id, extra={\"color_message\": color_message})\n\n    async def startup(self, sockets: list[socket.socket] | None = None) -> None:\n        await self.lifespan.startup()\n        if self.lifespan.should_exit:\n            self.should_exit = True\n            return\n\n        config = self.config\n\n        def create_protocol(\n            _loop: asyncio.AbstractEventLoop | None = None,\n        ) -> asyncio.Protocol:\n            return config.http_protocol_class(  # type: ignore[call-arg]\n                config=config,\n                server_state=self.server_state,\n                app_state=self.lifespan.state,\n                _loop=_loop,\n            )\n\n        loop = asyncio.get_running_loop()\n\n        listeners: Sequence[socket.SocketType]\n        if sockets is not None:  # pragma: full coverage\n            # Explicitly passed a list of open sockets.\n            # We use this when the server is run from a Gunicorn worker.\n\n            def _share_socket(\n                sock: socket.SocketType,\n            ) -> socket.SocketType:  # pragma py-not-win32\n                # Windows requires the socket be explicitly shared across\n                # multiple workers (processes).\n                from socket import fromshare  # type: ignore[attr-defined]\n\n                sock_data = sock.share(os.getpid())  # type: ignore[attr-defined]\n                return fromshare(sock_data)\n\n            self.servers: list[asyncio.base_events.Server] = []\n            for sock in sockets:\n                is_windows = platform.system() == \"Windows\"\n                if config.workers > 1 and is_windows:  # pragma: py-not-win32\n                    sock = _share_socket(sock)  # type: ignore[assignment]\n                server = await loop.create_server(create_protocol, sock=sock, ssl=config.ssl, backlog=config.backlog)\n                self.servers.append(server)\n            listeners = sockets\n\n        elif config.fd is not None:  # pragma: py-win32\n            # Use an existing socket, from a file descriptor.\n            sock = socket.fromfd(config.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            server = await loop.create_server(create_protocol, sock=sock, ssl=config.ssl, backlog=config.backlog)\n            assert server.sockets is not None  # mypy\n            listeners = server.sockets\n            self.servers = [server]\n\n        elif config.uds is not None:  # pragma: py-win32\n            # Create a socket using UNIX domain socket.\n            uds_perms = 0o666\n            if os.path.exists(config.uds):\n                uds_perms = os.stat(config.uds).st_mode  # pragma: full coverage\n            server = await loop.create_unix_server(\n                create_protocol, path=config.uds, ssl=config.ssl, backlog=config.backlog\n            )\n            os.chmod(config.uds, uds_perms)\n            assert server.sockets is not None  # mypy\n            listeners = server.sockets\n            self.servers = [server]\n\n        else:\n            # Standard case. Create a socket from a host/port pair.\n            try:\n                server = await loop.create_server(\n                    create_protocol,\n                    host=config.host,\n                    port=config.port,\n                    ssl=config.ssl,\n                    backlog=config.backlog,\n                )\n            except OSError as exc:\n                logger.error(exc)\n                await self.lifespan.shutdown()\n                sys.exit(1)\n\n            assert server.sockets is not None\n            listeners = server.sockets\n            self.servers = [server]\n\n        if sockets is None:\n            self._log_started_message(listeners)\n        else:\n            # We're most likely running multiple workers, so a message has already been\n            # logged by `config.bind_socket()`.\n            pass  # pragma: full coverage\n\n        self.started = True\n\n    def _log_started_message(self, listeners: Sequence[socket.SocketType]) -> None:\n        config = self.config\n\n        if config.fd is not None:  # pragma: py-win32\n            sock = listeners[0]\n            logger.info(\n                \"Uvicorn running on socket %s (Press CTRL+C to quit)\",\n                sock.getsockname(),\n            )\n\n        elif config.uds is not None:  # pragma: py-win32\n            logger.info(\"Uvicorn running on unix socket %s (Press CTRL+C to quit)\", config.uds)\n\n        else:\n            addr_format = \"%s://%s:%d\"\n            host = \"0.0.0.0\" if config.host is None else config.host\n            if \":\" in host:\n                # It's an IPv6 address.\n                addr_format = \"%s://[%s]:%d\"\n\n            port = config.port\n            if port == 0:\n                port = listeners[0].getsockname()[1]\n\n            protocol_name = \"https\" if config.ssl else \"http\"\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger.info(\n                message,\n                protocol_name,\n                host,\n                port,\n                extra={\"color_message\": color_message},\n            )\n\n    async def main_loop(self) -> None:\n        counter = 0\n        should_exit = await self.on_tick(counter)\n        while not should_exit:\n            counter += 1\n            counter = counter % 864000\n            await asyncio.sleep(0.1)\n            should_exit = await self.on_tick(counter)\n\n    async def on_tick(self, counter: int) -> bool:\n        # Update the default headers, once per second.\n        if counter % 10 == 0:\n            current_time = time.time()\n            current_date = formatdate(current_time, usegmt=True).encode()\n\n            if self.config.date_header:\n                date_header = [(b\"date\", current_date)]\n            else:\n                date_header = []\n\n            self.server_state.default_headers = date_header + self.config.encoded_headers\n\n            # Callback to `callback_notify` once every `timeout_notify` seconds.\n            if self.config.callback_notify is not None:\n                if current_time - self.last_notified > self.config.timeout_notify:  # pragma: full coverage\n                    self.last_notified = current_time\n                    await self.config.callback_notify()\n\n        # Determine if we should exit.\n        if self.should_exit:\n            return True\n\n        max_requests = self.config.limit_max_requests\n        if max_requests is not None and self.server_state.total_requests >= max_requests:\n            logger.warning(f\"Maximum request limit of {max_requests} exceeded. Terminating process.\")\n            return True\n\n        return False\n\n    async def shutdown(self, sockets: list[socket.socket] | None = None) -> None:\n        logger.info(\"Shutting down\")\n\n        # Stop accepting new connections.\n        for server in self.servers:\n            server.close()\n        for sock in sockets or []:\n            sock.close()  # pragma: full coverage\n\n        # Request shutdown on all existing connections.\n        for connection in list(self.server_state.connections):\n            connection.shutdown()\n        await asyncio.sleep(0.1)\n\n        # When 3.10 is not supported anymore, use `async with asyncio.timeout(...):`.\n        try:\n            await asyncio.wait_for(\n                self._wait_tasks_to_complete(),\n                timeout=self.config.timeout_graceful_shutdown,\n            )\n        except asyncio.TimeoutError:\n            logger.error(\n                \"Cancel %s running task(s), timeout graceful shutdown exceeded\",\n                len(self.server_state.tasks),\n            )\n            for t in self.server_state.tasks:\n                t.cancel(msg=\"Task cancelled, timeout graceful shutdown exceeded\")\n\n        # Send the lifespan shutdown event, and wait for application shutdown.\n        if not self.force_exit:\n            await self.lifespan.shutdown()\n\n    async def _wait_tasks_to_complete(self) -> None:\n        # Wait for existing connections to finish sending responses.\n        if self.server_state.connections and not self.force_exit:\n            msg = \"Waiting for connections to close. (CTRL+C to force quit)\"\n            logger.info(msg)\n            while self.server_state.connections and not self.force_exit:\n                await asyncio.sleep(0.1)\n\n        # Wait for existing tasks to complete.\n        if self.server_state.tasks and not self.force_exit:\n            msg = \"Waiting for background tasks to complete. (CTRL+C to force quit)\"\n            logger.info(msg)\n            while self.server_state.tasks and not self.force_exit:\n                await asyncio.sleep(0.1)\n\n        for server in self.servers:\n            await server.wait_closed()\n\n    @contextlib.contextmanager\n    def capture_signals(self) -> Generator[None, None, None]:\n        # Signals can only be listened to from the main thread.\n        if threading.current_thread() is not threading.main_thread():\n            yield\n            return\n        # always use signal.signal, even if loop.add_signal_handler is available\n        # this allows to restore previous signal handlers later on\n        original_handlers = {sig: signal.signal(sig, self.handle_exit) for sig in HANDLED_SIGNALS}\n        try:\n            yield\n        finally:\n            for sig, handler in original_handlers.items():\n                signal.signal(sig, handler)\n        # If we did gracefully shut down due to a signal, try to\n        # trigger the expected behaviour now; multiple signals would be\n        # done LIFO, see https://stackoverflow.com/questions/48434964\n        for captured_signal in reversed(self._captured_signals):\n            signal.raise_signal(captured_signal)\n\n    def handle_exit(self, sig: int, frame: FrameType | None) -> None:\n        self._captured_signals.append(sig)\n        if self.should_exit and sig == signal.SIGINT:\n            self.force_exit = True  # pragma: full coverage\n        else:\n            self.should_exit = True\n", 338], "/usr/local/lib/python3.11/email/utils.py": ["# Copyright (C) 2001-2010 Python Software Foundation\n# Author: Barry Warsaw\n# Contact: email-sig@python.org\n\n\"\"\"Miscellaneous utilities.\"\"\"\n\n__all__ = [\n    'collapse_rfc2231_value',\n    'decode_params',\n    'decode_rfc2231',\n    'encode_rfc2231',\n    'formataddr',\n    'formatdate',\n    'format_datetime',\n    'getaddresses',\n    'make_msgid',\n    'mktime_tz',\n    'parseaddr',\n    'parsedate',\n    'parsedate_tz',\n    'parsedate_to_datetime',\n    'unquote',\n    ]\n\nimport os\nimport re\nimport time\nimport random\nimport socket\nimport datetime\nimport urllib.parse\n\nfrom email._parseaddr import quote\nfrom email._parseaddr import AddressList as _AddressList\nfrom email._parseaddr import mktime_tz\n\nfrom email._parseaddr import parsedate, parsedate_tz, _parsedate_tz\n\n# Intrapackage imports\nfrom email.charset import Charset\n\nCOMMASPACE = ', '\nEMPTYSTRING = ''\nUEMPTYSTRING = ''\nCRLF = '\\r\\n'\nTICK = \"'\"\n\nspecialsre = re.compile(r'[][\\\\()<>@,:;\".]')\nescapesre = re.compile(r'[\\\\\"]')\n\n\ndef _has_surrogates(s):\n    \"\"\"Return True if s may contain surrogate-escaped binary data.\"\"\"\n    # This check is based on the fact that unless there are surrogates, utf8\n    # (Python's default encoding) can encode any string.  This is the fastest\n    # way to check for surrogates, see bpo-11454 (moved to gh-55663) for timings.\n    try:\n        s.encode()\n        return False\n    except UnicodeEncodeError:\n        return True\n\n# How to deal with a string containing bytes before handing it to the\n# application through the 'normal' interface.\ndef _sanitize(string):\n    # Turn any escaped bytes into unicode 'unknown' char.  If the escaped\n    # bytes happen to be utf-8 they will instead get decoded, even if they\n    # were invalid in the charset the source was supposed to be in.  This\n    # seems like it is not a bad thing; a defect was still registered.\n    original_bytes = string.encode('utf-8', 'surrogateescape')\n    return original_bytes.decode('utf-8', 'replace')\n\n\n\n# Helpers\n\ndef formataddr(pair, charset='utf-8'):\n    \"\"\"The inverse of parseaddr(), this takes a 2-tuple of the form\n    (realname, email_address) and returns the string value suitable\n    for an RFC 2822 From, To or Cc header.\n\n    If the first element of pair is false, then the second element is\n    returned unmodified.\n\n    The optional charset is the character set that is used to encode\n    realname in case realname is not ASCII safe.  Can be an instance of str or\n    a Charset-like object which has a header_encode method.  Default is\n    'utf-8'.\n    \"\"\"\n    name, address = pair\n    # The address MUST (per RFC) be ascii, so raise a UnicodeError if it isn't.\n    address.encode('ascii')\n    if name:\n        try:\n            name.encode('ascii')\n        except UnicodeEncodeError:\n            if isinstance(charset, str):\n                charset = Charset(charset)\n            encoded_name = charset.header_encode(name)\n            return \"%s <%s>\" % (encoded_name, address)\n        else:\n            quotes = ''\n            if specialsre.search(name):\n                quotes = '\"'\n            name = escapesre.sub(r'\\\\\\g<0>', name)\n            return '%s%s%s <%s>' % (quotes, name, quotes, address)\n    return address\n\n\ndef _iter_escaped_chars(addr):\n    pos = 0\n    escape = False\n    for pos, ch in enumerate(addr):\n        if escape:\n            yield (pos, '\\\\' + ch)\n            escape = False\n        elif ch == '\\\\':\n            escape = True\n        else:\n            yield (pos, ch)\n    if escape:\n        yield (pos, '\\\\')\n\n\ndef _strip_quoted_realnames(addr):\n    \"\"\"Strip real names between quotes.\"\"\"\n    if '\"' not in addr:\n        # Fast path\n        return addr\n\n    start = 0\n    open_pos = None\n    result = []\n    for pos, ch in _iter_escaped_chars(addr):\n        if ch == '\"':\n            if open_pos is None:\n                open_pos = pos\n            else:\n                if start != open_pos:\n                    result.append(addr[start:open_pos])\n                start = pos + 1\n                open_pos = None\n\n    if start < len(addr):\n        result.append(addr[start:])\n\n    return ''.join(result)\n\n\nsupports_strict_parsing = True\n\ndef getaddresses(fieldvalues, *, strict=True):\n    \"\"\"Return a list of (REALNAME, EMAIL) or ('','') for each fieldvalue.\n\n    When parsing fails for a fieldvalue, a 2-tuple of ('', '') is returned in\n    its place.\n\n    If strict is true, use a strict parser which rejects malformed inputs.\n    \"\"\"\n\n    # If strict is true, if the resulting list of parsed addresses is greater\n    # than the number of fieldvalues in the input list, a parsing error has\n    # occurred and consequently a list containing a single empty 2-tuple [('',\n    # '')] is returned in its place. This is done to avoid invalid output.\n    #\n    # Malformed input: getaddresses(['alice@example.com <bob@example.com>'])\n    # Invalid output: [('', 'alice@example.com'), ('', 'bob@example.com')]\n    # Safe output: [('', '')]\n\n    if not strict:\n        all = COMMASPACE.join(str(v) for v in fieldvalues)\n        a = _AddressList(all)\n        return a.addresslist\n\n    fieldvalues = [str(v) for v in fieldvalues]\n    fieldvalues = _pre_parse_validation(fieldvalues)\n    addr = COMMASPACE.join(fieldvalues)\n    a = _AddressList(addr)\n    result = _post_parse_validation(a.addresslist)\n\n    # Treat output as invalid if the number of addresses is not equal to the\n    # expected number of addresses.\n    n = 0\n    for v in fieldvalues:\n        # When a comma is used in the Real Name part it is not a deliminator.\n        # So strip those out before counting the commas.\n        v = _strip_quoted_realnames(v)\n        # Expected number of addresses: 1 + number of commas\n        n += 1 + v.count(',')\n    if len(result) != n:\n        return [('', '')]\n\n    return result\n\n\ndef _check_parenthesis(addr):\n    # Ignore parenthesis in quoted real names.\n    addr = _strip_quoted_realnames(addr)\n\n    opens = 0\n    for pos, ch in _iter_escaped_chars(addr):\n        if ch == '(':\n            opens += 1\n        elif ch == ')':\n            opens -= 1\n            if opens < 0:\n                return False\n    return (opens == 0)\n\n\ndef _pre_parse_validation(email_header_fields):\n    accepted_values = []\n    for v in email_header_fields:\n        if not _check_parenthesis(v):\n            v = \"('', '')\"\n        accepted_values.append(v)\n\n    return accepted_values\n\n\ndef _post_parse_validation(parsed_email_header_tuples):\n    accepted_values = []\n    # The parser would have parsed a correctly formatted domain-literal\n    # The existence of an [ after parsing indicates a parsing failure\n    for v in parsed_email_header_tuples:\n        if '[' in v[1]:\n            v = ('', '')\n        accepted_values.append(v)\n\n    return accepted_values\n\n\ndef _format_timetuple_and_zone(timetuple, zone):\n    return '%s, %02d %s %04d %02d:%02d:%02d %s' % (\n        ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][timetuple[6]],\n        timetuple[2],\n        ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n         'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][timetuple[1] - 1],\n        timetuple[0], timetuple[3], timetuple[4], timetuple[5],\n        zone)\n\ndef formatdate(timeval=None, localtime=False, usegmt=False):\n    \"\"\"Returns a date string as specified by RFC 2822, e.g.:\n\n    Fri, 09 Nov 2001 01:08:47 -0000\n\n    Optional timeval if given is a floating point time value as accepted by\n    gmtime() and localtime(), otherwise the current time is used.\n\n    Optional localtime is a flag that when True, interprets timeval, and\n    returns a date relative to the local timezone instead of UTC, properly\n    taking daylight savings time into account.\n\n    Optional argument usegmt means that the timezone is written out as\n    an ascii string, not numeric one (so \"GMT\" instead of \"+0000\"). This\n    is needed for HTTP, and is only used when localtime==False.\n    \"\"\"\n    # Note: we cannot use strftime() because that honors the locale and RFC\n    # 2822 requires that day and month names be the English abbreviations.\n    if timeval is None:\n        timeval = time.time()\n    if localtime or usegmt:\n        dt = datetime.datetime.fromtimestamp(timeval, datetime.timezone.utc)\n    else:\n        dt = datetime.datetime.utcfromtimestamp(timeval)\n    if localtime:\n        dt = dt.astimezone()\n        usegmt = False\n    return format_datetime(dt, usegmt)\n\ndef format_datetime(dt, usegmt=False):\n    \"\"\"Turn a datetime into a date string as specified in RFC 2822.\n\n    If usegmt is True, dt must be an aware datetime with an offset of zero.  In\n    this case 'GMT' will be rendered instead of the normal +0000 required by\n    RFC2822.  This is to support HTTP headers involving date stamps.\n    \"\"\"\n    now = dt.timetuple()\n    if usegmt:\n        if dt.tzinfo is None or dt.tzinfo != datetime.timezone.utc:\n            raise ValueError(\"usegmt option requires a UTC datetime\")\n        zone = 'GMT'\n    elif dt.tzinfo is None:\n        zone = '-0000'\n    else:\n        zone = dt.strftime(\"%z\")\n    return _format_timetuple_and_zone(now, zone)\n\n\ndef make_msgid(idstring=None, domain=None):\n    \"\"\"Returns a string suitable for RFC 2822 compliant Message-ID, e.g:\n\n    <142480216486.20800.16526388040877946887@nightshade.la.mastaler.com>\n\n    Optional idstring if given is a string used to strengthen the\n    uniqueness of the message id.  Optional domain if given provides the\n    portion of the message id after the '@'.  It defaults to the locally\n    defined hostname.\n    \"\"\"\n    timeval = int(time.time()*100)\n    pid = os.getpid()\n    randint = random.getrandbits(64)\n    if idstring is None:\n        idstring = ''\n    else:\n        idstring = '.' + idstring\n    if domain is None:\n        domain = socket.getfqdn()\n    msgid = '<%d.%d.%d%s@%s>' % (timeval, pid, randint, idstring, domain)\n    return msgid\n\n\ndef parsedate_to_datetime(data):\n    parsed_date_tz = _parsedate_tz(data)\n    if parsed_date_tz is None:\n        raise ValueError('Invalid date value or format \"%s\"' % str(data))\n    *dtuple, tz = parsed_date_tz\n    if tz is None:\n        return datetime.datetime(*dtuple[:6])\n    return datetime.datetime(*dtuple[:6],\n            tzinfo=datetime.timezone(datetime.timedelta(seconds=tz)))\n\n\ndef parseaddr(addr, *, strict=True):\n    \"\"\"\n    Parse addr into its constituent realname and email address parts.\n\n    Return a tuple of realname and email address, unless the parse fails, in\n    which case return a 2-tuple of ('', '').\n\n    If strict is True, use a strict parser which rejects malformed inputs.\n    \"\"\"\n    if not strict:\n        addrs = _AddressList(addr).addresslist\n        if not addrs:\n            return ('', '')\n        return addrs[0]\n\n    if isinstance(addr, list):\n        addr = addr[0]\n\n    if not isinstance(addr, str):\n        return ('', '')\n\n    addr = _pre_parse_validation([addr])[0]\n    addrs = _post_parse_validation(_AddressList(addr).addresslist)\n\n    if not addrs or len(addrs) > 1:\n        return ('', '')\n\n    return addrs[0]\n\n\n# rfc822.unquote() doesn't properly de-backslash-ify in Python pre-2.3.\ndef unquote(str):\n    \"\"\"Remove quotes from a string.\"\"\"\n    if len(str) > 1:\n        if str.startswith('\"') and str.endswith('\"'):\n            return str[1:-1].replace('\\\\\\\\', '\\\\').replace('\\\\\"', '\"')\n        if str.startswith('<') and str.endswith('>'):\n            return str[1:-1]\n    return str\n\n\n\n# RFC2231-related functions - parameter encoding and decoding\ndef decode_rfc2231(s):\n    \"\"\"Decode string according to RFC 2231\"\"\"\n    parts = s.split(TICK, 2)\n    if len(parts) <= 2:\n        return None, None, s\n    return parts\n\n\ndef encode_rfc2231(s, charset=None, language=None):\n    \"\"\"Encode string according to RFC 2231.\n\n    If neither charset nor language is given, then s is returned as-is.  If\n    charset is given but not language, the string is encoded using the empty\n    string for language.\n    \"\"\"\n    s = urllib.parse.quote(s, safe='', encoding=charset or 'ascii')\n    if charset is None and language is None:\n        return s\n    if language is None:\n        language = ''\n    return \"%s'%s'%s\" % (charset, language, s)\n\n\nrfc2231_continuation = re.compile(r'^(?P<name>\\w+)\\*((?P<num>[0-9]+)\\*?)?$',\n    re.ASCII)\n\ndef decode_params(params):\n    \"\"\"Decode parameters list according to RFC 2231.\n\n    params is a sequence of 2-tuples containing (param name, string value).\n    \"\"\"\n    new_params = [params[0]]\n    # Map parameter's name to a list of continuations.  The values are a\n    # 3-tuple of the continuation number, the string value, and a flag\n    # specifying whether a particular segment is %-encoded.\n    rfc2231_params = {}\n    for name, value in params[1:]:\n        encoded = name.endswith('*')\n        value = unquote(value)\n        mo = rfc2231_continuation.match(name)\n        if mo:\n            name, num = mo.group('name', 'num')\n            if num is not None:\n                num = int(num)\n            rfc2231_params.setdefault(name, []).append((num, value, encoded))\n        else:\n            new_params.append((name, '\"%s\"' % quote(value)))\n    if rfc2231_params:\n        for name, continuations in rfc2231_params.items():\n            value = []\n            extended = False\n            # Sort by number\n            continuations.sort()\n            # And now append all values in numerical order, converting\n            # %-encodings for the encoded segments.  If any of the\n            # continuation names ends in a *, then the entire string, after\n            # decoding segments and concatenating, must have the charset and\n            # language specifiers at the beginning of the string.\n            for num, s, encoded in continuations:\n                if encoded:\n                    # Decode as \"latin-1\", so the characters in s directly\n                    # represent the percent-encoded octet values.\n                    # collapse_rfc2231_value treats this as an octet sequence.\n                    s = urllib.parse.unquote(s, encoding=\"latin-1\")\n                    extended = True\n                value.append(s)\n            value = quote(EMPTYSTRING.join(value))\n            if extended:\n                charset, language, value = decode_rfc2231(value)\n                new_params.append((name, (charset, language, '\"%s\"' % value)))\n            else:\n                new_params.append((name, '\"%s\"' % value))\n    return new_params\n\ndef collapse_rfc2231_value(value, errors='replace',\n                           fallback_charset='us-ascii'):\n    if not isinstance(value, tuple) or len(value) != 3:\n        return unquote(value)\n    # While value comes to us as a unicode string, we need it to be a bytes\n    # object.  We do not want bytes() normal utf-8 decoder, we want a straight\n    # interpretation of the string as character bytes.\n    charset, language, text = value\n    if charset is None:\n        # Issue 17369: if charset/lang is None, decode_rfc2231 couldn't parse\n        # the value, so use the fallback_charset.\n        charset = fallback_charset\n    rawbytes = bytes(text, 'raw-unicode-escape')\n    try:\n        return str(rawbytes, charset, errors)\n    except LookupError:\n        # charset is not a known codec.\n        return unquote(text)\n\n\n#\n# datetime doesn't provide a localtime function yet, so provide one.  Code\n# adapted from the patch in issue 9527.  This may not be perfect, but it is\n# better than not having it.\n#\n\ndef localtime(dt=None, isdst=-1):\n    \"\"\"Return local time as an aware datetime object.\n\n    If called without arguments, return current time.  Otherwise *dt*\n    argument should be a datetime instance, and it is converted to the\n    local time zone according to the system time zone database.  If *dt* is\n    naive (that is, dt.tzinfo is None), it is assumed to be in local time.\n    In this case, a positive or zero value for *isdst* causes localtime to\n    presume initially that summer time (for example, Daylight Saving Time)\n    is or is not (respectively) in effect for the specified time.  A\n    negative value for *isdst* causes the localtime() function to attempt\n    to divine whether summer time is in effect for the specified time.\n\n    \"\"\"\n    if dt is None:\n        return datetime.datetime.now(datetime.timezone.utc).astimezone()\n    if dt.tzinfo is not None:\n        return dt.astimezone()\n    # We have a naive datetime.  Convert to a (localtime) timetuple and pass to\n    # system mktime together with the isdst hint.  System mktime will return\n    # seconds since epoch.\n    tm = dt.timetuple()[:-1] + (isdst,)\n    seconds = time.mktime(tm)\n    localtm = time.localtime(seconds)\n    try:\n        delta = datetime.timedelta(seconds=localtm.tm_gmtoff)\n        tz = datetime.timezone(delta, localtm.tm_zone)\n    except AttributeError:\n        # Compute UTC offset and compare with the value implied by tm_isdst.\n        # If the values match, use the zone name implied by tm_isdst.\n        delta = dt - datetime.datetime(*time.gmtime(seconds)[:6])\n        dst = time.daylight and localtm.tm_isdst > 0\n        gmtoff = -(time.altzone if dst else time.timezone)\n        if delta == datetime.timedelta(seconds=gmtoff):\n            tz = datetime.timezone(delta, time.tzname[dst])\n        else:\n            tz = datetime.timezone(delta)\n    return dt.replace(tzinfo=tz)\n", 504], "<frozen abc>": ["# Copyright 2007 Google, Inc. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n\n\ndef abstractmethod(funcobj):\n    \"\"\"A decorator indicating abstract methods.\n\n    Requires that the metaclass is ABCMeta or derived from it.  A\n    class that has a metaclass derived from ABCMeta cannot be\n    instantiated unless all of its abstract methods are overridden.\n    The abstract methods can be called using any of the normal\n    'super' call mechanisms.  abstractmethod() may be used to declare\n    abstract methods for properties and descriptors.\n\n    Usage:\n\n        class C(metaclass=ABCMeta):\n            @abstractmethod\n            def my_abstract_method(self, arg1, arg2, argN):\n                ...\n    \"\"\"\n    funcobj.__isabstractmethod__ = True\n    return funcobj\n\n\nclass abstractclassmethod(classmethod):\n    \"\"\"A decorator indicating abstract classmethods.\n\n    Deprecated, use 'classmethod' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @classmethod\n            @abstractmethod\n            def my_abstract_classmethod(cls, ...):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n    def __init__(self, callable):\n        callable.__isabstractmethod__ = True\n        super().__init__(callable)\n\n\nclass abstractstaticmethod(staticmethod):\n    \"\"\"A decorator indicating abstract staticmethods.\n\n    Deprecated, use 'staticmethod' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @staticmethod\n            @abstractmethod\n            def my_abstract_staticmethod(...):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n    def __init__(self, callable):\n        callable.__isabstractmethod__ = True\n        super().__init__(callable)\n\n\nclass abstractproperty(property):\n    \"\"\"A decorator indicating abstract properties.\n\n    Deprecated, use 'property' with 'abstractmethod' instead:\n\n        class C(ABC):\n            @property\n            @abstractmethod\n            def my_abstract_property(self):\n                ...\n\n    \"\"\"\n\n    __isabstractmethod__ = True\n\n\ntry:\n    from _abc import (get_cache_token, _abc_init, _abc_register,\n                      _abc_instancecheck, _abc_subclasscheck, _get_dump,\n                      _reset_registry, _reset_caches)\nexcept ImportError:\n    from _py_abc import ABCMeta, get_cache_token\n    ABCMeta.__module__ = 'abc'\nelse:\n    class ABCMeta(type):\n        \"\"\"Metaclass for defining Abstract Base Classes (ABCs).\n\n        Use this metaclass to create an ABC.  An ABC can be subclassed\n        directly, and then acts as a mix-in class.  You can also register\n        unrelated concrete classes (even built-in classes) and unrelated\n        ABCs as 'virtual subclasses' -- these and their descendants will\n        be considered subclasses of the registering ABC by the built-in\n        issubclass() function, but the registering ABC won't show up in\n        their MRO (Method Resolution Order) nor will method\n        implementations defined by the registering ABC be callable (not\n        even via super()).\n        \"\"\"\n        def __new__(mcls, name, bases, namespace, /, **kwargs):\n            cls = super().__new__(mcls, name, bases, namespace, **kwargs)\n            _abc_init(cls)\n            return cls\n\n        def register(cls, subclass):\n            \"\"\"Register a virtual subclass of an ABC.\n\n            Returns the subclass, to allow usage as a class decorator.\n            \"\"\"\n            return _abc_register(cls, subclass)\n\n        def __instancecheck__(cls, instance):\n            \"\"\"Override for isinstance(instance, cls).\"\"\"\n            return _abc_instancecheck(cls, instance)\n\n        def __subclasscheck__(cls, subclass):\n            \"\"\"Override for issubclass(subclass, cls).\"\"\"\n            return _abc_subclasscheck(cls, subclass)\n\n        def _dump_registry(cls, file=None):\n            \"\"\"Debug helper to print the ABC registry.\"\"\"\n            print(f\"Class: {cls.__module__}.{cls.__qualname__}\", file=file)\n            print(f\"Inv. counter: {get_cache_token()}\", file=file)\n            (_abc_registry, _abc_cache, _abc_negative_cache,\n             _abc_negative_cache_version) = _get_dump(cls)\n            print(f\"_abc_registry: {_abc_registry!r}\", file=file)\n            print(f\"_abc_cache: {_abc_cache!r}\", file=file)\n            print(f\"_abc_negative_cache: {_abc_negative_cache!r}\", file=file)\n            print(f\"_abc_negative_cache_version: {_abc_negative_cache_version!r}\",\n                  file=file)\n\n        def _abc_registry_clear(cls):\n            \"\"\"Clear the registry (for debugging or testing).\"\"\"\n            _reset_registry(cls)\n\n        def _abc_caches_clear(cls):\n            \"\"\"Clear the caches (for debugging or testing).\"\"\"\n            _reset_caches(cls)\n\n\ndef update_abstractmethods(cls):\n    \"\"\"Recalculate the set of abstract methods of an abstract class.\n\n    If a class has had one of its abstract methods implemented after the\n    class was created, the method will not be considered implemented until\n    this function is called. Alternatively, if a new abstract method has been\n    added to the class, it will only be considered an abstract method of the\n    class after this function is called.\n\n    This function should be called before any use is made of the class,\n    usually in class decorators that add methods to the subject class.\n\n    Returns cls, to allow usage as a class decorator.\n\n    If cls is not an instance of ABCMeta, does nothing.\n    \"\"\"\n    if not hasattr(cls, '__abstractmethods__'):\n        # We check for __abstractmethods__ here because cls might by a C\n        # implementation or a python implementation (especially during\n        # testing), and we want to handle both cases.\n        return cls\n\n    abstracts = set()\n    # Check the existing abstract methods of the parents, keep only the ones\n    # that are not implemented.\n    for scls in cls.__bases__:\n        for name in getattr(scls, '__abstractmethods__', ()):\n            value = getattr(cls, name, None)\n            if getattr(value, \"__isabstractmethod__\", False):\n                abstracts.add(name)\n    # Also add any other newly added abstract methods.\n    for name, value in cls.__dict__.items():\n        if getattr(value, \"__isabstractmethod__\", False):\n            abstracts.add(name)\n    cls.__abstractmethods__ = frozenset(abstracts)\n    return cls\n\n\nclass ABC(metaclass=ABCMeta):\n    \"\"\"Helper class that provides a standard way to create an ABC using\n    inheritance.\n    \"\"\"\n    __slots__ = ()\n", 188], "/usr/local/lib/python3.11/asyncio/coroutines.py": ["__all__ = 'iscoroutinefunction', 'iscoroutine'\n\nimport collections.abc\nimport inspect\nimport os\nimport sys\nimport traceback\nimport types\n\n\ndef _is_debug_mode():\n    # See: https://docs.python.org/3/library/asyncio-dev.html#asyncio-debug-mode.\n    return sys.flags.dev_mode or (not sys.flags.ignore_environment and\n                                  bool(os.environ.get('PYTHONASYNCIODEBUG')))\n\n\n# A marker for iscoroutinefunction.\n_is_coroutine = object()\n\n\ndef iscoroutinefunction(func):\n    \"\"\"Return True if func is a decorated coroutine function.\"\"\"\n    return (inspect.iscoroutinefunction(func) or\n            getattr(func, '_is_coroutine', None) is _is_coroutine)\n\n\n# Prioritize native coroutine check to speed-up\n# asyncio.iscoroutine.\n_COROUTINE_TYPES = (types.CoroutineType, types.GeneratorType,\n                    collections.abc.Coroutine)\n_iscoroutine_typecache = set()\n\n\ndef iscoroutine(obj):\n    \"\"\"Return True if obj is a coroutine object.\"\"\"\n    if type(obj) in _iscoroutine_typecache:\n        return True\n\n    if isinstance(obj, _COROUTINE_TYPES):\n        # Just in case we don't want to cache more than 100\n        # positive types.  That shouldn't ever happen, unless\n        # someone stressing the system on purpose.\n        if len(_iscoroutine_typecache) < 100:\n            _iscoroutine_typecache.add(type(obj))\n        return True\n    else:\n        return False\n\n\ndef _format_coroutine(coro):\n    assert iscoroutine(coro)\n\n    def get_name(coro):\n        # Coroutines compiled with Cython sometimes don't have\n        # proper __qualname__ or __name__.  While that is a bug\n        # in Cython, asyncio shouldn't crash with an AttributeError\n        # in its __repr__ functions.\n        if hasattr(coro, '__qualname__') and coro.__qualname__:\n            coro_name = coro.__qualname__\n        elif hasattr(coro, '__name__') and coro.__name__:\n            coro_name = coro.__name__\n        else:\n            # Stop masking Cython bugs, expose them in a friendly way.\n            coro_name = f'<{type(coro).__name__} without __name__>'\n        return f'{coro_name}()'\n\n    def is_running(coro):\n        try:\n            return coro.cr_running\n        except AttributeError:\n            try:\n                return coro.gi_running\n            except AttributeError:\n                return False\n\n    coro_code = None\n    if hasattr(coro, 'cr_code') and coro.cr_code:\n        coro_code = coro.cr_code\n    elif hasattr(coro, 'gi_code') and coro.gi_code:\n        coro_code = coro.gi_code\n\n    coro_name = get_name(coro)\n\n    if not coro_code:\n        # Built-in types might not have __qualname__ or __name__.\n        if is_running(coro):\n            return f'{coro_name} running'\n        else:\n            return coro_name\n\n    coro_frame = None\n    if hasattr(coro, 'gi_frame') and coro.gi_frame:\n        coro_frame = coro.gi_frame\n    elif hasattr(coro, 'cr_frame') and coro.cr_frame:\n        coro_frame = coro.cr_frame\n\n    # If Cython's coroutine has a fake code object without proper\n    # co_filename -- expose that.\n    filename = coro_code.co_filename or '<empty co_filename>'\n\n    lineno = 0\n\n    if coro_frame is not None:\n        lineno = coro_frame.f_lineno\n        coro_repr = f'{coro_name} running at {filename}:{lineno}'\n\n    else:\n        lineno = coro_code.co_firstlineno\n        coro_repr = f'{coro_name} done, defined at {filename}:{lineno}'\n\n    return coro_repr\n", 111], "/usr/local/lib/python3.11/inspect.py": ["\"\"\"Get useful information from live Python objects.\n\nThis module encapsulates the interface provided by the internal special\nattributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.\nIt also provides some help for examining source code and class layout.\n\nHere are some of the useful functions provided by this module:\n\n    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n        isroutine() - check object types\n    getmembers() - get members of an object that satisfy a given condition\n\n    getfile(), getsourcefile(), getsource() - find an object's source code\n    getdoc(), getcomments() - get documentation on an object\n    getmodule() - determine the module that an object came from\n    getclasstree() - arrange classes so as to represent their hierarchy\n\n    getargvalues(), getcallargs() - get info about function arguments\n    getfullargspec() - same, with support for Python 3 features\n    formatargvalues() - format an argument spec\n    getouterframes(), getinnerframes() - get info about frames\n    currentframe() - get the current stack frame\n    stack(), trace() - get info about frames on the stack or in a traceback\n\n    signature() - get a Signature object for the callable\n\n    get_annotations() - safely compute an object's annotations\n\"\"\"\n\n# This module is in the public domain.  No warranties.\n\n__author__ = ('Ka-Ping Yee <ping@lfw.org>',\n              'Yury Selivanov <yselivanov@sprymix.com>')\n\n__all__ = [\n    \"ArgInfo\",\n    \"Arguments\",\n    \"Attribute\",\n    \"BlockFinder\",\n    \"BoundArguments\",\n    \"CORO_CLOSED\",\n    \"CORO_CREATED\",\n    \"CORO_RUNNING\",\n    \"CORO_SUSPENDED\",\n    \"CO_ASYNC_GENERATOR\",\n    \"CO_COROUTINE\",\n    \"CO_GENERATOR\",\n    \"CO_ITERABLE_COROUTINE\",\n    \"CO_NESTED\",\n    \"CO_NEWLOCALS\",\n    \"CO_NOFREE\",\n    \"CO_OPTIMIZED\",\n    \"CO_VARARGS\",\n    \"CO_VARKEYWORDS\",\n    \"ClassFoundException\",\n    \"ClosureVars\",\n    \"EndOfBlock\",\n    \"FrameInfo\",\n    \"FullArgSpec\",\n    \"GEN_CLOSED\",\n    \"GEN_CREATED\",\n    \"GEN_RUNNING\",\n    \"GEN_SUSPENDED\",\n    \"Parameter\",\n    \"Signature\",\n    \"TPFLAGS_IS_ABSTRACT\",\n    \"Traceback\",\n    \"classify_class_attrs\",\n    \"cleandoc\",\n    \"currentframe\",\n    \"findsource\",\n    \"formatannotation\",\n    \"formatannotationrelativeto\",\n    \"formatargvalues\",\n    \"get_annotations\",\n    \"getabsfile\",\n    \"getargs\",\n    \"getargvalues\",\n    \"getattr_static\",\n    \"getblock\",\n    \"getcallargs\",\n    \"getclasstree\",\n    \"getclosurevars\",\n    \"getcomments\",\n    \"getcoroutinelocals\",\n    \"getcoroutinestate\",\n    \"getdoc\",\n    \"getfile\",\n    \"getframeinfo\",\n    \"getfullargspec\",\n    \"getgeneratorlocals\",\n    \"getgeneratorstate\",\n    \"getinnerframes\",\n    \"getlineno\",\n    \"getmembers\",\n    \"getmembers_static\",\n    \"getmodule\",\n    \"getmodulename\",\n    \"getmro\",\n    \"getouterframes\",\n    \"getsource\",\n    \"getsourcefile\",\n    \"getsourcelines\",\n    \"indentsize\",\n    \"isabstract\",\n    \"isasyncgen\",\n    \"isasyncgenfunction\",\n    \"isawaitable\",\n    \"isbuiltin\",\n    \"isclass\",\n    \"iscode\",\n    \"iscoroutine\",\n    \"iscoroutinefunction\",\n    \"isdatadescriptor\",\n    \"isframe\",\n    \"isfunction\",\n    \"isgenerator\",\n    \"isgeneratorfunction\",\n    \"isgetsetdescriptor\",\n    \"ismemberdescriptor\",\n    \"ismethod\",\n    \"ismethoddescriptor\",\n    \"ismethodwrapper\",\n    \"ismodule\",\n    \"isroutine\",\n    \"istraceback\",\n    \"signature\",\n    \"stack\",\n    \"trace\",\n    \"unwrap\",\n    \"walktree\",\n]\n\n\nimport abc\nimport ast\nimport dis\nimport collections.abc\nimport enum\nimport importlib.machinery\nimport itertools\nimport linecache\nimport os\nimport re\nimport sys\nimport tokenize\nimport token\nimport types\nimport functools\nimport builtins\nfrom keyword import iskeyword\nfrom operator import attrgetter\nfrom collections import namedtuple, OrderedDict\n\n# Create constants for the compiler flags in Include/code.h\n# We try to get them from dis to avoid duplication\nmod_dict = globals()\nfor k, v in dis.COMPILER_FLAG_NAMES.items():\n    mod_dict[\"CO_\" + v] = k\ndel k, v, mod_dict\n\n# See Include/object.h\nTPFLAGS_IS_ABSTRACT = 1 << 20\n\n\ndef get_annotations(obj, *, globals=None, locals=None, eval_str=False):\n    \"\"\"Compute the annotations dict for an object.\n\n    obj may be a callable, class, or module.\n    Passing in an object of any other type raises TypeError.\n\n    Returns a dict.  get_annotations() returns a new dict every time\n    it's called; calling it twice on the same object will return two\n    different but equivalent dicts.\n\n    This function handles several details for you:\n\n      * If eval_str is true, values of type str will\n        be un-stringized using eval().  This is intended\n        for use with stringized annotations\n        (\"from __future__ import annotations\").\n      * If obj doesn't have an annotations dict, returns an\n        empty dict.  (Functions and methods always have an\n        annotations dict; classes, modules, and other types of\n        callables may not.)\n      * Ignores inherited annotations on classes.  If a class\n        doesn't have its own annotations dict, returns an empty dict.\n      * All accesses to object members and dict values are done\n        using getattr() and dict.get() for safety.\n      * Always, always, always returns a freshly-created dict.\n\n    eval_str controls whether or not values of type str are replaced\n    with the result of calling eval() on those values:\n\n      * If eval_str is true, eval() is called on values of type str.\n      * If eval_str is false (the default), values of type str are unchanged.\n\n    globals and locals are passed in to eval(); see the documentation\n    for eval() for more information.  If either globals or locals is\n    None, this function may replace that value with a context-specific\n    default, contingent on type(obj):\n\n      * If obj is a module, globals defaults to obj.__dict__.\n      * If obj is a class, globals defaults to\n        sys.modules[obj.__module__].__dict__ and locals\n        defaults to the obj class namespace.\n      * If obj is a callable, globals defaults to obj.__globals__,\n        although if obj is a wrapped function (using\n        functools.update_wrapper()) it is first unwrapped.\n    \"\"\"\n    if isinstance(obj, type):\n        # class\n        obj_dict = getattr(obj, '__dict__', None)\n        if obj_dict and hasattr(obj_dict, 'get'):\n            ann = obj_dict.get('__annotations__', None)\n            if isinstance(ann, types.GetSetDescriptorType):\n                ann = None\n        else:\n            ann = None\n\n        obj_globals = None\n        module_name = getattr(obj, '__module__', None)\n        if module_name:\n            module = sys.modules.get(module_name, None)\n            if module:\n                obj_globals = getattr(module, '__dict__', None)\n        obj_locals = dict(vars(obj))\n        unwrap = obj\n    elif isinstance(obj, types.ModuleType):\n        # module\n        ann = getattr(obj, '__annotations__', None)\n        obj_globals = getattr(obj, '__dict__')\n        obj_locals = None\n        unwrap = None\n    elif callable(obj):\n        # this includes types.Function, types.BuiltinFunctionType,\n        # types.BuiltinMethodType, functools.partial, functools.singledispatch,\n        # \"class funclike\" from Lib/test/test_inspect... on and on it goes.\n        ann = getattr(obj, '__annotations__', None)\n        obj_globals = getattr(obj, '__globals__', None)\n        obj_locals = None\n        unwrap = obj\n    else:\n        raise TypeError(f\"{obj!r} is not a module, class, or callable.\")\n\n    if ann is None:\n        return {}\n\n    if not isinstance(ann, dict):\n        raise ValueError(f\"{obj!r}.__annotations__ is neither a dict nor None\")\n\n    if not ann:\n        return {}\n\n    if not eval_str:\n        return dict(ann)\n\n    if unwrap is not None:\n        while True:\n            if hasattr(unwrap, '__wrapped__'):\n                unwrap = unwrap.__wrapped__\n                continue\n            if isinstance(unwrap, functools.partial):\n                unwrap = unwrap.func\n                continue\n            break\n        if hasattr(unwrap, \"__globals__\"):\n            obj_globals = unwrap.__globals__\n\n    if globals is None:\n        globals = obj_globals\n    if locals is None:\n        locals = obj_locals\n\n    return_value = {key:\n        value if not isinstance(value, str) else eval(value, globals, locals)\n        for key, value in ann.items() }\n    return return_value\n\n\n# ----------------------------------------------------------- type-checking\ndef ismodule(object):\n    \"\"\"Return true if the object is a module.\n\n    Module objects provide these attributes:\n        __cached__      pathname to byte compiled file\n        __doc__         documentation string\n        __file__        filename (missing for built-in modules)\"\"\"\n    return isinstance(object, types.ModuleType)\n\ndef isclass(object):\n    \"\"\"Return true if the object is a class.\n\n    Class objects provide these attributes:\n        __doc__         documentation string\n        __module__      name of module in which this class was defined\"\"\"\n    return isinstance(object, type)\n\ndef ismethod(object):\n    \"\"\"Return true if the object is an instance method.\n\n    Instance method objects provide these attributes:\n        __doc__         documentation string\n        __name__        name with which this method was defined\n        __func__        function object containing implementation of method\n        __self__        instance to which this method is bound\"\"\"\n    return isinstance(object, types.MethodType)\n\ndef ismethoddescriptor(object):\n    \"\"\"Return true if the object is a method descriptor.\n\n    But not if ismethod() or isclass() or isfunction() are true.\n\n    This is new in Python 2.2, and, for example, is true of int.__add__.\n    An object passing this test has a __get__ attribute but not a __set__\n    attribute, but beyond that the set of attributes varies.  __name__ is\n    usually sensible, and __doc__ often is.\n\n    Methods implemented via descriptors that also pass one of the other\n    tests return false from the ismethoddescriptor() test, simply because\n    the other tests promise more -- you can, e.g., count on having the\n    __func__ attribute (etc) when an object passes ismethod().\"\"\"\n    if isclass(object) or ismethod(object) or isfunction(object):\n        # mutual exclusion\n        return False\n    tp = type(object)\n    return hasattr(tp, \"__get__\") and not hasattr(tp, \"__set__\")\n\ndef isdatadescriptor(object):\n    \"\"\"Return true if the object is a data descriptor.\n\n    Data descriptors have a __set__ or a __delete__ attribute.  Examples are\n    properties (defined in Python) and getsets and members (defined in C).\n    Typically, data descriptors will also have __name__ and __doc__ attributes\n    (properties, getsets, and members have both of these attributes), but this\n    is not guaranteed.\"\"\"\n    if isclass(object) or ismethod(object) or isfunction(object):\n        # mutual exclusion\n        return False\n    tp = type(object)\n    return hasattr(tp, \"__set__\") or hasattr(tp, \"__delete__\")\n\nif hasattr(types, 'MemberDescriptorType'):\n    # CPython and equivalent\n    def ismemberdescriptor(object):\n        \"\"\"Return true if the object is a member descriptor.\n\n        Member descriptors are specialized descriptors defined in extension\n        modules.\"\"\"\n        return isinstance(object, types.MemberDescriptorType)\nelse:\n    # Other implementations\n    def ismemberdescriptor(object):\n        \"\"\"Return true if the object is a member descriptor.\n\n        Member descriptors are specialized descriptors defined in extension\n        modules.\"\"\"\n        return False\n\nif hasattr(types, 'GetSetDescriptorType'):\n    # CPython and equivalent\n    def isgetsetdescriptor(object):\n        \"\"\"Return true if the object is a getset descriptor.\n\n        getset descriptors are specialized descriptors defined in extension\n        modules.\"\"\"\n        return isinstance(object, types.GetSetDescriptorType)\nelse:\n    # Other implementations\n    def isgetsetdescriptor(object):\n        \"\"\"Return true if the object is a getset descriptor.\n\n        getset descriptors are specialized descriptors defined in extension\n        modules.\"\"\"\n        return False\n\ndef isfunction(object):\n    \"\"\"Return true if the object is a user-defined function.\n\n    Function objects provide these attributes:\n        __doc__         documentation string\n        __name__        name with which this function was defined\n        __code__        code object containing compiled function bytecode\n        __defaults__    tuple of any default values for arguments\n        __globals__     global namespace in which this function was defined\n        __annotations__ dict of parameter annotations\n        __kwdefaults__  dict of keyword only parameters with defaults\"\"\"\n    return isinstance(object, types.FunctionType)\n\ndef _has_code_flag(f, flag):\n    \"\"\"Return true if ``f`` is a function (or a method or functools.partial\n    wrapper wrapping a function) whose code object has the given ``flag``\n    set in its flags.\"\"\"\n    while ismethod(f):\n        f = f.__func__\n    f = functools._unwrap_partial(f)\n    if not (isfunction(f) or _signature_is_functionlike(f)):\n        return False\n    return bool(f.__code__.co_flags & flag)\n\ndef isgeneratorfunction(obj):\n    \"\"\"Return true if the object is a user-defined generator function.\n\n    Generator function objects provide the same attributes as functions.\n    See help(isfunction) for a list of attributes.\"\"\"\n    return _has_code_flag(obj, CO_GENERATOR)\n\ndef iscoroutinefunction(obj):\n    \"\"\"Return true if the object is a coroutine function.\n\n    Coroutine functions are defined with \"async def\" syntax.\n    \"\"\"\n    return _has_code_flag(obj, CO_COROUTINE)\n\ndef isasyncgenfunction(obj):\n    \"\"\"Return true if the object is an asynchronous generator function.\n\n    Asynchronous generator functions are defined with \"async def\"\n    syntax and have \"yield\" expressions in their body.\n    \"\"\"\n    return _has_code_flag(obj, CO_ASYNC_GENERATOR)\n\ndef isasyncgen(object):\n    \"\"\"Return true if the object is an asynchronous generator.\"\"\"\n    return isinstance(object, types.AsyncGeneratorType)\n\ndef isgenerator(object):\n    \"\"\"Return true if the object is a generator.\n\n    Generator objects provide these attributes:\n        __iter__        defined to support iteration over container\n        close           raises a new GeneratorExit exception inside the\n                        generator to terminate the iteration\n        gi_code         code object\n        gi_frame        frame object or possibly None once the generator has\n                        been exhausted\n        gi_running      set to 1 when generator is executing, 0 otherwise\n        next            return the next item from the container\n        send            resumes the generator and \"sends\" a value that becomes\n                        the result of the current yield-expression\n        throw           used to raise an exception inside the generator\"\"\"\n    return isinstance(object, types.GeneratorType)\n\ndef iscoroutine(object):\n    \"\"\"Return true if the object is a coroutine.\"\"\"\n    return isinstance(object, types.CoroutineType)\n\ndef isawaitable(object):\n    \"\"\"Return true if object can be passed to an ``await`` expression.\"\"\"\n    return (isinstance(object, types.CoroutineType) or\n            isinstance(object, types.GeneratorType) and\n                bool(object.gi_code.co_flags & CO_ITERABLE_COROUTINE) or\n            isinstance(object, collections.abc.Awaitable))\n\ndef istraceback(object):\n    \"\"\"Return true if the object is a traceback.\n\n    Traceback objects provide these attributes:\n        tb_frame        frame object at this level\n        tb_lasti        index of last attempted instruction in bytecode\n        tb_lineno       current line number in Python source code\n        tb_next         next inner traceback object (called by this level)\"\"\"\n    return isinstance(object, types.TracebackType)\n\ndef isframe(object):\n    \"\"\"Return true if the object is a frame object.\n\n    Frame objects provide these attributes:\n        f_back          next outer frame object (this frame's caller)\n        f_builtins      built-in namespace seen by this frame\n        f_code          code object being executed in this frame\n        f_globals       global namespace seen by this frame\n        f_lasti         index of last attempted instruction in bytecode\n        f_lineno        current line number in Python source code\n        f_locals        local namespace seen by this frame\n        f_trace         tracing function for this frame, or None\"\"\"\n    return isinstance(object, types.FrameType)\n\ndef iscode(object):\n    \"\"\"Return true if the object is a code object.\n\n    Code objects provide these attributes:\n        co_argcount         number of arguments (not including *, ** args\n                            or keyword only arguments)\n        co_code             string of raw compiled bytecode\n        co_cellvars         tuple of names of cell variables\n        co_consts           tuple of constants used in the bytecode\n        co_filename         name of file in which this code object was created\n        co_firstlineno      number of first line in Python source code\n        co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg\n                            | 16=nested | 32=generator | 64=nofree | 128=coroutine\n                            | 256=iterable_coroutine | 512=async_generator\n        co_freevars         tuple of names of free variables\n        co_posonlyargcount  number of positional only arguments\n        co_kwonlyargcount   number of keyword only arguments (not including ** arg)\n        co_lnotab           encoded mapping of line numbers to bytecode indices\n        co_name             name with which this code object was defined\n        co_names            tuple of names other than arguments and function locals\n        co_nlocals          number of local variables\n        co_stacksize        virtual machine stack space required\n        co_varnames         tuple of names of arguments and local variables\"\"\"\n    return isinstance(object, types.CodeType)\n\ndef isbuiltin(object):\n    \"\"\"Return true if the object is a built-in function or method.\n\n    Built-in functions and methods provide these attributes:\n        __doc__         documentation string\n        __name__        original name of this function or method\n        __self__        instance to which a method is bound, or None\"\"\"\n    return isinstance(object, types.BuiltinFunctionType)\n\ndef ismethodwrapper(object):\n    \"\"\"Return true if the object is a method wrapper.\"\"\"\n    return isinstance(object, types.MethodWrapperType)\n\ndef isroutine(object):\n    \"\"\"Return true if the object is any kind of function or method.\"\"\"\n    return (isbuiltin(object)\n            or isfunction(object)\n            or ismethod(object)\n            or ismethoddescriptor(object)\n            or ismethodwrapper(object))\n\ndef isabstract(object):\n    \"\"\"Return true if the object is an abstract base class (ABC).\"\"\"\n    if not isinstance(object, type):\n        return False\n    if object.__flags__ & TPFLAGS_IS_ABSTRACT:\n        return True\n    if not issubclass(type(object), abc.ABCMeta):\n        return False\n    if hasattr(object, '__abstractmethods__'):\n        # It looks like ABCMeta.__new__ has finished running;\n        # TPFLAGS_IS_ABSTRACT should have been accurate.\n        return False\n    # It looks like ABCMeta.__new__ has not finished running yet; we're\n    # probably in __init_subclass__. We'll look for abstractmethods manually.\n    for name, value in object.__dict__.items():\n        if getattr(value, \"__isabstractmethod__\", False):\n            return True\n    for base in object.__bases__:\n        for name in getattr(base, \"__abstractmethods__\", ()):\n            value = getattr(object, name, None)\n            if getattr(value, \"__isabstractmethod__\", False):\n                return True\n    return False\n\ndef _getmembers(object, predicate, getter):\n    results = []\n    processed = set()\n    names = dir(object)\n    if isclass(object):\n        mro = (object,) + getmro(object)\n        # add any DynamicClassAttributes to the list of names if object is a class;\n        # this may result in duplicate entries if, for example, a virtual\n        # attribute with the same name as a DynamicClassAttribute exists\n        try:\n            for base in object.__bases__:\n                for k, v in base.__dict__.items():\n                    if isinstance(v, types.DynamicClassAttribute):\n                        names.append(k)\n        except AttributeError:\n            pass\n    else:\n        mro = ()\n    for key in names:\n        # First try to get the value via getattr.  Some descriptors don't\n        # like calling their __get__ (see bug #1785), so fall back to\n        # looking in the __dict__.\n        try:\n            value = getter(object, key)\n            # handle the duplicate key\n            if key in processed:\n                raise AttributeError\n        except AttributeError:\n            for base in mro:\n                if key in base.__dict__:\n                    value = base.__dict__[key]\n                    break\n            else:\n                # could be a (currently) missing slot member, or a buggy\n                # __dir__; discard and move on\n                continue\n        if not predicate or predicate(value):\n            results.append((key, value))\n        processed.add(key)\n    results.sort(key=lambda pair: pair[0])\n    return results\n\ndef getmembers(object, predicate=None):\n    \"\"\"Return all members of an object as (name, value) pairs sorted by name.\n    Optionally, only return members that satisfy a given predicate.\"\"\"\n    return _getmembers(object, predicate, getattr)\n\ndef getmembers_static(object, predicate=None):\n    \"\"\"Return all members of an object as (name, value) pairs sorted by name\n    without triggering dynamic lookup via the descriptor protocol,\n    __getattr__ or __getattribute__. Optionally, only return members that\n    satisfy a given predicate.\n\n    Note: this function may not be able to retrieve all members\n       that getmembers can fetch (like dynamically created attributes)\n       and may find members that getmembers can't (like descriptors\n       that raise AttributeError). It can also return descriptor objects\n       instead of instance members in some cases.\n    \"\"\"\n    return _getmembers(object, predicate, getattr_static)\n\nAttribute = namedtuple('Attribute', 'name kind defining_class object')\n\ndef classify_class_attrs(cls):\n    \"\"\"Return list of attribute-descriptor tuples.\n\n    For each name in dir(cls), the return list contains a 4-tuple\n    with these elements:\n\n        0. The name (a string).\n\n        1. The kind of attribute this is, one of these strings:\n               'class method'    created via classmethod()\n               'static method'   created via staticmethod()\n               'property'        created via property()\n               'method'          any other flavor of method or descriptor\n               'data'            not a method\n\n        2. The class which defined this attribute (a class).\n\n        3. The object as obtained by calling getattr; if this fails, or if the\n           resulting object does not live anywhere in the class' mro (including\n           metaclasses) then the object is looked up in the defining class's\n           dict (found by walking the mro).\n\n    If one of the items in dir(cls) is stored in the metaclass it will now\n    be discovered and not have None be listed as the class in which it was\n    defined.  Any items whose home class cannot be discovered are skipped.\n    \"\"\"\n\n    mro = getmro(cls)\n    metamro = getmro(type(cls)) # for attributes stored in the metaclass\n    metamro = tuple(cls for cls in metamro if cls not in (type, object))\n    class_bases = (cls,) + mro\n    all_bases = class_bases + metamro\n    names = dir(cls)\n    # :dd any DynamicClassAttributes to the list of names;\n    # this may result in duplicate entries if, for example, a virtual\n    # attribute with the same name as a DynamicClassAttribute exists.\n    for base in mro:\n        for k, v in base.__dict__.items():\n            if isinstance(v, types.DynamicClassAttribute) and v.fget is not None:\n                names.append(k)\n    result = []\n    processed = set()\n\n    for name in names:\n        # Get the object associated with the name, and where it was defined.\n        # Normal objects will be looked up with both getattr and directly in\n        # its class' dict (in case getattr fails [bug #1785], and also to look\n        # for a docstring).\n        # For DynamicClassAttributes on the second pass we only look in the\n        # class's dict.\n        #\n        # Getting an obj from the __dict__ sometimes reveals more than\n        # using getattr.  Static and class methods are dramatic examples.\n        homecls = None\n        get_obj = None\n        dict_obj = None\n        if name not in processed:\n            try:\n                if name == '__dict__':\n                    raise Exception(\"__dict__ is special, don't want the proxy\")\n                get_obj = getattr(cls, name)\n            except Exception as exc:\n                pass\n            else:\n                homecls = getattr(get_obj, \"__objclass__\", homecls)\n                if homecls not in class_bases:\n                    # if the resulting object does not live somewhere in the\n                    # mro, drop it and search the mro manually\n                    homecls = None\n                    last_cls = None\n                    # first look in the classes\n                    for srch_cls in class_bases:\n                        srch_obj = getattr(srch_cls, name, None)\n                        if srch_obj is get_obj:\n                            last_cls = srch_cls\n                    # then check the metaclasses\n                    for srch_cls in metamro:\n                        try:\n                            srch_obj = srch_cls.__getattr__(cls, name)\n                        except AttributeError:\n                            continue\n                        if srch_obj is get_obj:\n                            last_cls = srch_cls\n                    if last_cls is not None:\n                        homecls = last_cls\n        for base in all_bases:\n            if name in base.__dict__:\n                dict_obj = base.__dict__[name]\n                if homecls not in metamro:\n                    homecls = base\n                break\n        if homecls is None:\n            # unable to locate the attribute anywhere, most likely due to\n            # buggy custom __dir__; discard and move on\n            continue\n        obj = get_obj if get_obj is not None else dict_obj\n        # Classify the object or its descriptor.\n        if isinstance(dict_obj, (staticmethod, types.BuiltinMethodType)):\n            kind = \"static method\"\n            obj = dict_obj\n        elif isinstance(dict_obj, (classmethod, types.ClassMethodDescriptorType)):\n            kind = \"class method\"\n            obj = dict_obj\n        elif isinstance(dict_obj, property):\n            kind = \"property\"\n            obj = dict_obj\n        elif isroutine(obj):\n            kind = \"method\"\n        else:\n            kind = \"data\"\n        result.append(Attribute(name, kind, homecls, obj))\n        processed.add(name)\n    return result\n\n# ----------------------------------------------------------- class helpers\n\ndef getmro(cls):\n    \"Return tuple of base classes (including cls) in method resolution order.\"\n    return cls.__mro__\n\n# -------------------------------------------------------- function helpers\n\ndef unwrap(func, *, stop=None):\n    \"\"\"Get the object wrapped by *func*.\n\n   Follows the chain of :attr:`__wrapped__` attributes returning the last\n   object in the chain.\n\n   *stop* is an optional callback accepting an object in the wrapper chain\n   as its sole argument that allows the unwrapping to be terminated early if\n   the callback returns a true value. If the callback never returns a true\n   value, the last object in the chain is returned as usual. For example,\n   :func:`signature` uses this to stop unwrapping if any object in the\n   chain has a ``__signature__`` attribute defined.\n\n   :exc:`ValueError` is raised if a cycle is encountered.\n\n    \"\"\"\n    f = func  # remember the original func for error reporting\n    # Memoise by id to tolerate non-hashable objects, but store objects to\n    # ensure they aren't destroyed, which would allow their IDs to be reused.\n    memo = {id(f): f}\n    recursion_limit = sys.getrecursionlimit()\n    while not isinstance(func, type) and hasattr(func, '__wrapped__'):\n        if stop is not None and stop(func):\n            break\n        func = func.__wrapped__\n        id_func = id(func)\n        if (id_func in memo) or (len(memo) >= recursion_limit):\n            raise ValueError('wrapper loop when unwrapping {!r}'.format(f))\n        memo[id_func] = func\n    return func\n\n# -------------------------------------------------- source code extraction\ndef indentsize(line):\n    \"\"\"Return the indent size, in spaces, at the start of a line of text.\"\"\"\n    expline = line.expandtabs()\n    return len(expline) - len(expline.lstrip())\n\ndef _findclass(func):\n    cls = sys.modules.get(func.__module__)\n    if cls is None:\n        return None\n    for name in func.__qualname__.split('.')[:-1]:\n        cls = getattr(cls, name)\n    if not isclass(cls):\n        return None\n    return cls\n\ndef _finddoc(obj):\n    if isclass(obj):\n        for base in obj.__mro__:\n            if base is not object:\n                try:\n                    doc = base.__doc__\n                except AttributeError:\n                    continue\n                if doc is not None:\n                    return doc\n        return None\n\n    if ismethod(obj):\n        name = obj.__func__.__name__\n        self = obj.__self__\n        if (isclass(self) and\n            getattr(getattr(self, name, None), '__func__') is obj.__func__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    elif isfunction(obj):\n        name = obj.__name__\n        cls = _findclass(obj)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif isbuiltin(obj):\n        name = obj.__name__\n        self = obj.__self__\n        if (isclass(self) and\n            self.__qualname__ + '.' + name == obj.__qualname__):\n            # classmethod\n            cls = self\n        else:\n            cls = self.__class__\n    # Should be tested before isdatadescriptor().\n    elif isinstance(obj, property):\n        func = obj.fget\n        name = func.__name__\n        cls = _findclass(func)\n        if cls is None or getattr(cls, name) is not obj:\n            return None\n    elif ismethoddescriptor(obj) or isdatadescriptor(obj):\n        name = obj.__name__\n        cls = obj.__objclass__\n        if getattr(cls, name) is not obj:\n            return None\n        if ismemberdescriptor(obj):\n            slots = getattr(cls, '__slots__', None)\n            if isinstance(slots, dict) and name in slots:\n                return slots[name]\n    else:\n        return None\n    for base in cls.__mro__:\n        try:\n            doc = getattr(base, name).__doc__\n        except AttributeError:\n            continue\n        if doc is not None:\n            return doc\n    return None\n\ndef getdoc(object):\n    \"\"\"Get the documentation string for an object.\n\n    All tabs are expanded to spaces.  To clean up docstrings that are\n    indented to line up with blocks of code, any whitespace than can be\n    uniformly removed from the second line onwards is removed.\"\"\"\n    try:\n        doc = object.__doc__\n    except AttributeError:\n        return None\n    if doc is None:\n        try:\n            doc = _finddoc(object)\n        except (AttributeError, TypeError):\n            return None\n    if not isinstance(doc, str):\n        return None\n    return cleandoc(doc)\n\ndef cleandoc(doc):\n    \"\"\"Clean up indentation from docstrings.\n\n    Any whitespace that can be uniformly removed from the second line\n    onwards is removed.\"\"\"\n    try:\n        lines = doc.expandtabs().split('\\n')\n    except UnicodeError:\n        return None\n    else:\n        # Find minimum indentation of any non-blank lines after first line.\n        margin = sys.maxsize\n        for line in lines[1:]:\n            content = len(line.lstrip())\n            if content:\n                indent = len(line) - content\n                margin = min(margin, indent)\n        # Remove indentation.\n        if lines:\n            lines[0] = lines[0].lstrip()\n        if margin < sys.maxsize:\n            for i in range(1, len(lines)): lines[i] = lines[i][margin:]\n        # Remove any trailing or leading blank lines.\n        while lines and not lines[-1]:\n            lines.pop()\n        while lines and not lines[0]:\n            lines.pop(0)\n        return '\\n'.join(lines)\n\ndef getfile(object):\n    \"\"\"Work out which source or compiled file an object was defined in.\"\"\"\n    if ismodule(object):\n        if getattr(object, '__file__', None):\n            return object.__file__\n        raise TypeError('{!r} is a built-in module'.format(object))\n    if isclass(object):\n        if hasattr(object, '__module__'):\n            module = sys.modules.get(object.__module__)\n            if getattr(module, '__file__', None):\n                return module.__file__\n            if object.__module__ == '__main__':\n                raise OSError('source code not available')\n        raise TypeError('{!r} is a built-in class'.format(object))\n    if ismethod(object):\n        object = object.__func__\n    if isfunction(object):\n        object = object.__code__\n    if istraceback(object):\n        object = object.tb_frame\n    if isframe(object):\n        object = object.f_code\n    if iscode(object):\n        return object.co_filename\n    raise TypeError('module, class, method, function, traceback, frame, or '\n                    'code object was expected, got {}'.format(\n                    type(object).__name__))\n\ndef getmodulename(path):\n    \"\"\"Return the module name for a given file, or None.\"\"\"\n    fname = os.path.basename(path)\n    # Check for paths that look like an actual module file\n    suffixes = [(-len(suffix), suffix)\n                    for suffix in importlib.machinery.all_suffixes()]\n    suffixes.sort() # try longest suffixes first, in case they overlap\n    for neglen, suffix in suffixes:\n        if fname.endswith(suffix):\n            return fname[:neglen]\n    return None\n\ndef getsourcefile(object):\n    \"\"\"Return the filename that can be used to locate an object's source.\n    Return None if no way can be identified to get the source.\n    \"\"\"\n    filename = getfile(object)\n    all_bytecode_suffixes = importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]\n    all_bytecode_suffixes += importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]\n    if any(filename.endswith(s) for s in all_bytecode_suffixes):\n        filename = (os.path.splitext(filename)[0] +\n                    importlib.machinery.SOURCE_SUFFIXES[0])\n    elif any(filename.endswith(s) for s in\n                 importlib.machinery.EXTENSION_SUFFIXES):\n        return None\n    if os.path.exists(filename):\n        return filename\n    # only return a non-existent filename if the module has a PEP 302 loader\n    module = getmodule(object, filename)\n    if getattr(module, '__loader__', None) is not None:\n        return filename\n    elif getattr(getattr(module, \"__spec__\", None), \"loader\", None) is not None:\n        return filename\n    # or it is in the linecache\n    elif filename in linecache.cache:\n        return filename\n\ndef getabsfile(object, _filename=None):\n    \"\"\"Return an absolute path to the source or compiled file for an object.\n\n    The idea is for each object to have a unique origin, so this routine\n    normalizes the result as much as possible.\"\"\"\n    if _filename is None:\n        _filename = getsourcefile(object) or getfile(object)\n    return os.path.normcase(os.path.abspath(_filename))\n\nmodulesbyfile = {}\n_filesbymodname = {}\n\ndef getmodule(object, _filename=None):\n    \"\"\"Return the module an object was defined in, or None if not found.\"\"\"\n    if ismodule(object):\n        return object\n    if hasattr(object, '__module__'):\n        return sys.modules.get(object.__module__)\n    # Try the filename to modulename cache\n    if _filename is not None and _filename in modulesbyfile:\n        return sys.modules.get(modulesbyfile[_filename])\n    # Try the cache again with the absolute file name\n    try:\n        file = getabsfile(object, _filename)\n    except (TypeError, FileNotFoundError):\n        return None\n    if file in modulesbyfile:\n        return sys.modules.get(modulesbyfile[file])\n    # Update the filename to module name cache and check yet again\n    # Copy sys.modules in order to cope with changes while iterating\n    for modname, module in sys.modules.copy().items():\n        if ismodule(module) and hasattr(module, '__file__'):\n            f = module.__file__\n            if f == _filesbymodname.get(modname, None):\n                # Have already mapped this module, so skip it\n                continue\n            _filesbymodname[modname] = f\n            f = getabsfile(module)\n            # Always map to the name the module knows itself by\n            modulesbyfile[f] = modulesbyfile[\n                os.path.realpath(f)] = module.__name__\n    if file in modulesbyfile:\n        return sys.modules.get(modulesbyfile[file])\n    # Check the main module\n    main = sys.modules['__main__']\n    if not hasattr(object, '__name__'):\n        return None\n    if hasattr(main, object.__name__):\n        mainobject = getattr(main, object.__name__)\n        if mainobject is object:\n            return main\n    # Check builtins\n    builtin = sys.modules['builtins']\n    if hasattr(builtin, object.__name__):\n        builtinobject = getattr(builtin, object.__name__)\n        if builtinobject is object:\n            return builtin\n\n\nclass ClassFoundException(Exception):\n    pass\n\n\nclass _ClassFinder(ast.NodeVisitor):\n\n    def __init__(self, qualname):\n        self.stack = []\n        self.qualname = qualname\n\n    def visit_FunctionDef(self, node):\n        self.stack.append(node.name)\n        self.stack.append('<locals>')\n        self.generic_visit(node)\n        self.stack.pop()\n        self.stack.pop()\n\n    visit_AsyncFunctionDef = visit_FunctionDef\n\n    def visit_ClassDef(self, node):\n        self.stack.append(node.name)\n        if self.qualname == '.'.join(self.stack):\n            # Return the decorator for the class if present\n            if node.decorator_list:\n                line_number = node.decorator_list[0].lineno\n            else:\n                line_number = node.lineno\n\n            # decrement by one since lines starts with indexing by zero\n            line_number -= 1\n            raise ClassFoundException(line_number)\n        self.generic_visit(node)\n        self.stack.pop()\n\n\ndef findsource(object):\n    \"\"\"Return the entire source file and starting line number for an object.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of all the lines\n    in the file and the line number indexes a line in that list.  An OSError\n    is raised if the source code cannot be retrieved.\"\"\"\n\n    file = getsourcefile(object)\n    if file:\n        # Invalidate cache if needed.\n        linecache.checkcache(file)\n    else:\n        file = getfile(object)\n        # Allow filenames in form of \"<something>\" to pass through.\n        # `doctest` monkeypatches `linecache` module to enable\n        # inspection, so let `linecache.getlines` to be called.\n        if not (file.startswith('<') and file.endswith('>')):\n            raise OSError('source code not available')\n\n    module = getmodule(object, file)\n    if module:\n        lines = linecache.getlines(file, module.__dict__)\n    else:\n        lines = linecache.getlines(file)\n    if not lines:\n        raise OSError('could not get source code')\n\n    if ismodule(object):\n        return lines, 0\n\n    if isclass(object):\n        qualname = object.__qualname__\n        source = ''.join(lines)\n        tree = ast.parse(source)\n        class_finder = _ClassFinder(qualname)\n        try:\n            class_finder.visit(tree)\n        except ClassFoundException as e:\n            line_number = e.args[0]\n            return lines, line_number\n        else:\n            raise OSError('could not find class definition')\n\n    if ismethod(object):\n        object = object.__func__\n    if isfunction(object):\n        object = object.__code__\n    if istraceback(object):\n        object = object.tb_frame\n    if isframe(object):\n        object = object.f_code\n    if iscode(object):\n        if not hasattr(object, 'co_firstlineno'):\n            raise OSError('could not find function definition')\n        lnum = object.co_firstlineno - 1\n        pat = re.compile(r'^(\\s*def\\s)|(\\s*async\\s+def\\s)|(.*(?<!\\w)lambda(:|\\s))|^(\\s*@)')\n        while lnum > 0:\n            try:\n                line = lines[lnum]\n            except IndexError:\n                raise OSError('lineno is out of bounds')\n            if pat.match(line):\n                break\n            lnum = lnum - 1\n        return lines, lnum\n    raise OSError('could not find code object')\n\ndef getcomments(object):\n    \"\"\"Get lines of comments immediately preceding an object's source code.\n\n    Returns None when source can't be found.\n    \"\"\"\n    try:\n        lines, lnum = findsource(object)\n    except (OSError, TypeError):\n        return None\n\n    if ismodule(object):\n        # Look for a comment block at the top of the file.\n        start = 0\n        if lines and lines[0][:2] == '#!': start = 1\n        while start < len(lines) and lines[start].strip() in ('', '#'):\n            start = start + 1\n        if start < len(lines) and lines[start][:1] == '#':\n            comments = []\n            end = start\n            while end < len(lines) and lines[end][:1] == '#':\n                comments.append(lines[end].expandtabs())\n                end = end + 1\n            return ''.join(comments)\n\n    # Look for a preceding block of comments at the same indentation.\n    elif lnum > 0:\n        indent = indentsize(lines[lnum])\n        end = lnum - 1\n        if end >= 0 and lines[end].lstrip()[:1] == '#' and \\\n            indentsize(lines[end]) == indent:\n            comments = [lines[end].expandtabs().lstrip()]\n            if end > 0:\n                end = end - 1\n                comment = lines[end].expandtabs().lstrip()\n                while comment[:1] == '#' and indentsize(lines[end]) == indent:\n                    comments[:0] = [comment]\n                    end = end - 1\n                    if end < 0: break\n                    comment = lines[end].expandtabs().lstrip()\n            while comments and comments[0].strip() == '#':\n                comments[:1] = []\n            while comments and comments[-1].strip() == '#':\n                comments[-1:] = []\n            return ''.join(comments)\n\nclass EndOfBlock(Exception): pass\n\nclass BlockFinder:\n    \"\"\"Provide a tokeneater() method to detect the end of a code block.\"\"\"\n    def __init__(self):\n        self.indent = 0\n        self.islambda = False\n        self.started = False\n        self.passline = False\n        self.indecorator = False\n        self.last = 1\n        self.body_col0 = None\n\n    def tokeneater(self, type, token, srowcol, erowcol, line):\n        if not self.started and not self.indecorator:\n            # skip any decorators\n            if token == \"@\":\n                self.indecorator = True\n            # look for the first \"def\", \"class\" or \"lambda\"\n            elif token in (\"def\", \"class\", \"lambda\"):\n                if token == \"lambda\":\n                    self.islambda = True\n                self.started = True\n            self.passline = True    # skip to the end of the line\n        elif type == tokenize.NEWLINE:\n            self.passline = False   # stop skipping when a NEWLINE is seen\n            self.last = srowcol[0]\n            if self.islambda:       # lambdas always end at the first NEWLINE\n                raise EndOfBlock\n            # hitting a NEWLINE when in a decorator without args\n            # ends the decorator\n            if self.indecorator:\n                self.indecorator = False\n        elif self.passline:\n            pass\n        elif type == tokenize.INDENT:\n            if self.body_col0 is None and self.started:\n                self.body_col0 = erowcol[1]\n            self.indent = self.indent + 1\n            self.passline = True\n        elif type == tokenize.DEDENT:\n            self.indent = self.indent - 1\n            # the end of matching indent/dedent pairs end a block\n            # (note that this only works for \"def\"/\"class\" blocks,\n            #  not e.g. for \"if: else:\" or \"try: finally:\" blocks)\n            if self.indent <= 0:\n                raise EndOfBlock\n        elif type == tokenize.COMMENT:\n            if self.body_col0 is not None and srowcol[1] >= self.body_col0:\n                # Include comments if indented at least as much as the block\n                self.last = srowcol[0]\n        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):\n            # any other token on the same indentation level end the previous\n            # block as well, except the pseudo-tokens COMMENT and NL.\n            raise EndOfBlock\n\ndef getblock(lines):\n    \"\"\"Extract the block of code at the top of the given list of lines.\"\"\"\n    blockfinder = BlockFinder()\n    try:\n        tokens = tokenize.generate_tokens(iter(lines).__next__)\n        for _token in tokens:\n            blockfinder.tokeneater(*_token)\n    except (EndOfBlock, IndentationError):\n        pass\n    return lines[:blockfinder.last]\n\ndef getsourcelines(object):\n    \"\"\"Return a list of source lines and starting line number for an object.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of the lines\n    corresponding to the object and the line number indicates where in the\n    original source file the first line of code was found.  An OSError is\n    raised if the source code cannot be retrieved.\"\"\"\n    object = unwrap(object)\n    lines, lnum = findsource(object)\n\n    if istraceback(object):\n        object = object.tb_frame\n\n    # for module or frame that corresponds to module, return all source lines\n    if (ismodule(object) or\n        (isframe(object) and object.f_code.co_name == \"<module>\")):\n        return lines, 0\n    else:\n        return getblock(lines[lnum:]), lnum + 1\n\ndef getsource(object):\n    \"\"\"Return the text of the source code for an object.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a single string.  An\n    OSError is raised if the source code cannot be retrieved.\"\"\"\n    lines, lnum = getsourcelines(object)\n    return ''.join(lines)\n\n# --------------------------------------------------- class tree extraction\ndef walktree(classes, children, parent):\n    \"\"\"Recursive helper function for getclasstree().\"\"\"\n    results = []\n    classes.sort(key=attrgetter('__module__', '__name__'))\n    for c in classes:\n        results.append((c, c.__bases__))\n        if c in children:\n            results.append(walktree(children[c], children, c))\n    return results\n\ndef getclasstree(classes, unique=False):\n    \"\"\"Arrange the given list of classes into a hierarchy of nested lists.\n\n    Where a nested list appears, it contains classes derived from the class\n    whose entry immediately precedes the list.  Each entry is a 2-tuple\n    containing a class and a tuple of its base classes.  If the 'unique'\n    argument is true, exactly one entry appears in the returned structure\n    for each class in the given list.  Otherwise, classes using multiple\n    inheritance and their descendants will appear multiple times.\"\"\"\n    children = {}\n    roots = []\n    for c in classes:\n        if c.__bases__:\n            for parent in c.__bases__:\n                if parent not in children:\n                    children[parent] = []\n                if c not in children[parent]:\n                    children[parent].append(c)\n                if unique and parent in classes: break\n        elif c not in roots:\n            roots.append(c)\n    for parent in children:\n        if parent not in classes:\n            roots.append(parent)\n    return walktree(roots, children, None)\n\n# ------------------------------------------------ argument list extraction\nArguments = namedtuple('Arguments', 'args, varargs, varkw')\n\ndef getargs(co):\n    \"\"\"Get information about the arguments accepted by a code object.\n\n    Three things are returned: (args, varargs, varkw), where\n    'args' is the list of argument names. Keyword-only arguments are\n    appended. 'varargs' and 'varkw' are the names of the * and **\n    arguments or None.\"\"\"\n    if not iscode(co):\n        raise TypeError('{!r} is not a code object'.format(co))\n\n    names = co.co_varnames\n    nargs = co.co_argcount\n    nkwargs = co.co_kwonlyargcount\n    args = list(names[:nargs])\n    kwonlyargs = list(names[nargs:nargs+nkwargs])\n    step = 0\n\n    nargs += nkwargs\n    varargs = None\n    if co.co_flags & CO_VARARGS:\n        varargs = co.co_varnames[nargs]\n        nargs = nargs + 1\n    varkw = None\n    if co.co_flags & CO_VARKEYWORDS:\n        varkw = co.co_varnames[nargs]\n    return Arguments(args + kwonlyargs, varargs, varkw)\n\n\nFullArgSpec = namedtuple('FullArgSpec',\n    'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')\n\ndef getfullargspec(func):\n    \"\"\"Get the names and default values of a callable object's parameters.\n\n    A tuple of seven things is returned:\n    (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).\n    'args' is a list of the parameter names.\n    'varargs' and 'varkw' are the names of the * and ** parameters or None.\n    'defaults' is an n-tuple of the default values of the last n parameters.\n    'kwonlyargs' is a list of keyword-only parameter names.\n    'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.\n    'annotations' is a dictionary mapping parameter names to annotations.\n\n    Notable differences from inspect.signature():\n      - the \"self\" parameter is always reported, even for bound methods\n      - wrapper chains defined by __wrapped__ *not* unwrapped automatically\n    \"\"\"\n    try:\n        # Re: `skip_bound_arg=False`\n        #\n        # There is a notable difference in behaviour between getfullargspec\n        # and Signature: the former always returns 'self' parameter for bound\n        # methods, whereas the Signature always shows the actual calling\n        # signature of the passed object.\n        #\n        # To simulate this behaviour, we \"unbind\" bound methods, to trick\n        # inspect.signature to always return their first parameter (\"self\",\n        # usually)\n\n        # Re: `follow_wrapper_chains=False`\n        #\n        # getfullargspec() historically ignored __wrapped__ attributes,\n        # so we ensure that remains the case in 3.3+\n\n        sig = _signature_from_callable(func,\n                                       follow_wrapper_chains=False,\n                                       skip_bound_arg=False,\n                                       sigcls=Signature,\n                                       eval_str=False)\n    except Exception as ex:\n        # Most of the times 'signature' will raise ValueError.\n        # But, it can also raise AttributeError, and, maybe something\n        # else. So to be fully backwards compatible, we catch all\n        # possible exceptions here, and reraise a TypeError.\n        raise TypeError('unsupported callable') from ex\n\n    args = []\n    varargs = None\n    varkw = None\n    posonlyargs = []\n    kwonlyargs = []\n    annotations = {}\n    defaults = ()\n    kwdefaults = {}\n\n    if sig.return_annotation is not sig.empty:\n        annotations['return'] = sig.return_annotation\n\n    for param in sig.parameters.values():\n        kind = param.kind\n        name = param.name\n\n        if kind is _POSITIONAL_ONLY:\n            posonlyargs.append(name)\n            if param.default is not param.empty:\n                defaults += (param.default,)\n        elif kind is _POSITIONAL_OR_KEYWORD:\n            args.append(name)\n            if param.default is not param.empty:\n                defaults += (param.default,)\n        elif kind is _VAR_POSITIONAL:\n            varargs = name\n        elif kind is _KEYWORD_ONLY:\n            kwonlyargs.append(name)\n            if param.default is not param.empty:\n                kwdefaults[name] = param.default\n        elif kind is _VAR_KEYWORD:\n            varkw = name\n\n        if param.annotation is not param.empty:\n            annotations[name] = param.annotation\n\n    if not kwdefaults:\n        # compatibility with 'func.__kwdefaults__'\n        kwdefaults = None\n\n    if not defaults:\n        # compatibility with 'func.__defaults__'\n        defaults = None\n\n    return FullArgSpec(posonlyargs + args, varargs, varkw, defaults,\n                       kwonlyargs, kwdefaults, annotations)\n\n\nArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')\n\ndef getargvalues(frame):\n    \"\"\"Get information about arguments passed into a particular frame.\n\n    A tuple of four things is returned: (args, varargs, varkw, locals).\n    'args' is a list of the argument names.\n    'varargs' and 'varkw' are the names of the * and ** arguments or None.\n    'locals' is the locals dictionary of the given frame.\"\"\"\n    args, varargs, varkw = getargs(frame.f_code)\n    return ArgInfo(args, varargs, varkw, frame.f_locals)\n\ndef formatannotation(annotation, base_module=None):\n    if getattr(annotation, '__module__', None) == 'typing':\n        def repl(match):\n            text = match.group()\n            return text.removeprefix('typing.')\n        return re.sub(r'[\\w\\.]+', repl, repr(annotation))\n    if isinstance(annotation, types.GenericAlias):\n        return str(annotation)\n    if isinstance(annotation, type):\n        if annotation.__module__ in ('builtins', base_module):\n            return annotation.__qualname__\n        return annotation.__module__+'.'+annotation.__qualname__\n    return repr(annotation)\n\ndef formatannotationrelativeto(object):\n    module = getattr(object, '__module__', None)\n    def _formatannotation(annotation):\n        return formatannotation(annotation, module)\n    return _formatannotation\n\n\ndef formatargvalues(args, varargs, varkw, locals,\n                    formatarg=str,\n                    formatvarargs=lambda name: '*' + name,\n                    formatvarkw=lambda name: '**' + name,\n                    formatvalue=lambda value: '=' + repr(value)):\n    \"\"\"Format an argument spec from the 4 values returned by getargvalues.\n\n    The first four arguments are (args, varargs, varkw, locals).  The\n    next four arguments are the corresponding optional formatting functions\n    that are called to turn names and values into strings.  The ninth\n    argument is an optional function to format the sequence of arguments.\"\"\"\n    def convert(name, locals=locals,\n                formatarg=formatarg, formatvalue=formatvalue):\n        return formatarg(name) + formatvalue(locals[name])\n    specs = []\n    for i in range(len(args)):\n        specs.append(convert(args[i]))\n    if varargs:\n        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))\n    if varkw:\n        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))\n    return '(' + ', '.join(specs) + ')'\n\ndef _missing_arguments(f_name, argnames, pos, values):\n    names = [repr(name) for name in argnames if name not in values]\n    missing = len(names)\n    if missing == 1:\n        s = names[0]\n    elif missing == 2:\n        s = \"{} and {}\".format(*names)\n    else:\n        tail = \", {} and {}\".format(*names[-2:])\n        del names[-2:]\n        s = \", \".join(names) + tail\n    raise TypeError(\"%s() missing %i required %s argument%s: %s\" %\n                    (f_name, missing,\n                      \"positional\" if pos else \"keyword-only\",\n                      \"\" if missing == 1 else \"s\", s))\n\ndef _too_many(f_name, args, kwonly, varargs, defcount, given, values):\n    atleast = len(args) - defcount\n    kwonly_given = len([arg for arg in kwonly if arg in values])\n    if varargs:\n        plural = atleast != 1\n        sig = \"at least %d\" % (atleast,)\n    elif defcount:\n        plural = True\n        sig = \"from %d to %d\" % (atleast, len(args))\n    else:\n        plural = len(args) != 1\n        sig = str(len(args))\n    kwonly_sig = \"\"\n    if kwonly_given:\n        msg = \" positional argument%s (and %d keyword-only argument%s)\"\n        kwonly_sig = (msg % (\"s\" if given != 1 else \"\", kwonly_given,\n                             \"s\" if kwonly_given != 1 else \"\"))\n    raise TypeError(\"%s() takes %s positional argument%s but %d%s %s given\" %\n            (f_name, sig, \"s\" if plural else \"\", given, kwonly_sig,\n             \"was\" if given == 1 and not kwonly_given else \"were\"))\n\ndef getcallargs(func, /, *positional, **named):\n    \"\"\"Get the mapping of arguments to values.\n\n    A dict is returned, with keys the function argument names (including the\n    names of the * and ** arguments, if any), and values the respective bound\n    values from 'positional' and 'named'.\"\"\"\n    spec = getfullargspec(func)\n    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = spec\n    f_name = func.__name__\n    arg2value = {}\n\n\n    if ismethod(func) and func.__self__ is not None:\n        # implicit 'self' (or 'cls' for classmethods) argument\n        positional = (func.__self__,) + positional\n    num_pos = len(positional)\n    num_args = len(args)\n    num_defaults = len(defaults) if defaults else 0\n\n    n = min(num_pos, num_args)\n    for i in range(n):\n        arg2value[args[i]] = positional[i]\n    if varargs:\n        arg2value[varargs] = tuple(positional[n:])\n    possible_kwargs = set(args + kwonlyargs)\n    if varkw:\n        arg2value[varkw] = {}\n    for kw, value in named.items():\n        if kw not in possible_kwargs:\n            if not varkw:\n                raise TypeError(\"%s() got an unexpected keyword argument %r\" %\n                                (f_name, kw))\n            arg2value[varkw][kw] = value\n            continue\n        if kw in arg2value:\n            raise TypeError(\"%s() got multiple values for argument %r\" %\n                            (f_name, kw))\n        arg2value[kw] = value\n    if num_pos > num_args and not varargs:\n        _too_many(f_name, args, kwonlyargs, varargs, num_defaults,\n                   num_pos, arg2value)\n    if num_pos < num_args:\n        req = args[:num_args - num_defaults]\n        for arg in req:\n            if arg not in arg2value:\n                _missing_arguments(f_name, req, True, arg2value)\n        for i, arg in enumerate(args[num_args - num_defaults:]):\n            if arg not in arg2value:\n                arg2value[arg] = defaults[i]\n    missing = 0\n    for kwarg in kwonlyargs:\n        if kwarg not in arg2value:\n            if kwonlydefaults and kwarg in kwonlydefaults:\n                arg2value[kwarg] = kwonlydefaults[kwarg]\n            else:\n                missing += 1\n    if missing:\n        _missing_arguments(f_name, kwonlyargs, False, arg2value)\n    return arg2value\n\nClosureVars = namedtuple('ClosureVars', 'nonlocals globals builtins unbound')\n\ndef getclosurevars(func):\n    \"\"\"\n    Get the mapping of free variables to their current values.\n\n    Returns a named tuple of dicts mapping the current nonlocal, global\n    and builtin references as seen by the body of the function. A final\n    set of unbound names that could not be resolved is also provided.\n    \"\"\"\n\n    if ismethod(func):\n        func = func.__func__\n\n    if not isfunction(func):\n        raise TypeError(\"{!r} is not a Python function\".format(func))\n\n    code = func.__code__\n    # Nonlocal references are named in co_freevars and resolved\n    # by looking them up in __closure__ by positional index\n    if func.__closure__ is None:\n        nonlocal_vars = {}\n    else:\n        nonlocal_vars = {\n            var : cell.cell_contents\n            for var, cell in zip(code.co_freevars, func.__closure__)\n       }\n\n    # Global and builtin references are named in co_names and resolved\n    # by looking them up in __globals__ or __builtins__\n    global_ns = func.__globals__\n    builtin_ns = global_ns.get(\"__builtins__\", builtins.__dict__)\n    if ismodule(builtin_ns):\n        builtin_ns = builtin_ns.__dict__\n    global_vars = {}\n    builtin_vars = {}\n    unbound_names = set()\n    for name in code.co_names:\n        if name in (\"None\", \"True\", \"False\"):\n            # Because these used to be builtins instead of keywords, they\n            # may still show up as name references. We ignore them.\n            continue\n        try:\n            global_vars[name] = global_ns[name]\n        except KeyError:\n            try:\n                builtin_vars[name] = builtin_ns[name]\n            except KeyError:\n                unbound_names.add(name)\n\n    return ClosureVars(nonlocal_vars, global_vars,\n                       builtin_vars, unbound_names)\n\n# -------------------------------------------------- stack frame extraction\n\n_Traceback = namedtuple('_Traceback', 'filename lineno function code_context index')\n\nclass Traceback(_Traceback):\n    def __new__(cls, filename, lineno, function, code_context, index, *, positions=None):\n        instance = super().__new__(cls, filename, lineno, function, code_context, index)\n        instance.positions = positions\n        return instance\n\n    def __repr__(self):\n        return ('Traceback(filename={!r}, lineno={!r}, function={!r}, '\n               'code_context={!r}, index={!r}, positions={!r})'.format(\n                self.filename, self.lineno, self.function, self.code_context,\n                self.index, self.positions))\n\ndef _get_code_position_from_tb(tb):\n    code, instruction_index = tb.tb_frame.f_code, tb.tb_lasti\n    return _get_code_position(code, instruction_index)\n\ndef _get_code_position(code, instruction_index):\n    if instruction_index < 0:\n        return (None, None, None, None)\n    positions_gen = code.co_positions()\n    # The nth entry in code.co_positions() corresponds to instruction (2*n)th since Python 3.10+\n    return next(itertools.islice(positions_gen, instruction_index // 2, None))\n\ndef getframeinfo(frame, context=1):\n    \"\"\"Get information about a frame or traceback object.\n\n    A tuple of five things is returned: the filename, the line number of\n    the current line, the function name, a list of lines of context from\n    the source code, and the index of the current line within that list.\n    The optional second argument specifies the number of lines of context\n    to return, which are centered around the current line.\"\"\"\n    if istraceback(frame):\n        positions = _get_code_position_from_tb(frame)\n        lineno = frame.tb_lineno\n        frame = frame.tb_frame\n    else:\n        lineno = frame.f_lineno\n        positions = _get_code_position(frame.f_code, frame.f_lasti)\n\n    if positions[0] is None:\n        frame, *positions = (frame, lineno, *positions[1:])\n    else:\n        frame, *positions = (frame, *positions)\n\n    lineno = positions[0]\n\n    if not isframe(frame):\n        raise TypeError('{!r} is not a frame or traceback object'.format(frame))\n\n    filename = getsourcefile(frame) or getfile(frame)\n    if context > 0:\n        start = lineno - 1 - context//2\n        try:\n            lines, lnum = findsource(frame)\n        except OSError:\n            lines = index = None\n        else:\n            start = max(0, min(start, len(lines) - context))\n            lines = lines[start:start+context]\n            index = lineno - 1 - start\n    else:\n        lines = index = None\n\n    return Traceback(filename, lineno, frame.f_code.co_name, lines,\n                     index, positions=dis.Positions(*positions))\n\ndef getlineno(frame):\n    \"\"\"Get the line number from a frame object, allowing for optimization.\"\"\"\n    # FrameType.f_lineno is now a descriptor that grovels co_lnotab\n    return frame.f_lineno\n\n_FrameInfo = namedtuple('_FrameInfo', ('frame',) + Traceback._fields)\nclass FrameInfo(_FrameInfo):\n    def __new__(cls, frame, filename, lineno, function, code_context, index, *, positions=None):\n        instance = super().__new__(cls, frame, filename, lineno, function, code_context, index)\n        instance.positions = positions\n        return instance\n\n    def __repr__(self):\n        return ('FrameInfo(frame={!r}, filename={!r}, lineno={!r}, function={!r}, '\n               'code_context={!r}, index={!r}, positions={!r})'.format(\n                self.frame, self.filename, self.lineno, self.function,\n                self.code_context, self.index, self.positions))\n\ndef getouterframes(frame, context=1):\n    \"\"\"Get a list of records for a frame and all higher (calling) frames.\n\n    Each record contains a frame object, filename, line number, function\n    name, a list of lines of context, and index within the context.\"\"\"\n    framelist = []\n    while frame:\n        traceback_info = getframeinfo(frame, context)\n        frameinfo = (frame,) + traceback_info\n        framelist.append(FrameInfo(*frameinfo, positions=traceback_info.positions))\n        frame = frame.f_back\n    return framelist\n\ndef getinnerframes(tb, context=1):\n    \"\"\"Get a list of records for a traceback's frame and all lower frames.\n\n    Each record contains a frame object, filename, line number, function\n    name, a list of lines of context, and index within the context.\"\"\"\n    framelist = []\n    while tb:\n        traceback_info = getframeinfo(tb, context)\n        frameinfo = (tb.tb_frame,) + traceback_info\n        framelist.append(FrameInfo(*frameinfo, positions=traceback_info.positions))\n        tb = tb.tb_next\n    return framelist\n\ndef currentframe():\n    \"\"\"Return the frame of the caller or None if this is not possible.\"\"\"\n    return sys._getframe(1) if hasattr(sys, \"_getframe\") else None\n\ndef stack(context=1):\n    \"\"\"Return a list of records for the stack above the caller's frame.\"\"\"\n    return getouterframes(sys._getframe(1), context)\n\ndef trace(context=1):\n    \"\"\"Return a list of records for the stack below the current exception.\"\"\"\n    return getinnerframes(sys.exc_info()[2], context)\n\n\n# ------------------------------------------------ static version of getattr\n\n_sentinel = object()\n\ndef _static_getmro(klass):\n    return type.__dict__['__mro__'].__get__(klass)\n\ndef _check_instance(obj, attr):\n    instance_dict = {}\n    try:\n        instance_dict = object.__getattribute__(obj, \"__dict__\")\n    except AttributeError:\n        pass\n    return dict.get(instance_dict, attr, _sentinel)\n\n\ndef _check_class(klass, attr):\n    for entry in _static_getmro(klass):\n        if _shadowed_dict(type(entry)) is _sentinel:\n            try:\n                return entry.__dict__[attr]\n            except KeyError:\n                pass\n    return _sentinel\n\ndef _is_type(obj):\n    try:\n        _static_getmro(obj)\n    except TypeError:\n        return False\n    return True\n\ndef _shadowed_dict(klass):\n    dict_attr = type.__dict__[\"__dict__\"]\n    for entry in _static_getmro(klass):\n        try:\n            class_dict = dict_attr.__get__(entry)[\"__dict__\"]\n        except KeyError:\n            pass\n        else:\n            if not (type(class_dict) is types.GetSetDescriptorType and\n                    class_dict.__name__ == \"__dict__\" and\n                    class_dict.__objclass__ is entry):\n                return class_dict\n    return _sentinel\n\ndef getattr_static(obj, attr, default=_sentinel):\n    \"\"\"Retrieve attributes without triggering dynamic lookup via the\n       descriptor protocol,  __getattr__ or __getattribute__.\n\n       Note: this function may not be able to retrieve all attributes\n       that getattr can fetch (like dynamically created attributes)\n       and may find attributes that getattr can't (like descriptors\n       that raise AttributeError). It can also return descriptor objects\n       instead of instance members in some cases. See the\n       documentation for details.\n    \"\"\"\n    instance_result = _sentinel\n    if not _is_type(obj):\n        klass = type(obj)\n        dict_attr = _shadowed_dict(klass)\n        if (dict_attr is _sentinel or\n            type(dict_attr) is types.MemberDescriptorType):\n            instance_result = _check_instance(obj, attr)\n    else:\n        klass = obj\n\n    klass_result = _check_class(klass, attr)\n\n    if instance_result is not _sentinel and klass_result is not _sentinel:\n        if _check_class(type(klass_result), \"__get__\") is not _sentinel and (\n            _check_class(type(klass_result), \"__set__\") is not _sentinel\n            or _check_class(type(klass_result), \"__delete__\") is not _sentinel\n        ):\n            return klass_result\n\n    if instance_result is not _sentinel:\n        return instance_result\n    if klass_result is not _sentinel:\n        return klass_result\n\n    if obj is klass:\n        # for types we check the metaclass too\n        for entry in _static_getmro(type(klass)):\n            if _shadowed_dict(type(entry)) is _sentinel:\n                try:\n                    return entry.__dict__[attr]\n                except KeyError:\n                    pass\n    if default is not _sentinel:\n        return default\n    raise AttributeError(attr)\n\n\n# ------------------------------------------------ generator introspection\n\nGEN_CREATED = 'GEN_CREATED'\nGEN_RUNNING = 'GEN_RUNNING'\nGEN_SUSPENDED = 'GEN_SUSPENDED'\nGEN_CLOSED = 'GEN_CLOSED'\n\ndef getgeneratorstate(generator):\n    \"\"\"Get current state of a generator-iterator.\n\n    Possible states are:\n      GEN_CREATED: Waiting to start execution.\n      GEN_RUNNING: Currently being executed by the interpreter.\n      GEN_SUSPENDED: Currently suspended at a yield expression.\n      GEN_CLOSED: Execution has completed.\n    \"\"\"\n    if generator.gi_running:\n        return GEN_RUNNING\n    if generator.gi_suspended:\n        return GEN_SUSPENDED\n    if generator.gi_frame is None:\n        return GEN_CLOSED\n    return GEN_CREATED\n\n\ndef getgeneratorlocals(generator):\n    \"\"\"\n    Get the mapping of generator local variables to their current values.\n\n    A dict is returned, with the keys the local variable names and values the\n    bound values.\"\"\"\n\n    if not isgenerator(generator):\n        raise TypeError(\"{!r} is not a Python generator\".format(generator))\n\n    frame = getattr(generator, \"gi_frame\", None)\n    if frame is not None:\n        return generator.gi_frame.f_locals\n    else:\n        return {}\n\n\n# ------------------------------------------------ coroutine introspection\n\nCORO_CREATED = 'CORO_CREATED'\nCORO_RUNNING = 'CORO_RUNNING'\nCORO_SUSPENDED = 'CORO_SUSPENDED'\nCORO_CLOSED = 'CORO_CLOSED'\n\ndef getcoroutinestate(coroutine):\n    \"\"\"Get current state of a coroutine object.\n\n    Possible states are:\n      CORO_CREATED: Waiting to start execution.\n      CORO_RUNNING: Currently being executed by the interpreter.\n      CORO_SUSPENDED: Currently suspended at an await expression.\n      CORO_CLOSED: Execution has completed.\n    \"\"\"\n    if coroutine.cr_running:\n        return CORO_RUNNING\n    if coroutine.cr_suspended:\n        return CORO_SUSPENDED\n    if coroutine.cr_frame is None:\n        return CORO_CLOSED\n    return CORO_CREATED\n\n\ndef getcoroutinelocals(coroutine):\n    \"\"\"\n    Get the mapping of coroutine local variables to their current values.\n\n    A dict is returned, with the keys the local variable names and values the\n    bound values.\"\"\"\n    frame = getattr(coroutine, \"cr_frame\", None)\n    if frame is not None:\n        return frame.f_locals\n    else:\n        return {}\n\n\n###############################################################################\n### Function Signature Object (PEP 362)\n###############################################################################\n\n\n_NonUserDefinedCallables = (types.WrapperDescriptorType,\n                            types.MethodWrapperType,\n                            types.ClassMethodDescriptorType,\n                            types.BuiltinFunctionType)\n\n\ndef _signature_get_user_defined_method(cls, method_name):\n    \"\"\"Private helper. Checks if ``cls`` has an attribute\n    named ``method_name`` and returns it only if it is a\n    pure python function.\n    \"\"\"\n    if method_name == '__new__':\n        meth = getattr(cls, method_name, None)\n    else:\n        meth = getattr_static(cls, method_name, None)\n    if meth is None or isinstance(meth, _NonUserDefinedCallables):\n        # Once '__signature__' will be added to 'C'-level\n        # callables, this check won't be necessary\n        return None\n    if method_name != '__new__':\n        meth = _descriptor_get(meth, cls)\n    return meth\n\n\ndef _signature_get_partial(wrapped_sig, partial, extra_args=()):\n    \"\"\"Private helper to calculate how 'wrapped_sig' signature will\n    look like after applying a 'functools.partial' object (or alike)\n    on it.\n    \"\"\"\n\n    old_params = wrapped_sig.parameters\n    new_params = OrderedDict(old_params.items())\n\n    partial_args = partial.args or ()\n    partial_keywords = partial.keywords or {}\n\n    if extra_args:\n        partial_args = extra_args + partial_args\n\n    try:\n        ba = wrapped_sig.bind_partial(*partial_args, **partial_keywords)\n    except TypeError as ex:\n        msg = 'partial object {!r} has incorrect arguments'.format(partial)\n        raise ValueError(msg) from ex\n\n\n    transform_to_kwonly = False\n    for param_name, param in old_params.items():\n        try:\n            arg_value = ba.arguments[param_name]\n        except KeyError:\n            pass\n        else:\n            if param.kind is _POSITIONAL_ONLY:\n                # If positional-only parameter is bound by partial,\n                # it effectively disappears from the signature\n                new_params.pop(param_name)\n                continue\n\n            if param.kind is _POSITIONAL_OR_KEYWORD:\n                if param_name in partial_keywords:\n                    # This means that this parameter, and all parameters\n                    # after it should be keyword-only (and var-positional\n                    # should be removed). Here's why. Consider the following\n                    # function:\n                    #     foo(a, b, *args, c):\n                    #         pass\n                    #\n                    # \"partial(foo, a='spam')\" will have the following\n                    # signature: \"(*, a='spam', b, c)\". Because attempting\n                    # to call that partial with \"(10, 20)\" arguments will\n                    # raise a TypeError, saying that \"a\" argument received\n                    # multiple values.\n                    transform_to_kwonly = True\n                    # Set the new default value\n                    new_params[param_name] = param.replace(default=arg_value)\n                else:\n                    # was passed as a positional argument\n                    new_params.pop(param.name)\n                    continue\n\n            if param.kind is _KEYWORD_ONLY:\n                # Set the new default value\n                new_params[param_name] = param.replace(default=arg_value)\n\n        if transform_to_kwonly:\n            assert param.kind is not _POSITIONAL_ONLY\n\n            if param.kind is _POSITIONAL_OR_KEYWORD:\n                new_param = new_params[param_name].replace(kind=_KEYWORD_ONLY)\n                new_params[param_name] = new_param\n                new_params.move_to_end(param_name)\n            elif param.kind in (_KEYWORD_ONLY, _VAR_KEYWORD):\n                new_params.move_to_end(param_name)\n            elif param.kind is _VAR_POSITIONAL:\n                new_params.pop(param.name)\n\n    return wrapped_sig.replace(parameters=new_params.values())\n\n\ndef _signature_bound_method(sig):\n    \"\"\"Private helper to transform signatures for unbound\n    functions to bound methods.\n    \"\"\"\n\n    params = tuple(sig.parameters.values())\n\n    if not params or params[0].kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n        raise ValueError('invalid method signature')\n\n    kind = params[0].kind\n    if kind in (_POSITIONAL_OR_KEYWORD, _POSITIONAL_ONLY):\n        # Drop first parameter:\n        # '(p1, p2[, ...])' -> '(p2[, ...])'\n        params = params[1:]\n    else:\n        if kind is not _VAR_POSITIONAL:\n            # Unless we add a new parameter type we never\n            # get here\n            raise ValueError('invalid argument type')\n        # It's a var-positional parameter.\n        # Do nothing. '(*args[, ...])' -> '(*args[, ...])'\n\n    return sig.replace(parameters=params)\n\n\ndef _signature_is_builtin(obj):\n    \"\"\"Private helper to test if `obj` is a callable that might\n    support Argument Clinic's __text_signature__ protocol.\n    \"\"\"\n    return (isbuiltin(obj) or\n            ismethoddescriptor(obj) or\n            isinstance(obj, _NonUserDefinedCallables) or\n            # Can't test 'isinstance(type)' here, as it would\n            # also be True for regular python classes\n            obj in (type, object))\n\n\ndef _signature_is_functionlike(obj):\n    \"\"\"Private helper to test if `obj` is a duck type of FunctionType.\n    A good example of such objects are functions compiled with\n    Cython, which have all attributes that a pure Python function\n    would have, but have their code statically compiled.\n    \"\"\"\n\n    if not callable(obj) or isclass(obj):\n        # All function-like objects are obviously callables,\n        # and not classes.\n        return False\n\n    name = getattr(obj, '__name__', None)\n    code = getattr(obj, '__code__', None)\n    defaults = getattr(obj, '__defaults__', _void) # Important to use _void ...\n    kwdefaults = getattr(obj, '__kwdefaults__', _void) # ... and not None here\n    annotations = getattr(obj, '__annotations__', None)\n\n    return (isinstance(code, types.CodeType) and\n            isinstance(name, str) and\n            (defaults is None or isinstance(defaults, tuple)) and\n            (kwdefaults is None or isinstance(kwdefaults, dict)) and\n            (isinstance(annotations, (dict)) or annotations is None) )\n\n\ndef _signature_strip_non_python_syntax(signature):\n    \"\"\"\n    Private helper function. Takes a signature in Argument Clinic's\n    extended signature format.\n\n    Returns a tuple of three things:\n      * that signature re-rendered in standard Python syntax,\n      * the index of the \"self\" parameter (generally 0), or None if\n        the function does not have a \"self\" parameter, and\n      * the index of the last \"positional only\" parameter,\n        or None if the signature has no positional-only parameters.\n    \"\"\"\n\n    if not signature:\n        return signature, None, None\n\n    self_parameter = None\n    last_positional_only = None\n\n    lines = [l.encode('ascii') for l in signature.split('\\n') if l]\n    generator = iter(lines).__next__\n    token_stream = tokenize.tokenize(generator)\n\n    delayed_comma = False\n    skip_next_comma = False\n    text = []\n    add = text.append\n\n    current_parameter = 0\n    OP = token.OP\n    ERRORTOKEN = token.ERRORTOKEN\n\n    # token stream always starts with ENCODING token, skip it\n    t = next(token_stream)\n    assert t.type == tokenize.ENCODING\n\n    for t in token_stream:\n        type, string = t.type, t.string\n\n        if type == OP:\n            if string == ',':\n                if skip_next_comma:\n                    skip_next_comma = False\n                else:\n                    assert not delayed_comma\n                    delayed_comma = True\n                    current_parameter += 1\n                continue\n\n            if string == '/':\n                assert not skip_next_comma\n                assert last_positional_only is None\n                skip_next_comma = True\n                last_positional_only = current_parameter - 1\n                continue\n\n        if (type == ERRORTOKEN) and (string == '$'):\n            assert self_parameter is None\n            self_parameter = current_parameter\n            continue\n\n        if delayed_comma:\n            delayed_comma = False\n            if not ((type == OP) and (string == ')')):\n                add(', ')\n        add(string)\n        if (string == ','):\n            add(' ')\n    clean_signature = ''.join(text)\n    return clean_signature, self_parameter, last_positional_only\n\n\ndef _signature_fromstr(cls, obj, s, skip_bound_arg=True):\n    \"\"\"Private helper to parse content of '__text_signature__'\n    and return a Signature based on it.\n    \"\"\"\n    Parameter = cls._parameter_cls\n\n    clean_signature, self_parameter, last_positional_only = \\\n        _signature_strip_non_python_syntax(s)\n\n    program = \"def foo\" + clean_signature + \": pass\"\n\n    try:\n        module = ast.parse(program)\n    except SyntaxError:\n        module = None\n\n    if not isinstance(module, ast.Module):\n        raise ValueError(\"{!r} builtin has invalid signature\".format(obj))\n\n    f = module.body[0]\n\n    parameters = []\n    empty = Parameter.empty\n\n    module = None\n    module_dict = {}\n    module_name = getattr(obj, '__module__', None)\n    if module_name:\n        module = sys.modules.get(module_name, None)\n        if module:\n            module_dict = module.__dict__\n    sys_module_dict = sys.modules.copy()\n\n    def parse_name(node):\n        assert isinstance(node, ast.arg)\n        if node.annotation is not None:\n            raise ValueError(\"Annotations are not currently supported\")\n        return node.arg\n\n    def wrap_value(s):\n        try:\n            value = eval(s, module_dict)\n        except NameError:\n            try:\n                value = eval(s, sys_module_dict)\n            except NameError:\n                raise ValueError\n\n        if isinstance(value, (str, int, float, bytes, bool, type(None))):\n            return ast.Constant(value)\n        raise ValueError\n\n    class RewriteSymbolics(ast.NodeTransformer):\n        def visit_Attribute(self, node):\n            a = []\n            n = node\n            while isinstance(n, ast.Attribute):\n                a.append(n.attr)\n                n = n.value\n            if not isinstance(n, ast.Name):\n                raise ValueError\n            a.append(n.id)\n            value = \".\".join(reversed(a))\n            return wrap_value(value)\n\n        def visit_Name(self, node):\n            if not isinstance(node.ctx, ast.Load):\n                raise ValueError()\n            return wrap_value(node.id)\n\n        def visit_BinOp(self, node):\n            # Support constant folding of a couple simple binary operations\n            # commonly used to define default values in text signatures\n            left = self.visit(node.left)\n            right = self.visit(node.right)\n            if not isinstance(left, ast.Constant) or not isinstance(right, ast.Constant):\n                raise ValueError\n            if isinstance(node.op, ast.Add):\n                return ast.Constant(left.value + right.value)\n            elif isinstance(node.op, ast.Sub):\n                return ast.Constant(left.value - right.value)\n            elif isinstance(node.op, ast.BitOr):\n                return ast.Constant(left.value | right.value)\n            raise ValueError\n\n    def p(name_node, default_node, default=empty):\n        name = parse_name(name_node)\n        if default_node and default_node is not _empty:\n            try:\n                default_node = RewriteSymbolics().visit(default_node)\n                default = ast.literal_eval(default_node)\n            except ValueError:\n                raise ValueError(\"{!r} builtin has invalid signature\".format(obj)) from None\n        parameters.append(Parameter(name, kind, default=default, annotation=empty))\n\n    # non-keyword-only parameters\n    args = reversed(f.args.args)\n    defaults = reversed(f.args.defaults)\n    iter = itertools.zip_longest(args, defaults, fillvalue=None)\n    if last_positional_only is not None:\n        kind = Parameter.POSITIONAL_ONLY\n    else:\n        kind = Parameter.POSITIONAL_OR_KEYWORD\n    for i, (name, default) in enumerate(reversed(list(iter))):\n        p(name, default)\n        if i == last_positional_only:\n            kind = Parameter.POSITIONAL_OR_KEYWORD\n\n    # *args\n    if f.args.vararg:\n        kind = Parameter.VAR_POSITIONAL\n        p(f.args.vararg, empty)\n\n    # keyword-only arguments\n    kind = Parameter.KEYWORD_ONLY\n    for name, default in zip(f.args.kwonlyargs, f.args.kw_defaults):\n        p(name, default)\n\n    # **kwargs\n    if f.args.kwarg:\n        kind = Parameter.VAR_KEYWORD\n        p(f.args.kwarg, empty)\n\n    if self_parameter is not None:\n        # Possibly strip the bound argument:\n        #    - We *always* strip first bound argument if\n        #      it is a module.\n        #    - We don't strip first bound argument if\n        #      skip_bound_arg is False.\n        assert parameters\n        _self = getattr(obj, '__self__', None)\n        self_isbound = _self is not None\n        self_ismodule = ismodule(_self)\n        if self_isbound and (self_ismodule or skip_bound_arg):\n            parameters.pop(0)\n        else:\n            # for builtins, self parameter is always positional-only!\n            p = parameters[0].replace(kind=Parameter.POSITIONAL_ONLY)\n            parameters[0] = p\n\n    return cls(parameters, return_annotation=cls.empty)\n\n\ndef _signature_from_builtin(cls, func, skip_bound_arg=True):\n    \"\"\"Private helper function to get signature for\n    builtin callables.\n    \"\"\"\n\n    if not _signature_is_builtin(func):\n        raise TypeError(\"{!r} is not a Python builtin \"\n                        \"function\".format(func))\n\n    s = getattr(func, \"__text_signature__\", None)\n    if not s:\n        raise ValueError(\"no signature found for builtin {!r}\".format(func))\n\n    return _signature_fromstr(cls, func, s, skip_bound_arg)\n\n\ndef _signature_from_function(cls, func, skip_bound_arg=True,\n                             globals=None, locals=None, eval_str=False):\n    \"\"\"Private helper: constructs Signature for the given python function.\"\"\"\n\n    is_duck_function = False\n    if not isfunction(func):\n        if _signature_is_functionlike(func):\n            is_duck_function = True\n        else:\n            # If it's not a pure Python function, and not a duck type\n            # of pure function:\n            raise TypeError('{!r} is not a Python function'.format(func))\n\n    s = getattr(func, \"__text_signature__\", None)\n    if s:\n        return _signature_fromstr(cls, func, s, skip_bound_arg)\n\n    Parameter = cls._parameter_cls\n\n    # Parameter information.\n    func_code = func.__code__\n    pos_count = func_code.co_argcount\n    arg_names = func_code.co_varnames\n    posonly_count = func_code.co_posonlyargcount\n    positional = arg_names[:pos_count]\n    keyword_only_count = func_code.co_kwonlyargcount\n    keyword_only = arg_names[pos_count:pos_count + keyword_only_count]\n    annotations = get_annotations(func, globals=globals, locals=locals, eval_str=eval_str)\n    defaults = func.__defaults__\n    kwdefaults = func.__kwdefaults__\n\n    if defaults:\n        pos_default_count = len(defaults)\n    else:\n        pos_default_count = 0\n\n    parameters = []\n\n    non_default_count = pos_count - pos_default_count\n    posonly_left = posonly_count\n\n    # Non-keyword-only parameters w/o defaults.\n    for name in positional[:non_default_count]:\n        kind = _POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=kind))\n        if posonly_left:\n            posonly_left -= 1\n\n    # ... w/ defaults.\n    for offset, name in enumerate(positional[non_default_count:]):\n        kind = _POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=kind,\n                                    default=defaults[offset]))\n        if posonly_left:\n            posonly_left -= 1\n\n    # *args\n    if func_code.co_flags & CO_VARARGS:\n        name = arg_names[pos_count + keyword_only_count]\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=_VAR_POSITIONAL))\n\n    # Keyword-only parameters.\n    for name in keyword_only:\n        default = _empty\n        if kwdefaults is not None:\n            default = kwdefaults.get(name, _empty)\n\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=_KEYWORD_ONLY,\n                                    default=default))\n    # **kwargs\n    if func_code.co_flags & CO_VARKEYWORDS:\n        index = pos_count + keyword_only_count\n        if func_code.co_flags & CO_VARARGS:\n            index += 1\n\n        name = arg_names[index]\n        annotation = annotations.get(name, _empty)\n        parameters.append(Parameter(name, annotation=annotation,\n                                    kind=_VAR_KEYWORD))\n\n    # Is 'func' is a pure Python function - don't validate the\n    # parameters list (for correct order and defaults), it should be OK.\n    return cls(parameters,\n               return_annotation=annotations.get('return', _empty),\n               __validate_parameters__=is_duck_function)\n\n\ndef _descriptor_get(descriptor, obj):\n    if isclass(descriptor):\n        return descriptor\n    get = getattr(type(descriptor), '__get__', _sentinel)\n    if get is _sentinel:\n        return descriptor\n    return get(descriptor, obj, type(obj))\n\n\ndef _signature_from_callable(obj, *,\n                             follow_wrapper_chains=True,\n                             skip_bound_arg=True,\n                             globals=None,\n                             locals=None,\n                             eval_str=False,\n                             sigcls):\n\n    \"\"\"Private helper function to get signature for arbitrary\n    callable objects.\n    \"\"\"\n\n    _get_signature_of = functools.partial(_signature_from_callable,\n                                follow_wrapper_chains=follow_wrapper_chains,\n                                skip_bound_arg=skip_bound_arg,\n                                globals=globals,\n                                locals=locals,\n                                sigcls=sigcls,\n                                eval_str=eval_str)\n\n    if not callable(obj):\n        raise TypeError('{!r} is not a callable object'.format(obj))\n\n    if isinstance(obj, types.MethodType):\n        # In this case we skip the first parameter of the underlying\n        # function (usually `self` or `cls`).\n        sig = _get_signature_of(obj.__func__)\n\n        if skip_bound_arg:\n            return _signature_bound_method(sig)\n        else:\n            return sig\n\n    # Was this function wrapped by a decorator?\n    if follow_wrapper_chains:\n        # Unwrap until we find an explicit signature or a MethodType (which will be\n        # handled explicitly below).\n        obj = unwrap(obj, stop=(lambda f: hasattr(f, \"__signature__\")\n                                or isinstance(f, types.MethodType)))\n        if isinstance(obj, types.MethodType):\n            # If the unwrapped object is a *method*, we might want to\n            # skip its first parameter (self).\n            # See test_signature_wrapped_bound_method for details.\n            return _get_signature_of(obj)\n\n    try:\n        sig = obj.__signature__\n    except AttributeError:\n        pass\n    else:\n        if sig is not None:\n            if not isinstance(sig, Signature):\n                raise TypeError(\n                    'unexpected object {!r} in __signature__ '\n                    'attribute'.format(sig))\n            return sig\n\n    try:\n        partialmethod = obj._partialmethod\n    except AttributeError:\n        pass\n    else:\n        if isinstance(partialmethod, functools.partialmethod):\n            # Unbound partialmethod (see functools.partialmethod)\n            # This means, that we need to calculate the signature\n            # as if it's a regular partial object, but taking into\n            # account that the first positional argument\n            # (usually `self`, or `cls`) will not be passed\n            # automatically (as for boundmethods)\n\n            wrapped_sig = _get_signature_of(partialmethod.func)\n\n            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))\n            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]\n            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:\n                # First argument of the wrapped callable is `*args`, as in\n                # `partialmethod(lambda *args)`.\n                return sig\n            else:\n                sig_params = tuple(sig.parameters.values())\n                assert (not sig_params or\n                        first_wrapped_param is not sig_params[0])\n                new_params = (first_wrapped_param,) + sig_params\n                return sig.replace(parameters=new_params)\n\n    if isfunction(obj) or _signature_is_functionlike(obj):\n        # If it's a pure Python function, or an object that is duck type\n        # of a Python function (Cython functions, for instance), then:\n        return _signature_from_function(sigcls, obj,\n                                        skip_bound_arg=skip_bound_arg,\n                                        globals=globals, locals=locals, eval_str=eval_str)\n\n    if _signature_is_builtin(obj):\n        return _signature_from_builtin(sigcls, obj,\n                                       skip_bound_arg=skip_bound_arg)\n\n    if isinstance(obj, functools.partial):\n        wrapped_sig = _get_signature_of(obj.func)\n        return _signature_get_partial(wrapped_sig, obj)\n\n    if isinstance(obj, type):\n        # obj is a class or a metaclass\n\n        # First, let's see if it has an overloaded __call__ defined\n        # in its metaclass\n        call = _signature_get_user_defined_method(type(obj), '__call__')\n        if call is not None:\n            return _get_signature_of(call)\n\n        new = _signature_get_user_defined_method(obj, '__new__')\n        init = _signature_get_user_defined_method(obj, '__init__')\n\n        # Go through the MRO and see if any class has user-defined\n        # pure Python __new__ or __init__ method\n        for base in obj.__mro__:\n            # Now we check if the 'obj' class has an own '__new__' method\n            if new is not None and '__new__' in base.__dict__:\n                sig = _get_signature_of(new)\n                if skip_bound_arg:\n                    sig = _signature_bound_method(sig)\n                return sig\n            # or an own '__init__' method\n            elif init is not None and '__init__' in base.__dict__:\n                return _get_signature_of(init)\n\n        # At this point we know, that `obj` is a class, with no user-\n        # defined '__init__', '__new__', or class-level '__call__'\n\n        for base in obj.__mro__[:-1]:\n            # Since '__text_signature__' is implemented as a\n            # descriptor that extracts text signature from the\n            # class docstring, if 'obj' is derived from a builtin\n            # class, its own '__text_signature__' may be 'None'.\n            # Therefore, we go through the MRO (except the last\n            # class in there, which is 'object') to find the first\n            # class with non-empty text signature.\n            try:\n                text_sig = base.__text_signature__\n            except AttributeError:\n                pass\n            else:\n                if text_sig:\n                    # If 'base' class has a __text_signature__ attribute:\n                    # return a signature based on it\n                    return _signature_fromstr(sigcls, base, text_sig)\n\n        # No '__text_signature__' was found for the 'obj' class.\n        # Last option is to check if its '__init__' is\n        # object.__init__ or type.__init__.\n        if type not in obj.__mro__:\n            # We have a class (not metaclass), but no user-defined\n            # __init__ or __new__ for it\n            if (obj.__init__ is object.__init__ and\n                obj.__new__ is object.__new__):\n                # Return a signature of 'object' builtin.\n                return sigcls.from_callable(object)\n            else:\n                raise ValueError(\n                    'no signature found for builtin type {!r}'.format(obj))\n\n    else:\n        # An object with __call__\n        call = getattr_static(type(obj), '__call__', None)\n        if call is not None:\n            call = _descriptor_get(call, obj)\n            return _get_signature_of(call)\n\n    raise ValueError('callable {!r} is not supported by signature'.format(obj))\n\n\nclass _void:\n    \"\"\"A private marker - used in Parameter & Signature.\"\"\"\n\n\nclass _empty:\n    \"\"\"Marker object for Signature.empty and Parameter.empty.\"\"\"\n\n\nclass _ParameterKind(enum.IntEnum):\n    POSITIONAL_ONLY = 'positional-only'\n    POSITIONAL_OR_KEYWORD = 'positional or keyword'\n    VAR_POSITIONAL = 'variadic positional'\n    KEYWORD_ONLY = 'keyword-only'\n    VAR_KEYWORD = 'variadic keyword'\n\n    def __new__(cls, description):\n        value = len(cls.__members__)\n        member = int.__new__(cls, value)\n        member._value_ = value\n        member.description = description\n        return member\n\n    def __str__(self):\n        return self.name\n\n_POSITIONAL_ONLY         = _ParameterKind.POSITIONAL_ONLY\n_POSITIONAL_OR_KEYWORD   = _ParameterKind.POSITIONAL_OR_KEYWORD\n_VAR_POSITIONAL          = _ParameterKind.VAR_POSITIONAL\n_KEYWORD_ONLY            = _ParameterKind.KEYWORD_ONLY\n_VAR_KEYWORD             = _ParameterKind.VAR_KEYWORD\n\n\nclass Parameter:\n    \"\"\"Represents a parameter in a function signature.\n\n    Has the following public attributes:\n\n    * name : str\n        The name of the parameter as a string.\n    * default : object\n        The default value for the parameter if specified.  If the\n        parameter has no default value, this attribute is set to\n        `Parameter.empty`.\n    * annotation\n        The annotation for the parameter if specified.  If the\n        parameter has no annotation, this attribute is set to\n        `Parameter.empty`.\n    * kind : str\n        Describes how argument values are bound to the parameter.\n        Possible values: `Parameter.POSITIONAL_ONLY`,\n        `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,\n        `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.\n    \"\"\"\n\n    __slots__ = ('_name', '_kind', '_default', '_annotation')\n\n    POSITIONAL_ONLY         = _POSITIONAL_ONLY\n    POSITIONAL_OR_KEYWORD   = _POSITIONAL_OR_KEYWORD\n    VAR_POSITIONAL          = _VAR_POSITIONAL\n    KEYWORD_ONLY            = _KEYWORD_ONLY\n    VAR_KEYWORD             = _VAR_KEYWORD\n\n    empty = _empty\n\n    def __init__(self, name, kind, *, default=_empty, annotation=_empty):\n        try:\n            self._kind = _ParameterKind(kind)\n        except ValueError:\n            raise ValueError(f'value {kind!r} is not a valid Parameter.kind')\n        if default is not _empty:\n            if self._kind in (_VAR_POSITIONAL, _VAR_KEYWORD):\n                msg = '{} parameters cannot have default values'\n                msg = msg.format(self._kind.description)\n                raise ValueError(msg)\n        self._default = default\n        self._annotation = annotation\n\n        if name is _empty:\n            raise ValueError('name is a required attribute for Parameter')\n\n        if not isinstance(name, str):\n            msg = 'name must be a str, not a {}'.format(type(name).__name__)\n            raise TypeError(msg)\n\n        if name[0] == '.' and name[1:].isdigit():\n            # These are implicit arguments generated by comprehensions. In\n            # order to provide a friendlier interface to users, we recast\n            # their name as \"implicitN\" and treat them as positional-only.\n            # See issue 19611.\n            if self._kind != _POSITIONAL_OR_KEYWORD:\n                msg = (\n                    'implicit arguments must be passed as '\n                    'positional or keyword arguments, not {}'\n                )\n                msg = msg.format(self._kind.description)\n                raise ValueError(msg)\n            self._kind = _POSITIONAL_ONLY\n            name = 'implicit{}'.format(name[1:])\n\n        # It's possible for C functions to have a positional-only parameter\n        # where the name is a keyword, so for compatibility we'll allow it.\n        is_keyword = iskeyword(name) and self._kind is not _POSITIONAL_ONLY\n        if is_keyword or not name.isidentifier():\n            raise ValueError('{!r} is not a valid parameter name'.format(name))\n\n        self._name = name\n\n    def __reduce__(self):\n        return (type(self),\n                (self._name, self._kind),\n                {'_default': self._default,\n                 '_annotation': self._annotation})\n\n    def __setstate__(self, state):\n        self._default = state['_default']\n        self._annotation = state['_annotation']\n\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def default(self):\n        return self._default\n\n    @property\n    def annotation(self):\n        return self._annotation\n\n    @property\n    def kind(self):\n        return self._kind\n\n    def replace(self, *, name=_void, kind=_void,\n                annotation=_void, default=_void):\n        \"\"\"Creates a customized copy of the Parameter.\"\"\"\n\n        if name is _void:\n            name = self._name\n\n        if kind is _void:\n            kind = self._kind\n\n        if annotation is _void:\n            annotation = self._annotation\n\n        if default is _void:\n            default = self._default\n\n        return type(self)(name, kind, default=default, annotation=annotation)\n\n    def __str__(self):\n        kind = self.kind\n        formatted = self._name\n\n        # Add annotation and default value\n        if self._annotation is not _empty:\n            formatted = '{}: {}'.format(formatted,\n                                       formatannotation(self._annotation))\n\n        if self._default is not _empty:\n            if self._annotation is not _empty:\n                formatted = '{} = {}'.format(formatted, repr(self._default))\n            else:\n                formatted = '{}={}'.format(formatted, repr(self._default))\n\n        if kind == _VAR_POSITIONAL:\n            formatted = '*' + formatted\n        elif kind == _VAR_KEYWORD:\n            formatted = '**' + formatted\n\n        return formatted\n\n    def __repr__(self):\n        return '<{} \"{}\">'.format(self.__class__.__name__, self)\n\n    def __hash__(self):\n        return hash((self.name, self.kind, self.annotation, self.default))\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        if not isinstance(other, Parameter):\n            return NotImplemented\n        return (self._name == other._name and\n                self._kind == other._kind and\n                self._default == other._default and\n                self._annotation == other._annotation)\n\n\nclass BoundArguments:\n    \"\"\"Result of `Signature.bind` call.  Holds the mapping of arguments\n    to the function's parameters.\n\n    Has the following public attributes:\n\n    * arguments : dict\n        An ordered mutable mapping of parameters' names to arguments' values.\n        Does not contain arguments' default values.\n    * signature : Signature\n        The Signature object that created this instance.\n    * args : tuple\n        Tuple of positional arguments values.\n    * kwargs : dict\n        Dict of keyword arguments values.\n    \"\"\"\n\n    __slots__ = ('arguments', '_signature', '__weakref__')\n\n    def __init__(self, signature, arguments):\n        self.arguments = arguments\n        self._signature = signature\n\n    @property\n    def signature(self):\n        return self._signature\n\n    @property\n    def args(self):\n        args = []\n        for param_name, param in self._signature.parameters.items():\n            if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n                break\n\n            try:\n                arg = self.arguments[param_name]\n            except KeyError:\n                # We're done here. Other arguments\n                # will be mapped in 'BoundArguments.kwargs'\n                break\n            else:\n                if param.kind == _VAR_POSITIONAL:\n                    # *args\n                    args.extend(arg)\n                else:\n                    # plain argument\n                    args.append(arg)\n\n        return tuple(args)\n\n    @property\n    def kwargs(self):\n        kwargs = {}\n        kwargs_started = False\n        for param_name, param in self._signature.parameters.items():\n            if not kwargs_started:\n                if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n                    kwargs_started = True\n                else:\n                    if param_name not in self.arguments:\n                        kwargs_started = True\n                        continue\n\n            if not kwargs_started:\n                continue\n\n            try:\n                arg = self.arguments[param_name]\n            except KeyError:\n                pass\n            else:\n                if param.kind == _VAR_KEYWORD:\n                    # **kwargs\n                    kwargs.update(arg)\n                else:\n                    # plain keyword argument\n                    kwargs[param_name] = arg\n\n        return kwargs\n\n    def apply_defaults(self):\n        \"\"\"Set default values for missing arguments.\n\n        For variable-positional arguments (*args) the default is an\n        empty tuple.\n\n        For variable-keyword arguments (**kwargs) the default is an\n        empty dict.\n        \"\"\"\n        arguments = self.arguments\n        new_arguments = []\n        for name, param in self._signature.parameters.items():\n            try:\n                new_arguments.append((name, arguments[name]))\n            except KeyError:\n                if param.default is not _empty:\n                    val = param.default\n                elif param.kind is _VAR_POSITIONAL:\n                    val = ()\n                elif param.kind is _VAR_KEYWORD:\n                    val = {}\n                else:\n                    # This BoundArguments was likely produced by\n                    # Signature.bind_partial().\n                    continue\n                new_arguments.append((name, val))\n        self.arguments = dict(new_arguments)\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        if not isinstance(other, BoundArguments):\n            return NotImplemented\n        return (self.signature == other.signature and\n                self.arguments == other.arguments)\n\n    def __setstate__(self, state):\n        self._signature = state['_signature']\n        self.arguments = state['arguments']\n\n    def __getstate__(self):\n        return {'_signature': self._signature, 'arguments': self.arguments}\n\n    def __repr__(self):\n        args = []\n        for arg, value in self.arguments.items():\n            args.append('{}={!r}'.format(arg, value))\n        return '<{} ({})>'.format(self.__class__.__name__, ', '.join(args))\n\n\nclass Signature:\n    \"\"\"A Signature object represents the overall signature of a function.\n    It stores a Parameter object for each parameter accepted by the\n    function, as well as information specific to the function itself.\n\n    A Signature object has the following public attributes and methods:\n\n    * parameters : OrderedDict\n        An ordered mapping of parameters' names to the corresponding\n        Parameter objects (keyword-only arguments are in the same order\n        as listed in `code.co_varnames`).\n    * return_annotation : object\n        The annotation for the return type of the function if specified.\n        If the function has no annotation for its return type, this\n        attribute is set to `Signature.empty`.\n    * bind(*args, **kwargs) -> BoundArguments\n        Creates a mapping from positional and keyword arguments to\n        parameters.\n    * bind_partial(*args, **kwargs) -> BoundArguments\n        Creates a partial mapping from positional and keyword arguments\n        to parameters (simulating 'functools.partial' behavior.)\n    \"\"\"\n\n    __slots__ = ('_return_annotation', '_parameters')\n\n    _parameter_cls = Parameter\n    _bound_arguments_cls = BoundArguments\n\n    empty = _empty\n\n    def __init__(self, parameters=None, *, return_annotation=_empty,\n                 __validate_parameters__=True):\n        \"\"\"Constructs Signature from the given list of Parameter\n        objects and 'return_annotation'.  All arguments are optional.\n        \"\"\"\n\n        if parameters is None:\n            params = OrderedDict()\n        else:\n            if __validate_parameters__:\n                params = OrderedDict()\n                top_kind = _POSITIONAL_ONLY\n                seen_default = False\n\n                for param in parameters:\n                    kind = param.kind\n                    name = param.name\n\n                    if kind < top_kind:\n                        msg = (\n                            'wrong parameter order: {} parameter before {} '\n                            'parameter'\n                        )\n                        msg = msg.format(top_kind.description,\n                                         kind.description)\n                        raise ValueError(msg)\n                    elif kind > top_kind:\n                        top_kind = kind\n\n                    if kind in (_POSITIONAL_ONLY, _POSITIONAL_OR_KEYWORD):\n                        if param.default is _empty:\n                            if seen_default:\n                                # No default for this parameter, but the\n                                # previous parameter of had a default\n                                msg = 'non-default argument follows default ' \\\n                                      'argument'\n                                raise ValueError(msg)\n                        else:\n                            # There is a default for this parameter.\n                            seen_default = True\n\n                    if name in params:\n                        msg = 'duplicate parameter name: {!r}'.format(name)\n                        raise ValueError(msg)\n\n                    params[name] = param\n            else:\n                params = OrderedDict((param.name, param) for param in parameters)\n\n        self._parameters = types.MappingProxyType(params)\n        self._return_annotation = return_annotation\n\n    @classmethod\n    def from_callable(cls, obj, *,\n                      follow_wrapped=True, globals=None, locals=None, eval_str=False):\n        \"\"\"Constructs Signature for the given callable object.\"\"\"\n        return _signature_from_callable(obj, sigcls=cls,\n                                        follow_wrapper_chains=follow_wrapped,\n                                        globals=globals, locals=locals, eval_str=eval_str)\n\n    @property\n    def parameters(self):\n        return self._parameters\n\n    @property\n    def return_annotation(self):\n        return self._return_annotation\n\n    def replace(self, *, parameters=_void, return_annotation=_void):\n        \"\"\"Creates a customized copy of the Signature.\n        Pass 'parameters' and/or 'return_annotation' arguments\n        to override them in the new copy.\n        \"\"\"\n\n        if parameters is _void:\n            parameters = self.parameters.values()\n\n        if return_annotation is _void:\n            return_annotation = self._return_annotation\n\n        return type(self)(parameters,\n                          return_annotation=return_annotation)\n\n    def _hash_basis(self):\n        params = tuple(param for param in self.parameters.values()\n                             if param.kind != _KEYWORD_ONLY)\n\n        kwo_params = {param.name: param for param in self.parameters.values()\n                                        if param.kind == _KEYWORD_ONLY}\n\n        return params, kwo_params, self.return_annotation\n\n    def __hash__(self):\n        params, kwo_params, return_annotation = self._hash_basis()\n        kwo_params = frozenset(kwo_params.values())\n        return hash((params, kwo_params, return_annotation))\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        if not isinstance(other, Signature):\n            return NotImplemented\n        return self._hash_basis() == other._hash_basis()\n\n    def _bind(self, args, kwargs, *, partial=False):\n        \"\"\"Private method. Don't use directly.\"\"\"\n\n        arguments = {}\n\n        parameters = iter(self.parameters.values())\n        parameters_ex = ()\n        arg_vals = iter(args)\n\n        while True:\n            # Let's iterate through the positional arguments and corresponding\n            # parameters\n            try:\n                arg_val = next(arg_vals)\n            except StopIteration:\n                # No more positional arguments\n                try:\n                    param = next(parameters)\n                except StopIteration:\n                    # No more parameters. That's it. Just need to check that\n                    # we have no `kwargs` after this while loop\n                    break\n                else:\n                    if param.kind == _VAR_POSITIONAL:\n                        # That's OK, just empty *args.  Let's start parsing\n                        # kwargs\n                        break\n                    elif param.name in kwargs:\n                        if param.kind == _POSITIONAL_ONLY:\n                            msg = '{arg!r} parameter is positional only, ' \\\n                                  'but was passed as a keyword'\n                            msg = msg.format(arg=param.name)\n                            raise TypeError(msg) from None\n                        parameters_ex = (param,)\n                        break\n                    elif (param.kind == _VAR_KEYWORD or\n                                                param.default is not _empty):\n                        # That's fine too - we have a default value for this\n                        # parameter.  So, lets start parsing `kwargs`, starting\n                        # with the current parameter\n                        parameters_ex = (param,)\n                        break\n                    else:\n                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,\n                        # not in `kwargs`\n                        if partial:\n                            parameters_ex = (param,)\n                            break\n                        else:\n                            msg = 'missing a required argument: {arg!r}'\n                            msg = msg.format(arg=param.name)\n                            raise TypeError(msg) from None\n            else:\n                # We have a positional argument to process\n                try:\n                    param = next(parameters)\n                except StopIteration:\n                    raise TypeError('too many positional arguments') from None\n                else:\n                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n                        # Looks like we have no parameter for this positional\n                        # argument\n                        raise TypeError(\n                            'too many positional arguments') from None\n\n                    if param.kind == _VAR_POSITIONAL:\n                        # We have an '*args'-like argument, let's fill it with\n                        # all positional arguments we have left and move on to\n                        # the next phase\n                        values = [arg_val]\n                        values.extend(arg_vals)\n                        arguments[param.name] = tuple(values)\n                        break\n\n                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:\n                        raise TypeError(\n                            'multiple values for argument {arg!r}'.format(\n                                arg=param.name)) from None\n\n                    arguments[param.name] = arg_val\n\n        # Now, we iterate through the remaining parameters to process\n        # keyword arguments\n        kwargs_param = None\n        for param in itertools.chain(parameters_ex, parameters):\n            if param.kind == _VAR_KEYWORD:\n                # Memorize that we have a '**kwargs'-like parameter\n                kwargs_param = param\n                continue\n\n            if param.kind == _VAR_POSITIONAL:\n                # Named arguments don't refer to '*args'-like parameters.\n                # We only arrive here if the positional arguments ended\n                # before reaching the last parameter before *args.\n                continue\n\n            param_name = param.name\n            try:\n                arg_val = kwargs.pop(param_name)\n            except KeyError:\n                # We have no value for this parameter.  It's fine though,\n                # if it has a default value, or it is an '*args'-like\n                # parameter, left alone by the processing of positional\n                # arguments.\n                if (not partial and param.kind != _VAR_POSITIONAL and\n                                                    param.default is _empty):\n                    raise TypeError('missing a required argument: {arg!r}'. \\\n                                    format(arg=param_name)) from None\n\n            else:\n                if param.kind == _POSITIONAL_ONLY:\n                    # This should never happen in case of a properly built\n                    # Signature object (but let's have this check here\n                    # to ensure correct behaviour just in case)\n                    raise TypeError('{arg!r} parameter is positional only, '\n                                    'but was passed as a keyword'. \\\n                                    format(arg=param.name))\n\n                arguments[param_name] = arg_val\n\n        if kwargs:\n            if kwargs_param is not None:\n                # Process our '**kwargs'-like parameter\n                arguments[kwargs_param.name] = kwargs\n            else:\n                raise TypeError(\n                    'got an unexpected keyword argument {arg!r}'.format(\n                        arg=next(iter(kwargs))))\n\n        return self._bound_arguments_cls(self, arguments)\n\n    def bind(self, /, *args, **kwargs):\n        \"\"\"Get a BoundArguments object, that maps the passed `args`\n        and `kwargs` to the function's signature.  Raises `TypeError`\n        if the passed arguments can not be bound.\n        \"\"\"\n        return self._bind(args, kwargs)\n\n    def bind_partial(self, /, *args, **kwargs):\n        \"\"\"Get a BoundArguments object, that partially maps the\n        passed `args` and `kwargs` to the function's signature.\n        Raises `TypeError` if the passed arguments can not be bound.\n        \"\"\"\n        return self._bind(args, kwargs, partial=True)\n\n    def __reduce__(self):\n        return (type(self),\n                (tuple(self._parameters.values()),),\n                {'_return_annotation': self._return_annotation})\n\n    def __setstate__(self, state):\n        self._return_annotation = state['_return_annotation']\n\n    def __repr__(self):\n        return '<{} {}>'.format(self.__class__.__name__, self)\n\n    def __str__(self):\n        result = []\n        render_pos_only_separator = False\n        render_kw_only_separator = True\n        for param in self.parameters.values():\n            formatted = str(param)\n\n            kind = param.kind\n\n            if kind == _POSITIONAL_ONLY:\n                render_pos_only_separator = True\n            elif render_pos_only_separator:\n                # It's not a positional-only parameter, and the flag\n                # is set to 'True' (there were pos-only params before.)\n                result.append('/')\n                render_pos_only_separator = False\n\n            if kind == _VAR_POSITIONAL:\n                # OK, we have an '*args'-like parameter, so we won't need\n                # a '*' to separate keyword-only arguments\n                render_kw_only_separator = False\n            elif kind == _KEYWORD_ONLY and render_kw_only_separator:\n                # We have a keyword-only parameter to render and we haven't\n                # rendered an '*args'-like parameter before, so add a '*'\n                # separator to the parameters list (\"foo(arg1, *, arg2)\" case)\n                result.append('*')\n                # This condition should be only triggered once, so\n                # reset the flag\n                render_kw_only_separator = False\n\n            result.append(formatted)\n\n        if render_pos_only_separator:\n            # There were only positional-only parameters, hence the\n            # flag was not reset to 'False'\n            result.append('/')\n\n        rendered = '({})'.format(', '.join(result))\n\n        if self.return_annotation is not _empty:\n            anno = formatannotation(self.return_annotation)\n            rendered += ' -> {}'.format(anno)\n\n        return rendered\n\n\ndef signature(obj, *, follow_wrapped=True, globals=None, locals=None, eval_str=False):\n    \"\"\"Get a signature object for the passed callable.\"\"\"\n    return Signature.from_callable(obj, follow_wrapped=follow_wrapped,\n                                   globals=globals, locals=locals, eval_str=eval_str)\n\n\ndef _main():\n    \"\"\" Logic for inspecting an object given at command line \"\"\"\n    import argparse\n    import importlib\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        'object',\n         help=\"The object to be analysed. \"\n              \"It supports the 'module:qualname' syntax\")\n    parser.add_argument(\n        '-d', '--details', action='store_true',\n        help='Display info about the module rather than its source code')\n\n    args = parser.parse_args()\n\n    target = args.object\n    mod_name, has_attrs, attrs = target.partition(\":\")\n    try:\n        obj = module = importlib.import_module(mod_name)\n    except Exception as exc:\n        msg = \"Failed to import {} ({}: {})\".format(mod_name,\n                                                    type(exc).__name__,\n                                                    exc)\n        print(msg, file=sys.stderr)\n        sys.exit(2)\n\n    if has_attrs:\n        parts = attrs.split(\".\")\n        obj = module\n        for part in parts:\n            obj = getattr(obj, part)\n\n    if module.__name__ in sys.builtin_module_names:\n        print(\"Can't get info for builtin modules.\", file=sys.stderr)\n        sys.exit(1)\n\n    if args.details:\n        print('Target: {}'.format(target))\n        print('Origin: {}'.format(getsourcefile(module)))\n        print('Cached: {}'.format(module.__cached__))\n        if obj is module:\n            print('Loader: {}'.format(repr(module.__loader__)))\n            if hasattr(module, '__path__'):\n                print('Submodule search path: {}'.format(module.__path__))\n        else:\n            try:\n                __, lineno = findsource(obj)\n            except Exception:\n                pass\n            else:\n                print('Line: {}'.format(lineno))\n\n        print('\\n')\n    else:\n        print(getsource(obj))\n\n\nif __name__ == \"__main__\":\n    _main()\n", 3326], "/usr/local/lib/python3.11/functools.py": ["\"\"\"functools.py - Tools for working with functions and callable objects\n\"\"\"\n# Python module wrapper for _functools C module\n# to allow utilities written in Python to be added\n# to the functools module.\n# Written by Nick Coghlan <ncoghlan at gmail.com>,\n# Raymond Hettinger <python at rcn.com>,\n# and \u0141ukasz Langa <lukasz at langa.pl>.\n#   Copyright (C) 2006-2013 Python Software Foundation.\n# See C source code for _functools credits/copyright\n\n__all__ = ['update_wrapper', 'wraps', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES',\n           'total_ordering', 'cache', 'cmp_to_key', 'lru_cache', 'reduce',\n           'partial', 'partialmethod', 'singledispatch', 'singledispatchmethod',\n           'cached_property']\n\nfrom abc import get_cache_token\nfrom collections import namedtuple\n# import types, weakref  # Deferred to single_dispatch()\nfrom reprlib import recursive_repr\nfrom _thread import RLock\nfrom types import GenericAlias\n\n\n################################################################################\n### update_wrapper() and wraps() decorator\n################################################################################\n\n# update_wrapper() and wraps() are tools to help write\n# wrapper functions that can handle naive introspection\n\nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',\n                       '__annotations__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n\n       wrapper is the function to be updated\n       wrapped is the original function\n       assigned is a tuple naming the attributes assigned directly\n       from the wrapped function to the wrapper function (defaults to\n       functools.WRAPPER_ASSIGNMENTS)\n       updated is a tuple naming the attributes of the wrapper that\n       are updated with the corresponding attribute from the wrapped\n       function (defaults to functools.WRAPPER_UPDATES)\n    \"\"\"\n    for attr in assigned:\n        try:\n            value = getattr(wrapped, attr)\n        except AttributeError:\n            pass\n        else:\n            setattr(wrapper, attr, value)\n    for attr in updated:\n        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n    # Issue #17482: set __wrapped__ last so we don't inadvertently copy it\n    # from the wrapped function when updating __dict__\n    wrapper.__wrapped__ = wrapped\n    # Return the wrapper so this can be used as a decorator via partial()\n    return wrapper\n\ndef wraps(wrapped,\n          assigned = WRAPPER_ASSIGNMENTS,\n          updated = WRAPPER_UPDATES):\n    \"\"\"Decorator factory to apply update_wrapper() to a wrapper function\n\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    \"\"\"\n    return partial(update_wrapper, wrapped=wrapped,\n                   assigned=assigned, updated=updated)\n\n\n################################################################################\n### total_ordering class decorator\n################################################################################\n\n# The total ordering functions all invoke the root magic method directly\n# rather than using the corresponding operator.  This avoids possible\n# infinite recursion that could occur when the operator dispatch logic\n# detects a NotImplemented result and then calls a reflected method.\n\ndef _gt_from_lt(self, other):\n    'Return a > b.  Computed by @total_ordering from (not a < b) and (a != b).'\n    op_result = type(self).__lt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result and self != other\n\ndef _le_from_lt(self, other):\n    'Return a <= b.  Computed by @total_ordering from (a < b) or (a == b).'\n    op_result = type(self).__lt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return op_result or self == other\n\ndef _ge_from_lt(self, other):\n    'Return a >= b.  Computed by @total_ordering from (not a < b).'\n    op_result = type(self).__lt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result\n\ndef _ge_from_le(self, other):\n    'Return a >= b.  Computed by @total_ordering from (not a <= b) or (a == b).'\n    op_result = type(self).__le__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result or self == other\n\ndef _lt_from_le(self, other):\n    'Return a < b.  Computed by @total_ordering from (a <= b) and (a != b).'\n    op_result = type(self).__le__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return op_result and self != other\n\ndef _gt_from_le(self, other):\n    'Return a > b.  Computed by @total_ordering from (not a <= b).'\n    op_result = type(self).__le__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result\n\ndef _lt_from_gt(self, other):\n    'Return a < b.  Computed by @total_ordering from (not a > b) and (a != b).'\n    op_result = type(self).__gt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result and self != other\n\ndef _ge_from_gt(self, other):\n    'Return a >= b.  Computed by @total_ordering from (a > b) or (a == b).'\n    op_result = type(self).__gt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return op_result or self == other\n\ndef _le_from_gt(self, other):\n    'Return a <= b.  Computed by @total_ordering from (not a > b).'\n    op_result = type(self).__gt__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result\n\ndef _le_from_ge(self, other):\n    'Return a <= b.  Computed by @total_ordering from (not a >= b) or (a == b).'\n    op_result = type(self).__ge__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result or self == other\n\ndef _gt_from_ge(self, other):\n    'Return a > b.  Computed by @total_ordering from (a >= b) and (a != b).'\n    op_result = type(self).__ge__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return op_result and self != other\n\ndef _lt_from_ge(self, other):\n    'Return a < b.  Computed by @total_ordering from (not a >= b).'\n    op_result = type(self).__ge__(self, other)\n    if op_result is NotImplemented:\n        return op_result\n    return not op_result\n\n_convert = {\n    '__lt__': [('__gt__', _gt_from_lt),\n               ('__le__', _le_from_lt),\n               ('__ge__', _ge_from_lt)],\n    '__le__': [('__ge__', _ge_from_le),\n               ('__lt__', _lt_from_le),\n               ('__gt__', _gt_from_le)],\n    '__gt__': [('__lt__', _lt_from_gt),\n               ('__ge__', _ge_from_gt),\n               ('__le__', _le_from_gt)],\n    '__ge__': [('__le__', _le_from_ge),\n               ('__gt__', _gt_from_ge),\n               ('__lt__', _lt_from_ge)]\n}\n\ndef total_ordering(cls):\n    \"\"\"Class decorator that fills in missing ordering methods\"\"\"\n    # Find user-defined comparisons (not those inherited from object).\n    roots = {op for op in _convert if getattr(cls, op, None) is not getattr(object, op, None)}\n    if not roots:\n        raise ValueError('must define at least one ordering operation: < > <= >=')\n    root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__\n    for opname, opfunc in _convert[root]:\n        if opname not in roots:\n            opfunc.__name__ = opname\n            setattr(cls, opname, opfunc)\n    return cls\n\n\n################################################################################\n### cmp_to_key() function converter\n################################################################################\n\ndef cmp_to_key(mycmp):\n    \"\"\"Convert a cmp= function into a key= function\"\"\"\n    class K(object):\n        __slots__ = ['obj']\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) < 0\n        def __gt__(self, other):\n            return mycmp(self.obj, other.obj) > 0\n        def __eq__(self, other):\n            return mycmp(self.obj, other.obj) == 0\n        def __le__(self, other):\n            return mycmp(self.obj, other.obj) <= 0\n        def __ge__(self, other):\n            return mycmp(self.obj, other.obj) >= 0\n        __hash__ = None\n    return K\n\ntry:\n    from _functools import cmp_to_key\nexcept ImportError:\n    pass\n\n\n################################################################################\n### reduce() sequence to a single item\n################################################################################\n\n_initial_missing = object()\n\ndef reduce(function, sequence, initial=_initial_missing):\n    \"\"\"\n    reduce(function, iterable[, initial]) -> value\n\n    Apply a function of two arguments cumulatively to the items of a sequence\n    or iterable, from left to right, so as to reduce the iterable to a single\n    value.  For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the iterable in the calculation, and serves as a default when the\n    iterable is empty.\n    \"\"\"\n\n    it = iter(sequence)\n\n    if initial is _initial_missing:\n        try:\n            value = next(it)\n        except StopIteration:\n            raise TypeError(\n                \"reduce() of empty iterable with no initial value\") from None\n    else:\n        value = initial\n\n    for element in it:\n        value = function(value, element)\n\n    return value\n\ntry:\n    from _functools import reduce\nexcept ImportError:\n    pass\n\n\n################################################################################\n### partial() argument application\n################################################################################\n\n# Purely functional, no descriptor behaviour\nclass partial:\n    \"\"\"New function with partial application of the given arguments\n    and keywords.\n    \"\"\"\n\n    __slots__ = \"func\", \"args\", \"keywords\", \"__dict__\", \"__weakref__\"\n\n    def __new__(cls, func, /, *args, **keywords):\n        if not callable(func):\n            raise TypeError(\"the first argument must be callable\")\n\n        if hasattr(func, \"func\"):\n            args = func.args + args\n            keywords = {**func.keywords, **keywords}\n            func = func.func\n\n        self = super(partial, cls).__new__(cls)\n\n        self.func = func\n        self.args = args\n        self.keywords = keywords\n        return self\n\n    def __call__(self, /, *args, **keywords):\n        keywords = {**self.keywords, **keywords}\n        return self.func(*self.args, *args, **keywords)\n\n    @recursive_repr()\n    def __repr__(self):\n        qualname = type(self).__qualname__\n        args = [repr(self.func)]\n        args.extend(repr(x) for x in self.args)\n        args.extend(f\"{k}={v!r}\" for (k, v) in self.keywords.items())\n        if type(self).__module__ == \"functools\":\n            return f\"functools.{qualname}({', '.join(args)})\"\n        return f\"{qualname}({', '.join(args)})\"\n\n    def __reduce__(self):\n        return type(self), (self.func,), (self.func, self.args,\n               self.keywords or None, self.__dict__ or None)\n\n    def __setstate__(self, state):\n        if not isinstance(state, tuple):\n            raise TypeError(\"argument to __setstate__ must be a tuple\")\n        if len(state) != 4:\n            raise TypeError(f\"expected 4 items in state, got {len(state)}\")\n        func, args, kwds, namespace = state\n        if (not callable(func) or not isinstance(args, tuple) or\n           (kwds is not None and not isinstance(kwds, dict)) or\n           (namespace is not None and not isinstance(namespace, dict))):\n            raise TypeError(\"invalid partial state\")\n\n        args = tuple(args) # just in case it's a subclass\n        if kwds is None:\n            kwds = {}\n        elif type(kwds) is not dict: # XXX does it need to be *exactly* dict?\n            kwds = dict(kwds)\n        if namespace is None:\n            namespace = {}\n\n        self.__dict__ = namespace\n        self.func = func\n        self.args = args\n        self.keywords = kwds\n\ntry:\n    from _functools import partial\nexcept ImportError:\n    pass\n\n# Descriptor version\nclass partialmethod(object):\n    \"\"\"Method descriptor with partial application of the given arguments\n    and keywords.\n\n    Supports wrapping existing descriptors and handles non-descriptor\n    callables as instance methods.\n    \"\"\"\n\n    def __init__(self, func, /, *args, **keywords):\n        if not callable(func) and not hasattr(func, \"__get__\"):\n            raise TypeError(\"{!r} is not callable or a descriptor\"\n                                 .format(func))\n\n        # func could be a descriptor like classmethod which isn't callable,\n        # so we can't inherit from partial (it verifies func is callable)\n        if isinstance(func, partialmethod):\n            # flattening is mandatory in order to place cls/self before all\n            # other arguments\n            # it's also more efficient since only one function will be called\n            self.func = func.func\n            self.args = func.args + args\n            self.keywords = {**func.keywords, **keywords}\n        else:\n            self.func = func\n            self.args = args\n            self.keywords = keywords\n\n    def __repr__(self):\n        args = \", \".join(map(repr, self.args))\n        keywords = \", \".join(\"{}={!r}\".format(k, v)\n                                 for k, v in self.keywords.items())\n        format_string = \"{module}.{cls}({func}, {args}, {keywords})\"\n        return format_string.format(module=self.__class__.__module__,\n                                    cls=self.__class__.__qualname__,\n                                    func=self.func,\n                                    args=args,\n                                    keywords=keywords)\n\n    def _make_unbound_method(self):\n        def _method(cls_or_self, /, *args, **keywords):\n            keywords = {**self.keywords, **keywords}\n            return self.func(cls_or_self, *self.args, *args, **keywords)\n        _method.__isabstractmethod__ = self.__isabstractmethod__\n        _method._partialmethod = self\n        return _method\n\n    def __get__(self, obj, cls=None):\n        get = getattr(self.func, \"__get__\", None)\n        result = None\n        if get is not None:\n            new_func = get(obj, cls)\n            if new_func is not self.func:\n                # Assume __get__ returning something new indicates the\n                # creation of an appropriate callable\n                result = partial(new_func, *self.args, **self.keywords)\n                try:\n                    result.__self__ = new_func.__self__\n                except AttributeError:\n                    pass\n        if result is None:\n            # If the underlying descriptor didn't do anything, treat this\n            # like an instance method\n            result = self._make_unbound_method().__get__(obj, cls)\n        return result\n\n    @property\n    def __isabstractmethod__(self):\n        return getattr(self.func, \"__isabstractmethod__\", False)\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\n# Helper functions\n\ndef _unwrap_partial(func):\n    while isinstance(func, partial):\n        func = func.func\n    return func\n\n################################################################################\n### LRU Cache function decorator\n################################################################################\n\n_CacheInfo = namedtuple(\"CacheInfo\", [\"hits\", \"misses\", \"maxsize\", \"currsize\"])\n\nclass _HashedSeq(list):\n    \"\"\" This class guarantees that hash() will be called no more than once\n        per element.  This is important because the lru_cache() will hash\n        the key multiple times on a cache miss.\n\n    \"\"\"\n\n    __slots__ = 'hashvalue'\n\n    def __init__(self, tup, hash=hash):\n        self[:] = tup\n        self.hashvalue = hash(tup)\n\n    def __hash__(self):\n        return self.hashvalue\n\ndef _make_key(args, kwds, typed,\n             kwd_mark = (object(),),\n             fasttypes = {int, str},\n             tuple=tuple, type=type, len=len):\n    \"\"\"Make a cache key from optionally typed positional and keyword arguments\n\n    The key is constructed in a way that is flat as possible rather than\n    as a nested structure that would take more memory.\n\n    If there is only a single argument and its data type is known to cache\n    its hash value, then that argument is returned without a wrapper.  This\n    saves space and improves lookup speed.\n\n    \"\"\"\n    # All of code below relies on kwds preserving the order input by the user.\n    # Formerly, we sorted() the kwds before looping.  The new way is *much*\n    # faster; however, it means that f(x=1, y=2) will now be treated as a\n    # distinct call from f(y=2, x=1) which will be cached separately.\n    key = args\n    if kwds:\n        key += kwd_mark\n        for item in kwds.items():\n            key += item\n    if typed:\n        key += tuple(type(v) for v in args)\n        if kwds:\n            key += tuple(type(v) for v in kwds.values())\n    elif len(key) == 1 and type(key[0]) in fasttypes:\n        return key[0]\n    return _HashedSeq(key)\n\ndef lru_cache(maxsize=128, typed=False):\n    \"\"\"Least-recently-used cache decorator.\n\n    If *maxsize* is set to None, the LRU features are disabled and the cache\n    can grow without bound.\n\n    If *typed* is True, arguments of different types will be cached separately.\n    For example, f(3.0) and f(3) will be treated as distinct calls with\n    distinct results.\n\n    Arguments to the cached function must be hashable.\n\n    View the cache statistics named tuple (hits, misses, maxsize, currsize)\n    with f.cache_info().  Clear the cache and statistics with f.cache_clear().\n    Access the underlying function with f.__wrapped__.\n\n    See:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)\n\n    \"\"\"\n\n    # Users should only access the lru_cache through its public API:\n    #       cache_info, cache_clear, and f.__wrapped__\n    # The internals of the lru_cache are encapsulated for thread safety and\n    # to allow the implementation to change (including a possible C version).\n\n    if isinstance(maxsize, int):\n        # Negative maxsize is treated as 0\n        if maxsize < 0:\n            maxsize = 0\n    elif callable(maxsize) and isinstance(typed, bool):\n        # The user_function was passed in directly via the maxsize argument\n        user_function, maxsize = maxsize, 128\n        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)\n        wrapper.cache_parameters = lambda : {'maxsize': maxsize, 'typed': typed}\n        return update_wrapper(wrapper, user_function)\n    elif maxsize is not None:\n        raise TypeError(\n            'Expected first argument to be an integer, a callable, or None')\n\n    def decorating_function(user_function):\n        wrapper = _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo)\n        wrapper.cache_parameters = lambda : {'maxsize': maxsize, 'typed': typed}\n        return update_wrapper(wrapper, user_function)\n\n    return decorating_function\n\ndef _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):\n    # Constants shared by all lru cache instances:\n    sentinel = object()          # unique object used to signal cache misses\n    make_key = _make_key         # build a key from the function arguments\n    PREV, NEXT, KEY, RESULT = 0, 1, 2, 3   # names for the link fields\n\n    cache = {}\n    hits = misses = 0\n    full = False\n    cache_get = cache.get    # bound method to lookup a key or return None\n    cache_len = cache.__len__  # get cache size without calling len()\n    lock = RLock()           # because linkedlist updates aren't threadsafe\n    root = []                # root of the circular doubly linked list\n    root[:] = [root, root, None, None]     # initialize by pointing to self\n\n    if maxsize == 0:\n\n        def wrapper(*args, **kwds):\n            # No caching -- just a statistics update\n            nonlocal misses\n            misses += 1\n            result = user_function(*args, **kwds)\n            return result\n\n    elif maxsize is None:\n\n        def wrapper(*args, **kwds):\n            # Simple caching without ordering or size limit\n            nonlocal hits, misses\n            key = make_key(args, kwds, typed)\n            result = cache_get(key, sentinel)\n            if result is not sentinel:\n                hits += 1\n                return result\n            misses += 1\n            result = user_function(*args, **kwds)\n            cache[key] = result\n            return result\n\n    else:\n\n        def wrapper(*args, **kwds):\n            # Size limited caching that tracks accesses by recency\n            nonlocal root, hits, misses, full\n            key = make_key(args, kwds, typed)\n            with lock:\n                link = cache_get(key)\n                if link is not None:\n                    # Move the link to the front of the circular queue\n                    link_prev, link_next, _key, result = link\n                    link_prev[NEXT] = link_next\n                    link_next[PREV] = link_prev\n                    last = root[PREV]\n                    last[NEXT] = root[PREV] = link\n                    link[PREV] = last\n                    link[NEXT] = root\n                    hits += 1\n                    return result\n                misses += 1\n            result = user_function(*args, **kwds)\n            with lock:\n                if key in cache:\n                    # Getting here means that this same key was added to the\n                    # cache while the lock was released.  Since the link\n                    # update is already done, we need only return the\n                    # computed result and update the count of misses.\n                    pass\n                elif full:\n                    # Use the old root to store the new key and result.\n                    oldroot = root\n                    oldroot[KEY] = key\n                    oldroot[RESULT] = result\n                    # Empty the oldest link and make it the new root.\n                    # Keep a reference to the old key and old result to\n                    # prevent their ref counts from going to zero during the\n                    # update. That will prevent potentially arbitrary object\n                    # clean-up code (i.e. __del__) from running while we're\n                    # still adjusting the links.\n                    root = oldroot[NEXT]\n                    oldkey = root[KEY]\n                    oldresult = root[RESULT]\n                    root[KEY] = root[RESULT] = None\n                    # Now update the cache dictionary.\n                    del cache[oldkey]\n                    # Save the potentially reentrant cache[key] assignment\n                    # for last, after the root and links have been put in\n                    # a consistent state.\n                    cache[key] = oldroot\n                else:\n                    # Put result in a new link at the front of the queue.\n                    last = root[PREV]\n                    link = [last, root, key, result]\n                    last[NEXT] = root[PREV] = cache[key] = link\n                    # Use the cache_len bound method instead of the len() function\n                    # which could potentially be wrapped in an lru_cache itself.\n                    full = (cache_len() >= maxsize)\n            return result\n\n    def cache_info():\n        \"\"\"Report cache statistics\"\"\"\n        with lock:\n            return _CacheInfo(hits, misses, maxsize, cache_len())\n\n    def cache_clear():\n        \"\"\"Clear the cache and cache statistics\"\"\"\n        nonlocal hits, misses, full\n        with lock:\n            cache.clear()\n            root[:] = [root, root, None, None]\n            hits = misses = 0\n            full = False\n\n    wrapper.cache_info = cache_info\n    wrapper.cache_clear = cache_clear\n    return wrapper\n\ntry:\n    from _functools import _lru_cache_wrapper\nexcept ImportError:\n    pass\n\n\n################################################################################\n### cache -- simplified access to the infinity cache\n################################################################################\n\ndef cache(user_function, /):\n    'Simple lightweight unbounded cache.  Sometimes called \"memoize\".'\n    return lru_cache(maxsize=None)(user_function)\n\n\n################################################################################\n### singledispatch() - single-dispatch generic function decorator\n################################################################################\n\ndef _c3_merge(sequences):\n    \"\"\"Merges MROs in *sequences* to a single MRO using the C3 algorithm.\n\n    Adapted from https://www.python.org/download/releases/2.3/mro/.\n\n    \"\"\"\n    result = []\n    while True:\n        sequences = [s for s in sequences if s]   # purge empty sequences\n        if not sequences:\n            return result\n        for s1 in sequences:   # find merge candidates among seq heads\n            candidate = s1[0]\n            for s2 in sequences:\n                if candidate in s2[1:]:\n                    candidate = None\n                    break      # reject the current head, it appears later\n            else:\n                break\n        if candidate is None:\n            raise RuntimeError(\"Inconsistent hierarchy\")\n        result.append(candidate)\n        # remove the chosen candidate\n        for seq in sequences:\n            if seq[0] == candidate:\n                del seq[0]\n\ndef _c3_mro(cls, abcs=None):\n    \"\"\"Computes the method resolution order using extended C3 linearization.\n\n    If no *abcs* are given, the algorithm works exactly like the built-in C3\n    linearization used for method resolution.\n\n    If given, *abcs* is a list of abstract base classes that should be inserted\n    into the resulting MRO. Unrelated ABCs are ignored and don't end up in the\n    result. The algorithm inserts ABCs where their functionality is introduced,\n    i.e. issubclass(cls, abc) returns True for the class itself but returns\n    False for all its direct base classes. Implicit ABCs for a given class\n    (either registered or inferred from the presence of a special method like\n    __len__) are inserted directly after the last ABC explicitly listed in the\n    MRO of said class. If two implicit ABCs end up next to each other in the\n    resulting MRO, their ordering depends on the order of types in *abcs*.\n\n    \"\"\"\n    for i, base in enumerate(reversed(cls.__bases__)):\n        if hasattr(base, '__abstractmethods__'):\n            boundary = len(cls.__bases__) - i\n            break   # Bases up to the last explicit ABC are considered first.\n    else:\n        boundary = 0\n    abcs = list(abcs) if abcs else []\n    explicit_bases = list(cls.__bases__[:boundary])\n    abstract_bases = []\n    other_bases = list(cls.__bases__[boundary:])\n    for base in abcs:\n        if issubclass(cls, base) and not any(\n                issubclass(b, base) for b in cls.__bases__\n            ):\n            # If *cls* is the class that introduces behaviour described by\n            # an ABC *base*, insert said ABC to its MRO.\n            abstract_bases.append(base)\n    for base in abstract_bases:\n        abcs.remove(base)\n    explicit_c3_mros = [_c3_mro(base, abcs=abcs) for base in explicit_bases]\n    abstract_c3_mros = [_c3_mro(base, abcs=abcs) for base in abstract_bases]\n    other_c3_mros = [_c3_mro(base, abcs=abcs) for base in other_bases]\n    return _c3_merge(\n        [[cls]] +\n        explicit_c3_mros + abstract_c3_mros + other_c3_mros +\n        [explicit_bases] + [abstract_bases] + [other_bases]\n    )\n\ndef _compose_mro(cls, types):\n    \"\"\"Calculates the method resolution order for a given class *cls*.\n\n    Includes relevant abstract base classes (with their respective bases) from\n    the *types* iterable. Uses a modified C3 linearization algorithm.\n\n    \"\"\"\n    bases = set(cls.__mro__)\n    # Remove entries which are already present in the __mro__ or unrelated.\n    def is_related(typ):\n        return (typ not in bases and hasattr(typ, '__mro__')\n                                 and not isinstance(typ, GenericAlias)\n                                 and issubclass(cls, typ))\n    types = [n for n in types if is_related(n)]\n    # Remove entries which are strict bases of other entries (they will end up\n    # in the MRO anyway.\n    def is_strict_base(typ):\n        for other in types:\n            if typ != other and typ in other.__mro__:\n                return True\n        return False\n    types = [n for n in types if not is_strict_base(n)]\n    # Subclasses of the ABCs in *types* which are also implemented by\n    # *cls* can be used to stabilize ABC ordering.\n    type_set = set(types)\n    mro = []\n    for typ in types:\n        found = []\n        for sub in typ.__subclasses__():\n            if sub not in bases and issubclass(cls, sub):\n                found.append([s for s in sub.__mro__ if s in type_set])\n        if not found:\n            mro.append(typ)\n            continue\n        # Favor subclasses with the biggest number of useful bases\n        found.sort(key=len, reverse=True)\n        for sub in found:\n            for subcls in sub:\n                if subcls not in mro:\n                    mro.append(subcls)\n    return _c3_mro(cls, abcs=mro)\n\ndef _find_impl(cls, registry):\n    \"\"\"Returns the best matching implementation from *registry* for type *cls*.\n\n    Where there is no registered implementation for a specific type, its method\n    resolution order is used to find a more generic implementation.\n\n    Note: if *registry* does not contain an implementation for the base\n    *object* type, this function may return None.\n\n    \"\"\"\n    mro = _compose_mro(cls, registry.keys())\n    match = None\n    for t in mro:\n        if match is not None:\n            # If *match* is an implicit ABC but there is another unrelated,\n            # equally matching implicit ABC, refuse the temptation to guess.\n            if (t in registry and t not in cls.__mro__\n                              and match not in cls.__mro__\n                              and not issubclass(match, t)):\n                raise RuntimeError(\"Ambiguous dispatch: {} or {}\".format(\n                    match, t))\n            break\n        if t in registry:\n            match = t\n    return registry.get(match)\n\ndef singledispatch(func):\n    \"\"\"Single-dispatch generic function decorator.\n\n    Transforms a function into a generic function, which can have different\n    behaviours depending upon the type of its first argument. The decorated\n    function acts as the default implementation, and additional\n    implementations can be registered using the register() attribute of the\n    generic function.\n    \"\"\"\n    # There are many programs that use functools without singledispatch, so we\n    # trade-off making singledispatch marginally slower for the benefit of\n    # making start-up of such applications slightly faster.\n    import types, weakref\n\n    registry = {}\n    dispatch_cache = weakref.WeakKeyDictionary()\n    cache_token = None\n\n    def dispatch(cls):\n        \"\"\"generic_func.dispatch(cls) -> <function implementation>\n\n        Runs the dispatch algorithm to return the best available implementation\n        for the given *cls* registered on *generic_func*.\n\n        \"\"\"\n        nonlocal cache_token\n        if cache_token is not None:\n            current_token = get_cache_token()\n            if cache_token != current_token:\n                dispatch_cache.clear()\n                cache_token = current_token\n        try:\n            impl = dispatch_cache[cls]\n        except KeyError:\n            try:\n                impl = registry[cls]\n            except KeyError:\n                impl = _find_impl(cls, registry)\n            dispatch_cache[cls] = impl\n        return impl\n\n    def _is_union_type(cls):\n        from typing import get_origin, Union\n        return get_origin(cls) in {Union, types.UnionType}\n\n    def _is_valid_dispatch_type(cls):\n        if isinstance(cls, type):\n            return True\n        from typing import get_args\n        return (_is_union_type(cls) and\n                all(isinstance(arg, type) for arg in get_args(cls)))\n\n    def register(cls, func=None):\n        \"\"\"generic_func.register(cls, func) -> func\n\n        Registers a new implementation for the given *cls* on a *generic_func*.\n\n        \"\"\"\n        nonlocal cache_token\n        if _is_valid_dispatch_type(cls):\n            if func is None:\n                return lambda f: register(cls, f)\n        else:\n            if func is not None:\n                raise TypeError(\n                    f\"Invalid first argument to `register()`. \"\n                    f\"{cls!r} is not a class or union type.\"\n                )\n            ann = getattr(cls, '__annotations__', {})\n            if not ann:\n                raise TypeError(\n                    f\"Invalid first argument to `register()`: {cls!r}. \"\n                    f\"Use either `@register(some_class)` or plain `@register` \"\n                    f\"on an annotated function.\"\n                )\n            func = cls\n\n            # only import typing if annotation parsing is necessary\n            from typing import get_type_hints\n            argname, cls = next(iter(get_type_hints(func).items()))\n            if not _is_valid_dispatch_type(cls):\n                if _is_union_type(cls):\n                    raise TypeError(\n                        f\"Invalid annotation for {argname!r}. \"\n                        f\"{cls!r} not all arguments are classes.\"\n                    )\n                else:\n                    raise TypeError(\n                        f\"Invalid annotation for {argname!r}. \"\n                        f\"{cls!r} is not a class.\"\n                    )\n\n        if _is_union_type(cls):\n            from typing import get_args\n\n            for arg in get_args(cls):\n                registry[arg] = func\n        else:\n            registry[cls] = func\n        if cache_token is None and hasattr(cls, '__abstractmethods__'):\n            cache_token = get_cache_token()\n        dispatch_cache.clear()\n        return func\n\n    def wrapper(*args, **kw):\n        if not args:\n            raise TypeError(f'{funcname} requires at least '\n                            '1 positional argument')\n\n        return dispatch(args[0].__class__)(*args, **kw)\n\n    funcname = getattr(func, '__name__', 'singledispatch function')\n    registry[object] = func\n    wrapper.register = register\n    wrapper.dispatch = dispatch\n    wrapper.registry = types.MappingProxyType(registry)\n    wrapper._clear_cache = dispatch_cache.clear\n    update_wrapper(wrapper, func)\n    return wrapper\n\n\n# Descriptor version\nclass singledispatchmethod:\n    \"\"\"Single-dispatch generic method descriptor.\n\n    Supports wrapping existing descriptors and handles non-descriptor\n    callables as instance methods.\n    \"\"\"\n\n    def __init__(self, func):\n        if not callable(func) and not hasattr(func, \"__get__\"):\n            raise TypeError(f\"{func!r} is not callable or a descriptor\")\n\n        self.dispatcher = singledispatch(func)\n        self.func = func\n\n    def register(self, cls, method=None):\n        \"\"\"generic_method.register(cls, func) -> func\n\n        Registers a new implementation for the given *cls* on a *generic_method*.\n        \"\"\"\n        return self.dispatcher.register(cls, func=method)\n\n    def __get__(self, obj, cls=None):\n        def _method(*args, **kwargs):\n            method = self.dispatcher.dispatch(args[0].__class__)\n            return method.__get__(obj, cls)(*args, **kwargs)\n\n        _method.__isabstractmethod__ = self.__isabstractmethod__\n        _method.register = self.register\n        update_wrapper(_method, self.func)\n        return _method\n\n    @property\n    def __isabstractmethod__(self):\n        return getattr(self.func, '__isabstractmethod__', False)\n\n\n################################################################################\n### cached_property() - computed once per instance, cached as attribute\n################################################################################\n\n_NOT_FOUND = object()\n\n\nclass cached_property:\n    def __init__(self, func):\n        self.func = func\n        self.attrname = None\n        self.__doc__ = func.__doc__\n        self.lock = RLock()\n\n    def __set_name__(self, owner, name):\n        if self.attrname is None:\n            self.attrname = name\n        elif name != self.attrname:\n            raise TypeError(\n                \"Cannot assign the same cached_property to two different names \"\n                f\"({self.attrname!r} and {name!r}).\"\n            )\n\n    def __get__(self, instance, owner=None):\n        if instance is None:\n            return self\n        if self.attrname is None:\n            raise TypeError(\n                \"Cannot use cached_property instance without calling __set_name__ on it.\")\n        try:\n            cache = instance.__dict__\n        except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)\n            msg = (\n                f\"No '__dict__' attribute on {type(instance).__name__!r} \"\n                f\"instance to cache {self.attrname!r} property.\"\n            )\n            raise TypeError(msg) from None\n        val = cache.get(self.attrname, _NOT_FOUND)\n        if val is _NOT_FOUND:\n            with self.lock:\n                # check if another thread filled cache while we awaited lock\n                val = cache.get(self.attrname, _NOT_FOUND)\n                if val is _NOT_FOUND:\n                    val = self.func(instance)\n                    try:\n                        cache[self.attrname] = val\n                    except TypeError:\n                        msg = (\n                            f\"The '__dict__' attribute on {type(instance).__name__!r} instance \"\n                            f\"does not support item assignment for caching {self.attrname!r} property.\"\n                        )\n                        raise TypeError(msg) from None\n        return val\n\n    __class_getitem__ = classmethod(GenericAlias)\n", 1012], "/usr/local/lib/python3.11/threading.py": ["\"\"\"Thread module emulating a subset of Java's threading model.\"\"\"\n\nimport os as _os\nimport sys as _sys\nimport _thread\nimport functools\n\nfrom time import monotonic as _time\nfrom _weakrefset import WeakSet\nfrom itertools import islice as _islice, count as _count\ntry:\n    from _collections import deque as _deque\nexcept ImportError:\n    from collections import deque as _deque\n\n# Note regarding PEP 8 compliant names\n#  This threading model was originally inspired by Java, and inherited\n# the convention of camelCase function and method names from that\n# language. Those original names are not in any imminent danger of\n# being deprecated (even for Py3k),so this module provides them as an\n# alias for the PEP 8 compliant names\n# Note that using the new PEP 8 compliant names facilitates substitution\n# with the multiprocessing module, which doesn't provide the old\n# Java inspired names.\n\n__all__ = ['get_ident', 'active_count', 'Condition', 'current_thread',\n           'enumerate', 'main_thread', 'TIMEOUT_MAX',\n           'Event', 'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',\n           'Barrier', 'BrokenBarrierError', 'Timer', 'ThreadError',\n           'setprofile', 'settrace', 'local', 'stack_size',\n           'excepthook', 'ExceptHookArgs', 'gettrace', 'getprofile']\n\n# Rename some stuff so \"from threading import *\" is safe\n_start_new_thread = _thread.start_new_thread\n_allocate_lock = _thread.allocate_lock\n_set_sentinel = _thread._set_sentinel\nget_ident = _thread.get_ident\ntry:\n    get_native_id = _thread.get_native_id\n    _HAVE_THREAD_NATIVE_ID = True\n    __all__.append('get_native_id')\nexcept AttributeError:\n    _HAVE_THREAD_NATIVE_ID = False\nThreadError = _thread.error\ntry:\n    _CRLock = _thread.RLock\nexcept AttributeError:\n    _CRLock = None\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\ndel _thread\n\n\n# Support for profile and trace hooks\n\n_profile_hook = None\n_trace_hook = None\n\ndef setprofile(func):\n    \"\"\"Set a profile function for all threads started from the threading module.\n\n    The func will be passed to sys.setprofile() for each thread, before its\n    run() method is called.\n\n    \"\"\"\n    global _profile_hook\n    _profile_hook = func\n\ndef getprofile():\n    \"\"\"Get the profiler function as set by threading.setprofile().\"\"\"\n    return _profile_hook\n\ndef settrace(func):\n    \"\"\"Set a trace function for all threads started from the threading module.\n\n    The func will be passed to sys.settrace() for each thread, before its run()\n    method is called.\n\n    \"\"\"\n    global _trace_hook\n    _trace_hook = func\n\ndef gettrace():\n    \"\"\"Get the trace function as set by threading.settrace().\"\"\"\n    return _trace_hook\n\n# Synchronization classes\n\nLock = _allocate_lock\n\ndef RLock(*args, **kwargs):\n    \"\"\"Factory function that returns a new reentrant lock.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it again\n    without blocking; the thread must release it once for each time it has\n    acquired it.\n\n    \"\"\"\n    if _CRLock is None:\n        return _PyRLock(*args, **kwargs)\n    return _CRLock(*args, **kwargs)\n\nclass _RLock:\n    \"\"\"This class implements reentrant lock objects.\n\n    A reentrant lock must be released by the thread that acquired it. Once a\n    thread has acquired a reentrant lock, the same thread may acquire it\n    again without blocking; the thread must release it once for each time it\n    has acquired it.\n\n    \"\"\"\n\n    def __init__(self):\n        self._block = _allocate_lock()\n        self._owner = None\n        self._count = 0\n\n    def __repr__(self):\n        owner = self._owner\n        try:\n            owner = _active[owner].name\n        except KeyError:\n            pass\n        return \"<%s %s.%s object owner=%r count=%d at %s>\" % (\n            \"locked\" if self._block.locked() else \"unlocked\",\n            self.__class__.__module__,\n            self.__class__.__qualname__,\n            owner,\n            self._count,\n            hex(id(self))\n        )\n\n    def _at_fork_reinit(self):\n        self._block._at_fork_reinit()\n        self._owner = None\n        self._count = 0\n\n    def acquire(self, blocking=True, timeout=-1):\n        \"\"\"Acquire a lock, blocking or non-blocking.\n\n        When invoked without arguments: if this thread already owns the lock,\n        increment the recursion level by one, and return immediately. Otherwise,\n        if another thread owns the lock, block until the lock is unlocked. Once\n        the lock is unlocked (not owned by any thread), then grab ownership, set\n        the recursion level to one, and return. If more than one thread is\n        blocked waiting until the lock is unlocked, only one at a time will be\n        able to grab ownership of the lock. There is no return value in this\n        case.\n\n        When invoked with the blocking argument set to true, do the same thing\n        as when called without arguments, and return true.\n\n        When invoked with the blocking argument set to false, do not block. If a\n        call without an argument would block, return false immediately;\n        otherwise, do the same thing as when called without arguments, and\n        return true.\n\n        When invoked with the floating-point timeout argument set to a positive\n        value, block for at most the number of seconds specified by timeout\n        and as long as the lock cannot be acquired.  Return true if the lock has\n        been acquired, false if the timeout has elapsed.\n\n        \"\"\"\n        me = get_ident()\n        if self._owner == me:\n            self._count += 1\n            return 1\n        rc = self._block.acquire(blocking, timeout)\n        if rc:\n            self._owner = me\n            self._count = 1\n        return rc\n\n    __enter__ = acquire\n\n    def release(self):\n        \"\"\"Release a lock, decrementing the recursion level.\n\n        If after the decrement it is zero, reset the lock to unlocked (not owned\n        by any thread), and if any other threads are blocked waiting for the\n        lock to become unlocked, allow exactly one of them to proceed. If after\n        the decrement the recursion level is still nonzero, the lock remains\n        locked and owned by the calling thread.\n\n        Only call this method when the calling thread owns the lock. A\n        RuntimeError is raised if this method is called when the lock is\n        unlocked.\n\n        There is no return value.\n\n        \"\"\"\n        if self._owner != get_ident():\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        self._count = count = self._count - 1\n        if not count:\n            self._owner = None\n            self._block.release()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n    # Internal methods used by condition variables\n\n    def _acquire_restore(self, state):\n        self._block.acquire()\n        self._count, self._owner = state\n\n    def _release_save(self):\n        if self._count == 0:\n            raise RuntimeError(\"cannot release un-acquired lock\")\n        count = self._count\n        self._count = 0\n        owner = self._owner\n        self._owner = None\n        self._block.release()\n        return (count, owner)\n\n    def _is_owned(self):\n        return self._owner == get_ident()\n\n    # Internal method used for reentrancy checks\n\n    def _recursion_count(self):\n        if self._owner != get_ident():\n            return 0\n        return self._count\n\n_PyRLock = _RLock\n\n\nclass Condition:\n    \"\"\"Class that implements a condition variable.\n\n    A condition variable allows one or more threads to wait until they are\n    notified by another thread.\n\n    If the lock argument is given and not None, it must be a Lock or RLock\n    object, and it is used as the underlying lock. Otherwise, a new RLock object\n    is created and used as the underlying lock.\n\n    \"\"\"\n\n    def __init__(self, lock=None):\n        if lock is None:\n            lock = RLock()\n        self._lock = lock\n        # Export the lock's acquire() and release() methods\n        self.acquire = lock.acquire\n        self.release = lock.release\n        # If the lock defines _release_save() and/or _acquire_restore(),\n        # these override the default implementations (which just call\n        # release() and acquire() on the lock).  Ditto for _is_owned().\n        try:\n            self._release_save = lock._release_save\n        except AttributeError:\n            pass\n        try:\n            self._acquire_restore = lock._acquire_restore\n        except AttributeError:\n            pass\n        try:\n            self._is_owned = lock._is_owned\n        except AttributeError:\n            pass\n        self._waiters = _deque()\n\n    def _at_fork_reinit(self):\n        self._lock._at_fork_reinit()\n        self._waiters.clear()\n\n    def __enter__(self):\n        return self._lock.__enter__()\n\n    def __exit__(self, *args):\n        return self._lock.__exit__(*args)\n\n    def __repr__(self):\n        return \"<Condition(%s, %d)>\" % (self._lock, len(self._waiters))\n\n    def _release_save(self):\n        self._lock.release()           # No state to save\n\n    def _acquire_restore(self, x):\n        self._lock.acquire()           # Ignore saved state\n\n    def _is_owned(self):\n        # Return True if lock is owned by current_thread.\n        # This method is called only if _lock doesn't have _is_owned().\n        if self._lock.acquire(False):\n            self._lock.release()\n            return False\n        else:\n            return True\n\n    def wait(self, timeout=None):\n        \"\"\"Wait until notified or until a timeout occurs.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method releases the underlying lock, and then blocks until it is\n        awakened by a notify() or notify_all() call for the same condition\n        variable in another thread, or until the optional timeout occurs. Once\n        awakened or timed out, it re-acquires the lock and returns.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        When the underlying lock is an RLock, it is not released using its\n        release() method, since this may not actually unlock the lock when it\n        was acquired multiple times recursively. Instead, an internal interface\n        of the RLock class is used, which really unlocks it even when it has\n        been recursively acquired several times. Another internal interface is\n        then used to restore the recursion level when the lock is reacquired.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot wait on un-acquired lock\")\n        waiter = _allocate_lock()\n        waiter.acquire()\n        self._waiters.append(waiter)\n        saved_state = self._release_save()\n        gotit = False\n        try:    # restore state no matter what (e.g., KeyboardInterrupt)\n            if timeout is None:\n                waiter.acquire()\n                gotit = True\n            else:\n                if timeout > 0:\n                    gotit = waiter.acquire(True, timeout)\n                else:\n                    gotit = waiter.acquire(False)\n            return gotit\n        finally:\n            self._acquire_restore(saved_state)\n            if not gotit:\n                try:\n                    self._waiters.remove(waiter)\n                except ValueError:\n                    pass\n\n    def wait_for(self, predicate, timeout=None):\n        \"\"\"Wait until a condition evaluates to True.\n\n        predicate should be a callable which result will be interpreted as a\n        boolean value.  A timeout may be provided giving the maximum time to\n        wait.\n\n        \"\"\"\n        endtime = None\n        waittime = timeout\n        result = predicate()\n        while not result:\n            if waittime is not None:\n                if endtime is None:\n                    endtime = _time() + waittime\n                else:\n                    waittime = endtime - _time()\n                    if waittime <= 0:\n                        break\n            self.wait(waittime)\n            result = predicate()\n        return result\n\n    def notify(self, n=1):\n        \"\"\"Wake up one or more threads waiting on this condition, if any.\n\n        If the calling thread has not acquired the lock when this method is\n        called, a RuntimeError is raised.\n\n        This method wakes up at most n of the threads waiting for the condition\n        variable; it is a no-op if no threads are waiting.\n\n        \"\"\"\n        if not self._is_owned():\n            raise RuntimeError(\"cannot notify on un-acquired lock\")\n        waiters = self._waiters\n        while waiters and n > 0:\n            waiter = waiters[0]\n            try:\n                waiter.release()\n            except RuntimeError:\n                # gh-92530: The previous call of notify() released the lock,\n                # but was interrupted before removing it from the queue.\n                # It can happen if a signal handler raises an exception,\n                # like CTRL+C which raises KeyboardInterrupt.\n                pass\n            else:\n                n -= 1\n            try:\n                waiters.remove(waiter)\n            except ValueError:\n                pass\n\n    def notify_all(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        If the calling thread has not acquired the lock when this method\n        is called, a RuntimeError is raised.\n\n        \"\"\"\n        self.notify(len(self._waiters))\n\n    def notifyAll(self):\n        \"\"\"Wake up all threads waiting on this condition.\n\n        This method is deprecated, use notify_all() instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('notifyAll() is deprecated, use notify_all() instead',\n                      DeprecationWarning, stacklevel=2)\n        self.notify_all()\n\n\nclass Semaphore:\n    \"\"\"This class implements semaphore objects.\n\n    Semaphores manage a counter representing the number of release() calls minus\n    the number of acquire() calls, plus an initial value. The acquire() method\n    blocks if necessary until it can return without making the counter\n    negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    # After Tim Peters' semaphore class, but not quite the same (no maximum)\n\n    def __init__(self, value=1):\n        if value < 0:\n            raise ValueError(\"semaphore initial value must be >= 0\")\n        self._cond = Condition(Lock())\n        self._value = value\n\n    def __repr__(self):\n        cls = self.__class__\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" value={self._value}>\")\n\n    def acquire(self, blocking=True, timeout=None):\n        \"\"\"Acquire a semaphore, decrementing the internal counter by one.\n\n        When invoked without arguments: if the internal counter is larger than\n        zero on entry, decrement it by one and return immediately. If it is zero\n        on entry, block, waiting until some other thread has called release() to\n        make it larger than zero. This is done with proper interlocking so that\n        if multiple acquire() calls are blocked, release() will wake exactly one\n        of them up. The implementation may pick one at random, so the order in\n        which blocked threads are awakened should not be relied on. There is no\n        return value in this case.\n\n        When invoked with blocking set to true, do the same thing as when called\n        without arguments, and return true.\n\n        When invoked with blocking set to false, do not block. If a call without\n        an argument would block, return false immediately; otherwise, do the\n        same thing as when called without arguments, and return true.\n\n        When invoked with a timeout other than None, it will block for at\n        most timeout seconds.  If acquire does not complete successfully in\n        that interval, return false.  Return true otherwise.\n\n        \"\"\"\n        if not blocking and timeout is not None:\n            raise ValueError(\"can't specify timeout for non-blocking acquire\")\n        rc = False\n        endtime = None\n        with self._cond:\n            while self._value == 0:\n                if not blocking:\n                    break\n                if timeout is not None:\n                    if endtime is None:\n                        endtime = _time() + timeout\n                    else:\n                        timeout = endtime - _time()\n                        if timeout <= 0:\n                            break\n                self._cond.wait(timeout)\n            else:\n                self._value -= 1\n                rc = True\n        return rc\n\n    __enter__ = acquire\n\n    def release(self, n=1):\n        \"\"\"Release a semaphore, incrementing the internal counter by one or more.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        \"\"\"\n        if n < 1:\n            raise ValueError('n must be one or more')\n        with self._cond:\n            self._value += n\n            for i in range(n):\n                self._cond.notify()\n\n    def __exit__(self, t, v, tb):\n        self.release()\n\n\nclass BoundedSemaphore(Semaphore):\n    \"\"\"Implements a bounded semaphore.\n\n    A bounded semaphore checks to make sure its current value doesn't exceed its\n    initial value. If it does, ValueError is raised. In most situations\n    semaphores are used to guard resources with limited capacity.\n\n    If the semaphore is released too many times it's a sign of a bug. If not\n    given, value defaults to 1.\n\n    Like regular semaphores, bounded semaphores manage a counter representing\n    the number of release() calls minus the number of acquire() calls, plus an\n    initial value. The acquire() method blocks if necessary until it can return\n    without making the counter negative. If not given, value defaults to 1.\n\n    \"\"\"\n\n    def __init__(self, value=1):\n        Semaphore.__init__(self, value)\n        self._initial_value = value\n\n    def __repr__(self):\n        cls = self.__class__\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" value={self._value}/{self._initial_value}>\")\n\n    def release(self, n=1):\n        \"\"\"Release a semaphore, incrementing the internal counter by one or more.\n\n        When the counter is zero on entry and another thread is waiting for it\n        to become larger than zero again, wake up that thread.\n\n        If the number of releases exceeds the number of acquires,\n        raise a ValueError.\n\n        \"\"\"\n        if n < 1:\n            raise ValueError('n must be one or more')\n        with self._cond:\n            if self._value + n > self._initial_value:\n                raise ValueError(\"Semaphore released too many times\")\n            self._value += n\n            for i in range(n):\n                self._cond.notify()\n\n\nclass Event:\n    \"\"\"Class implementing event objects.\n\n    Events manage a flag that can be set to true with the set() method and reset\n    to false with the clear() method. The wait() method blocks until the flag is\n    true.  The flag is initially false.\n\n    \"\"\"\n\n    # After Tim Peters' event class (without is_posted())\n\n    def __init__(self):\n        self._cond = Condition(Lock())\n        self._flag = False\n\n    def __repr__(self):\n        cls = self.__class__\n        status = 'set' if self._flag else 'unset'\n        return f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}: {status}>\"\n\n    def _at_fork_reinit(self):\n        # Private method called by Thread._reset_internal_locks()\n        self._cond._at_fork_reinit()\n\n    def is_set(self):\n        \"\"\"Return true if and only if the internal flag is true.\"\"\"\n        return self._flag\n\n    def isSet(self):\n        \"\"\"Return true if and only if the internal flag is true.\n\n        This method is deprecated, use is_set() instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('isSet() is deprecated, use is_set() instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.is_set()\n\n    def set(self):\n        \"\"\"Set the internal flag to true.\n\n        All threads waiting for it to become true are awakened. Threads\n        that call wait() once the flag is true will not block at all.\n\n        \"\"\"\n        with self._cond:\n            self._flag = True\n            self._cond.notify_all()\n\n    def clear(self):\n        \"\"\"Reset the internal flag to false.\n\n        Subsequently, threads calling wait() will block until set() is called to\n        set the internal flag to true again.\n\n        \"\"\"\n        with self._cond:\n            self._flag = False\n\n    def wait(self, timeout=None):\n        \"\"\"Block until the internal flag is true.\n\n        If the internal flag is true on entry, return immediately. Otherwise,\n        block until another thread calls set() to set the flag to true, or until\n        the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof).\n\n        This method returns the internal flag on exit, so it will always return\n        True except if a timeout is given and the operation times out.\n\n        \"\"\"\n        with self._cond:\n            signaled = self._flag\n            if not signaled:\n                signaled = self._cond.wait(timeout)\n            return signaled\n\n\n# A barrier class.  Inspired in part by the pthread_barrier_* api and\n# the CyclicBarrier class from Java.  See\n# http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and\n# http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/\n#        CyclicBarrier.html\n# for information.\n# We maintain two main states, 'filling' and 'draining' enabling the barrier\n# to be cyclic.  Threads are not allowed into it until it has fully drained\n# since the previous cycle.  In addition, a 'resetting' state exists which is\n# similar to 'draining' except that threads leave with a BrokenBarrierError,\n# and a 'broken' state in which all threads get the exception.\nclass Barrier:\n    \"\"\"Implements a Barrier.\n\n    Useful for synchronizing a fixed number of threads at known synchronization\n    points.  Threads block on 'wait()' and are simultaneously awoken once they\n    have all made that call.\n\n    \"\"\"\n\n    def __init__(self, parties, action=None, timeout=None):\n        \"\"\"Create a barrier, initialised to 'parties' threads.\n\n        'action' is a callable which, when supplied, will be called by one of\n        the threads after they have all entered the barrier and just prior to\n        releasing them all. If a 'timeout' is provided, it is used as the\n        default for all subsequent 'wait()' calls.\n\n        \"\"\"\n        self._cond = Condition(Lock())\n        self._action = action\n        self._timeout = timeout\n        self._parties = parties\n        self._state = 0  # 0 filling, 1 draining, -1 resetting, -2 broken\n        self._count = 0\n\n    def __repr__(self):\n        cls = self.__class__\n        if self.broken:\n            return f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}: broken>\"\n        return (f\"<{cls.__module__}.{cls.__qualname__} at {id(self):#x}:\"\n                f\" waiters={self.n_waiting}/{self.parties}>\")\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for the barrier.\n\n        When the specified number of threads have started waiting, they are all\n        simultaneously awoken. If an 'action' was provided for the barrier, one\n        of the threads will have executed that callback prior to returning.\n        Returns an individual index number from 0 to 'parties-1'.\n\n        \"\"\"\n        if timeout is None:\n            timeout = self._timeout\n        with self._cond:\n            self._enter() # Block while the barrier drains.\n            index = self._count\n            self._count += 1\n            try:\n                if index + 1 == self._parties:\n                    # We release the barrier\n                    self._release()\n                else:\n                    # We wait until someone releases us\n                    self._wait(timeout)\n                return index\n            finally:\n                self._count -= 1\n                # Wake up any threads waiting for barrier to drain.\n                self._exit()\n\n    # Block until the barrier is ready for us, or raise an exception\n    # if it is broken.\n    def _enter(self):\n        while self._state in (-1, 1):\n            # It is draining or resetting, wait until done\n            self._cond.wait()\n        #see if the barrier is in a broken state\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 0\n\n    # Optionally run the 'action' and release the threads waiting\n    # in the barrier.\n    def _release(self):\n        try:\n            if self._action:\n                self._action()\n            # enter draining state\n            self._state = 1\n            self._cond.notify_all()\n        except:\n            #an exception during the _action handler.  Break and reraise\n            self._break()\n            raise\n\n    # Wait in the barrier until we are released.  Raise an exception\n    # if the barrier is reset or broken.\n    def _wait(self, timeout):\n        if not self._cond.wait_for(lambda : self._state != 0, timeout):\n            #timed out.  Break the barrier\n            self._break()\n            raise BrokenBarrierError\n        if self._state < 0:\n            raise BrokenBarrierError\n        assert self._state == 1\n\n    # If we are the last thread to exit the barrier, signal any threads\n    # waiting for the barrier to drain.\n    def _exit(self):\n        if self._count == 0:\n            if self._state in (-1, 1):\n                #resetting or draining\n                self._state = 0\n                self._cond.notify_all()\n\n    def reset(self):\n        \"\"\"Reset the barrier to the initial state.\n\n        Any threads currently waiting will get the BrokenBarrier exception\n        raised.\n\n        \"\"\"\n        with self._cond:\n            if self._count > 0:\n                if self._state == 0:\n                    #reset the barrier, waking up threads\n                    self._state = -1\n                elif self._state == -2:\n                    #was broken, set it to reset state\n                    #which clears when the last thread exits\n                    self._state = -1\n            else:\n                self._state = 0\n            self._cond.notify_all()\n\n    def abort(self):\n        \"\"\"Place the barrier into a 'broken' state.\n\n        Useful in case of error.  Any currently waiting threads and threads\n        attempting to 'wait()' will have BrokenBarrierError raised.\n\n        \"\"\"\n        with self._cond:\n            self._break()\n\n    def _break(self):\n        # An internal error was detected.  The barrier is set to\n        # a broken state all parties awakened.\n        self._state = -2\n        self._cond.notify_all()\n\n    @property\n    def parties(self):\n        \"\"\"Return the number of threads required to trip the barrier.\"\"\"\n        return self._parties\n\n    @property\n    def n_waiting(self):\n        \"\"\"Return the number of threads currently waiting at the barrier.\"\"\"\n        # We don't need synchronization here since this is an ephemeral result\n        # anyway.  It returns the correct value in the steady state.\n        if self._state == 0:\n            return self._count\n        return 0\n\n    @property\n    def broken(self):\n        \"\"\"Return True if the barrier is in a broken state.\"\"\"\n        return self._state == -2\n\n# exception raised by the Barrier class\nclass BrokenBarrierError(RuntimeError):\n    pass\n\n\n# Helper to generate new thread names\n_counter = _count(1).__next__\ndef _newname(name_template):\n    return name_template % _counter()\n\n# Active thread administration.\n#\n# bpo-44422: Use a reentrant lock to allow reentrant calls to functions like\n# threading.enumerate().\n_active_limbo_lock = RLock()\n_active = {}    # maps thread id to Thread object\n_limbo = {}\n_dangling = WeakSet()\n\n# Set of Thread._tstate_lock locks of non-daemon threads used by _shutdown()\n# to wait until all Python thread states get deleted:\n# see Thread._set_tstate_lock().\n_shutdown_locks_lock = _allocate_lock()\n_shutdown_locks = set()\n\ndef _maintain_shutdown_locks():\n    \"\"\"\n    Drop any shutdown locks that don't correspond to running threads anymore.\n\n    Calling this from time to time avoids an ever-growing _shutdown_locks\n    set when Thread objects are not joined explicitly. See bpo-37788.\n\n    This must be called with _shutdown_locks_lock acquired.\n    \"\"\"\n    # If a lock was released, the corresponding thread has exited\n    to_remove = [lock for lock in _shutdown_locks if not lock.locked()]\n    _shutdown_locks.difference_update(to_remove)\n\n\n# Main class for threads\n\nclass Thread:\n    \"\"\"A class that represents a thread of control.\n\n    This class can be safely subclassed in a limited fashion. There are two ways\n    to specify the activity: by passing a callable object to the constructor, or\n    by overriding the run() method in a subclass.\n\n    \"\"\"\n\n    _initialized = False\n\n    def __init__(self, group=None, target=None, name=None,\n                 args=(), kwargs=None, *, daemon=None):\n        \"\"\"This constructor should always be called with keyword arguments. Arguments are:\n\n        *group* should be None; reserved for future extension when a ThreadGroup\n        class is implemented.\n\n        *target* is the callable object to be invoked by the run()\n        method. Defaults to None, meaning nothing is called.\n\n        *name* is the thread name. By default, a unique name is constructed of\n        the form \"Thread-N\" where N is a small decimal number.\n\n        *args* is a list or tuple of arguments for the target invocation. Defaults to ().\n\n        *kwargs* is a dictionary of keyword arguments for the target\n        invocation. Defaults to {}.\n\n        If a subclass overrides the constructor, it must make sure to invoke\n        the base class constructor (Thread.__init__()) before doing anything\n        else to the thread.\n\n        \"\"\"\n        assert group is None, \"group argument must be None for now\"\n        if kwargs is None:\n            kwargs = {}\n        if name:\n            name = str(name)\n        else:\n            name = _newname(\"Thread-%d\")\n            if target is not None:\n                try:\n                    target_name = target.__name__\n                    name += f\" ({target_name})\"\n                except AttributeError:\n                    pass\n\n        self._target = target\n        self._name = name\n        self._args = args\n        self._kwargs = kwargs\n        if daemon is not None:\n            self._daemonic = daemon\n        else:\n            self._daemonic = current_thread().daemon\n        self._ident = None\n        if _HAVE_THREAD_NATIVE_ID:\n            self._native_id = None\n        self._tstate_lock = None\n        self._started = Event()\n        self._is_stopped = False\n        self._initialized = True\n        # Copy of sys.stderr used by self._invoke_excepthook()\n        self._stderr = _sys.stderr\n        self._invoke_excepthook = _make_invoke_excepthook()\n        # For debugging and _after_fork()\n        _dangling.add(self)\n\n    def _reset_internal_locks(self, is_alive):\n        # private!  Called by _after_fork() to reset our internal locks as\n        # they may be in an invalid state leading to a deadlock or crash.\n        self._started._at_fork_reinit()\n        if is_alive:\n            # bpo-42350: If the fork happens when the thread is already stopped\n            # (ex: after threading._shutdown() has been called), _tstate_lock\n            # is None. Do nothing in this case.\n            if self._tstate_lock is not None:\n                self._tstate_lock._at_fork_reinit()\n                self._tstate_lock.acquire()\n        else:\n            # The thread isn't alive after fork: it doesn't have a tstate\n            # anymore.\n            self._is_stopped = True\n            self._tstate_lock = None\n\n    def __repr__(self):\n        assert self._initialized, \"Thread.__init__() was not called\"\n        status = \"initial\"\n        if self._started.is_set():\n            status = \"started\"\n        self.is_alive() # easy way to get ._is_stopped set when appropriate\n        if self._is_stopped:\n            status = \"stopped\"\n        if self._daemonic:\n            status += \" daemon\"\n        if self._ident is not None:\n            status += \" %s\" % self._ident\n        return \"<%s(%s, %s)>\" % (self.__class__.__name__, self._name, status)\n\n    def start(self):\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n        same thread object.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n            raise RuntimeError(\"threads can only be started once\")\n\n        with _active_limbo_lock:\n            _limbo[self] = self\n        try:\n            _start_new_thread(self._bootstrap, ())\n        except Exception:\n            with _active_limbo_lock:\n                del _limbo[self]\n            raise\n        self._started.wait()\n\n    def run(self):\n        \"\"\"Method representing the thread's activity.\n\n        You may override this method in a subclass. The standard run() method\n        invokes the callable object passed to the object's constructor as the\n        target argument, if any, with sequential and keyword arguments taken\n        from the args and kwargs arguments, respectively.\n\n        \"\"\"\n        try:\n            if self._target is not None:\n                self._target(*self._args, **self._kwargs)\n        finally:\n            # Avoid a refcycle if the thread is running a function with\n            # an argument that has a member that points to the thread.\n            del self._target, self._args, self._kwargs\n\n    def _bootstrap(self):\n        # Wrapper around the real bootstrap code that ignores\n        # exceptions during interpreter cleanup.  Those typically\n        # happen when a daemon thread wakes up at an unfortunate\n        # moment, finds the world around it destroyed, and raises some\n        # random exception *** while trying to report the exception in\n        # _bootstrap_inner() below ***.  Those random exceptions\n        # don't help anybody, and they confuse users, so we suppress\n        # them.  We suppress them only when it appears that the world\n        # indeed has already been destroyed, so that exceptions in\n        # _bootstrap_inner() during normal business hours are properly\n        # reported.  Also, we only suppress them for daemonic threads;\n        # if a non-daemonic encounters this, something else is wrong.\n        try:\n            self._bootstrap_inner()\n        except:\n            if self._daemonic and _sys is None:\n                return\n            raise\n\n    def _set_ident(self):\n        self._ident = get_ident()\n\n    if _HAVE_THREAD_NATIVE_ID:\n        def _set_native_id(self):\n            self._native_id = get_native_id()\n\n    def _set_tstate_lock(self):\n        \"\"\"\n        Set a lock object which will be released by the interpreter when\n        the underlying thread state (see pystate.h) gets deleted.\n        \"\"\"\n        self._tstate_lock = _set_sentinel()\n        self._tstate_lock.acquire()\n\n        if not self.daemon:\n            with _shutdown_locks_lock:\n                _maintain_shutdown_locks()\n                _shutdown_locks.add(self._tstate_lock)\n\n    def _bootstrap_inner(self):\n        try:\n            self._set_ident()\n            self._set_tstate_lock()\n            if _HAVE_THREAD_NATIVE_ID:\n                self._set_native_id()\n            self._started.set()\n            with _active_limbo_lock:\n                _active[self._ident] = self\n                del _limbo[self]\n\n            if _trace_hook:\n                _sys.settrace(_trace_hook)\n            if _profile_hook:\n                _sys.setprofile(_profile_hook)\n\n            try:\n                self.run()\n            except:\n                self._invoke_excepthook(self)\n        finally:\n            self._delete()\n\n    def _stop(self):\n        # After calling ._stop(), .is_alive() returns False and .join() returns\n        # immediately.  ._tstate_lock must be released before calling ._stop().\n        #\n        # Normal case:  C code at the end of the thread's life\n        # (release_sentinel in _threadmodule.c) releases ._tstate_lock, and\n        # that's detected by our ._wait_for_tstate_lock(), called by .join()\n        # and .is_alive().  Any number of threads _may_ call ._stop()\n        # simultaneously (for example, if multiple threads are blocked in\n        # .join() calls), and they're not serialized.  That's harmless -\n        # they'll just make redundant rebindings of ._is_stopped and\n        # ._tstate_lock.  Obscure:  we rebind ._tstate_lock last so that the\n        # \"assert self._is_stopped\" in ._wait_for_tstate_lock() always works\n        # (the assert is executed only if ._tstate_lock is None).\n        #\n        # Special case:  _main_thread releases ._tstate_lock via this\n        # module's _shutdown() function.\n        lock = self._tstate_lock\n        if lock is not None:\n            assert not lock.locked()\n        self._is_stopped = True\n        self._tstate_lock = None\n        if not self.daemon:\n            with _shutdown_locks_lock:\n                # Remove our lock and other released locks from _shutdown_locks\n                _maintain_shutdown_locks()\n\n    def _delete(self):\n        \"Remove current thread from the dict of currently running threads.\"\n        with _active_limbo_lock:\n            del _active[get_ident()]\n            # There must not be any python code between the previous line\n            # and after the lock is released.  Otherwise a tracing function\n            # could try to acquire the lock again in the same thread, (in\n            # current_thread()), and would block.\n\n    def join(self, timeout=None):\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n        called terminates -- either normally or through an unhandled exception\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n        floating point number specifying a timeout for the operation in seconds\n        (or fractions thereof). As join() always returns None, you must call\n        is_alive() after join() to decide whether a timeout happened -- if the\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n        thread as that would cause a deadlock. It is also an error to join() a\n        thread before it has been started and attempts to do so raises the same\n        exception.\n\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if not self._started.is_set():\n            raise RuntimeError(\"cannot join thread before it is started\")\n        if self is current_thread():\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n            self._wait_for_tstate_lock()\n        else:\n            # the behavior of a negative timeout isn't documented, but\n            # historically .join(timeout=x) for x<0 has acted as if timeout=0\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n\n    def _wait_for_tstate_lock(self, block=True, timeout=-1):\n        # Issue #18808: wait for the thread state to be gone.\n        # At the end of the thread's life, after all knowledge of the thread\n        # is removed from C data structures, C code releases our _tstate_lock.\n        # This method passes its arguments to _tstate_lock.acquire().\n        # If the lock is acquired, the C code is done, and self._stop() is\n        # called.  That sets ._is_stopped to True, and ._tstate_lock to None.\n        lock = self._tstate_lock\n        if lock is None:\n            # already determined that the C code is done\n            assert self._is_stopped\n            return\n\n        try:\n            if lock.acquire(block, timeout):\n                lock.release()\n                self._stop()\n        except:\n            if lock.locked():\n                # bpo-45274: lock.acquire() acquired the lock, but the function\n                # was interrupted with an exception before reaching the\n                # lock.release(). It can happen if a signal handler raises an\n                # exception, like CTRL+C which raises KeyboardInterrupt.\n                lock.release()\n                self._stop()\n            raise\n\n    @property\n    def name(self):\n        \"\"\"A string used for identification purposes only.\n\n        It has no semantics. Multiple threads may be given the same name. The\n        initial name is set by the constructor.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        assert self._initialized, \"Thread.__init__() not called\"\n        self._name = str(name)\n\n    @property\n    def ident(self):\n        \"\"\"Thread identifier of this thread or None if it has not been started.\n\n        This is a nonzero integer. See the get_ident() function. Thread\n        identifiers may be recycled when a thread exits and another thread is\n        created. The identifier is available even after the thread has exited.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._ident\n\n    if _HAVE_THREAD_NATIVE_ID:\n        @property\n        def native_id(self):\n            \"\"\"Native integral thread ID of this thread, or None if it has not been started.\n\n            This is a non-negative integer. See the get_native_id() function.\n            This represents the Thread ID as reported by the kernel.\n\n            \"\"\"\n            assert self._initialized, \"Thread.__init__() not called\"\n            return self._native_id\n\n    def is_alive(self):\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n        after the run() method terminates. See also the module function\n        enumerate().\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        if self._is_stopped or not self._started.is_set():\n            return False\n        self._wait_for_tstate_lock(False)\n        return not self._is_stopped\n\n    @property\n    def daemon(self):\n        \"\"\"A boolean value indicating whether this thread is a daemon thread.\n\n        This must be set before start() is called, otherwise RuntimeError is\n        raised. Its initial value is inherited from the creating thread; the\n        main thread is not a daemon thread and therefore all threads created in\n        the main thread default to daemon = False.\n\n        The entire Python program exits when only daemon threads are left.\n\n        \"\"\"\n        assert self._initialized, \"Thread.__init__() not called\"\n        return self._daemonic\n\n    @daemon.setter\n    def daemon(self, daemonic):\n        if not self._initialized:\n            raise RuntimeError(\"Thread.__init__() not called\")\n        if self._started.is_set():\n            raise RuntimeError(\"cannot set daemon status of active thread\")\n        self._daemonic = daemonic\n\n    def isDaemon(self):\n        \"\"\"Return whether this thread is a daemon.\n\n        This method is deprecated, use the daemon attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('isDaemon() is deprecated, get the daemon attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.daemon\n\n    def setDaemon(self, daemonic):\n        \"\"\"Set whether this thread is a daemon.\n\n        This method is deprecated, use the .daemon property instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('setDaemon() is deprecated, set the daemon attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        self.daemon = daemonic\n\n    def getName(self):\n        \"\"\"Return a string used for identification purposes only.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('getName() is deprecated, get the name attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        return self.name\n\n    def setName(self, name):\n        \"\"\"Set the name string for this thread.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n        import warnings\n        warnings.warn('setName() is deprecated, set the name attribute instead',\n                      DeprecationWarning, stacklevel=2)\n        self.name = name\n\n\ntry:\n    from _thread import (_excepthook as excepthook,\n                         _ExceptHookArgs as ExceptHookArgs)\nexcept ImportError:\n    # Simple Python implementation if _thread._excepthook() is not available\n    from traceback import print_exception as _print_exception\n    from collections import namedtuple\n\n    _ExceptHookArgs = namedtuple(\n        'ExceptHookArgs',\n        'exc_type exc_value exc_traceback thread')\n\n    def ExceptHookArgs(args):\n        return _ExceptHookArgs(*args)\n\n    def excepthook(args, /):\n        \"\"\"\n        Handle uncaught Thread.run() exception.\n        \"\"\"\n        if args.exc_type == SystemExit:\n            # silently ignore SystemExit\n            return\n\n        if _sys is not None and _sys.stderr is not None:\n            stderr = _sys.stderr\n        elif args.thread is not None:\n            stderr = args.thread._stderr\n            if stderr is None:\n                # do nothing if sys.stderr is None and sys.stderr was None\n                # when the thread was created\n                return\n        else:\n            # do nothing if sys.stderr is None and args.thread is None\n            return\n\n        if args.thread is not None:\n            name = args.thread.name\n        else:\n            name = get_ident()\n        print(f\"Exception in thread {name}:\",\n              file=stderr, flush=True)\n        _print_exception(args.exc_type, args.exc_value, args.exc_traceback,\n                         file=stderr)\n        stderr.flush()\n\n\n# Original value of threading.excepthook\n__excepthook__ = excepthook\n\n\ndef _make_invoke_excepthook():\n    # Create a local namespace to ensure that variables remain alive\n    # when _invoke_excepthook() is called, even if it is called late during\n    # Python shutdown. It is mostly needed for daemon threads.\n\n    old_excepthook = excepthook\n    old_sys_excepthook = _sys.excepthook\n    if old_excepthook is None:\n        raise RuntimeError(\"threading.excepthook is None\")\n    if old_sys_excepthook is None:\n        raise RuntimeError(\"sys.excepthook is None\")\n\n    sys_exc_info = _sys.exc_info\n    local_print = print\n    local_sys = _sys\n\n    def invoke_excepthook(thread):\n        global excepthook\n        try:\n            hook = excepthook\n            if hook is None:\n                hook = old_excepthook\n\n            args = ExceptHookArgs([*sys_exc_info(), thread])\n\n            hook(args)\n        except Exception as exc:\n            exc.__suppress_context__ = True\n            del exc\n\n            if local_sys is not None and local_sys.stderr is not None:\n                stderr = local_sys.stderr\n            else:\n                stderr = thread._stderr\n\n            local_print(\"Exception in threading.excepthook:\",\n                        file=stderr, flush=True)\n\n            if local_sys is not None and local_sys.excepthook is not None:\n                sys_excepthook = local_sys.excepthook\n            else:\n                sys_excepthook = old_sys_excepthook\n\n            sys_excepthook(*sys_exc_info())\n        finally:\n            # Break reference cycle (exception stored in a variable)\n            args = None\n\n    return invoke_excepthook\n\n\n# The timer class was contributed by Itamar Shtull-Trauring\n\nclass Timer(Thread):\n    \"\"\"Call a function after a specified number of seconds:\n\n            t = Timer(30.0, f, args=None, kwargs=None)\n            t.start()\n            t.cancel()     # stop the timer's action if it's still waiting\n\n    \"\"\"\n\n    def __init__(self, interval, function, args=None, kwargs=None):\n        Thread.__init__(self)\n        self.interval = interval\n        self.function = function\n        self.args = args if args is not None else []\n        self.kwargs = kwargs if kwargs is not None else {}\n        self.finished = Event()\n\n    def cancel(self):\n        \"\"\"Stop the timer if it hasn't finished yet.\"\"\"\n        self.finished.set()\n\n    def run(self):\n        self.finished.wait(self.interval)\n        if not self.finished.is_set():\n            self.function(*self.args, **self.kwargs)\n        self.finished.set()\n\n\n# Special thread class to represent the main thread\n\nclass _MainThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=\"MainThread\", daemon=False)\n        self._set_tstate_lock()\n        self._started.set()\n        self._set_ident()\n        if _HAVE_THREAD_NATIVE_ID:\n            self._set_native_id()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n\n# Dummy thread class to represent threads not started here.\n# These aren't garbage collected when they die, nor can they be waited for.\n# If they invoke anything in threading.py that calls current_thread(), they\n# leave an entry in the _active dict forever after.\n# Their purpose is to return *something* from current_thread().\n# They are marked as daemon threads so we won't wait for them\n# when we exit (conform previous semantics).\n\nclass _DummyThread(Thread):\n\n    def __init__(self):\n        Thread.__init__(self, name=_newname(\"Dummy-%d\"), daemon=True)\n\n        self._started.set()\n        self._set_ident()\n        if _HAVE_THREAD_NATIVE_ID:\n            self._set_native_id()\n        with _active_limbo_lock:\n            _active[self._ident] = self\n\n    def _stop(self):\n        pass\n\n    def is_alive(self):\n        assert not self._is_stopped and self._started.is_set()\n        return True\n\n    def join(self, timeout=None):\n        assert False, \"cannot join a dummy thread\"\n\n\n# Global API functions\n\ndef current_thread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    If the caller's thread of control was not created through the threading\n    module, a dummy thread object with limited functionality is returned.\n\n    \"\"\"\n    try:\n        return _active[get_ident()]\n    except KeyError:\n        return _DummyThread()\n\ndef currentThread():\n    \"\"\"Return the current Thread object, corresponding to the caller's thread of control.\n\n    This function is deprecated, use current_thread() instead.\n\n    \"\"\"\n    import warnings\n    warnings.warn('currentThread() is deprecated, use current_thread() instead',\n                  DeprecationWarning, stacklevel=2)\n    return current_thread()\n\ndef active_count():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    The returned count is equal to the length of the list returned by\n    enumerate().\n\n    \"\"\"\n    with _active_limbo_lock:\n        return len(_active) + len(_limbo)\n\ndef activeCount():\n    \"\"\"Return the number of Thread objects currently alive.\n\n    This function is deprecated, use active_count() instead.\n\n    \"\"\"\n    import warnings\n    warnings.warn('activeCount() is deprecated, use active_count() instead',\n                  DeprecationWarning, stacklevel=2)\n    return active_count()\n\ndef _enumerate():\n    # Same as enumerate(), but without the lock. Internal use only.\n    return list(_active.values()) + list(_limbo.values())\n\ndef enumerate():\n    \"\"\"Return a list of all Thread objects currently alive.\n\n    The list includes daemonic threads, dummy thread objects created by\n    current_thread(), and the main thread. It excludes terminated threads and\n    threads that have not yet been started.\n\n    \"\"\"\n    with _active_limbo_lock:\n        return list(_active.values()) + list(_limbo.values())\n\n\n_threading_atexits = []\n_SHUTTING_DOWN = False\n\ndef _register_atexit(func, *arg, **kwargs):\n    \"\"\"CPython internal: register *func* to be called before joining threads.\n\n    The registered *func* is called with its arguments just before all\n    non-daemon threads are joined in `_shutdown()`. It provides a similar\n    purpose to `atexit.register()`, but its functions are called prior to\n    threading shutdown instead of interpreter shutdown.\n\n    For similarity to atexit, the registered functions are called in reverse.\n    \"\"\"\n    if _SHUTTING_DOWN:\n        raise RuntimeError(\"can't register atexit after shutdown\")\n\n    call = functools.partial(func, *arg, **kwargs)\n    _threading_atexits.append(call)\n\n\nfrom _thread import stack_size\n\n# Create the main thread object,\n# and make it available for the interpreter\n# (Py_Main) as threading._shutdown.\n\n_main_thread = _MainThread()\n\ndef _shutdown():\n    \"\"\"\n    Wait until the Python thread state of all non-daemon threads get deleted.\n    \"\"\"\n    # Obscure:  other threads may be waiting to join _main_thread.  That's\n    # dubious, but some code does it.  We can't wait for C code to release\n    # the main thread's tstate_lock - that won't happen until the interpreter\n    # is nearly dead.  So we release it here.  Note that just calling _stop()\n    # isn't enough:  other threads may already be waiting on _tstate_lock.\n    if _main_thread._is_stopped:\n        # _shutdown() was already called\n        return\n\n    global _SHUTTING_DOWN\n    _SHUTTING_DOWN = True\n\n    # Call registered threading atexit functions before threads are joined.\n    # Order is reversed, similar to atexit.\n    for atexit_call in reversed(_threading_atexits):\n        atexit_call()\n\n    # Main thread\n    if _main_thread.ident == get_ident():\n        tlock = _main_thread._tstate_lock\n        # The main thread isn't finished yet, so its thread state lock can't\n        # have been released.\n        assert tlock is not None\n        assert tlock.locked()\n        tlock.release()\n        _main_thread._stop()\n    else:\n        # bpo-1596321: _shutdown() must be called in the main thread.\n        # If the threading module was not imported by the main thread,\n        # _main_thread is the thread which imported the threading module.\n        # In this case, ignore _main_thread, similar behavior than for threads\n        # spawned by C libraries or using _thread.start_new_thread().\n        pass\n\n    # Join all non-deamon threads\n    while True:\n        with _shutdown_locks_lock:\n            locks = list(_shutdown_locks)\n            _shutdown_locks.clear()\n\n        if not locks:\n            break\n\n        for lock in locks:\n            # mimic Thread.join()\n            lock.acquire()\n            lock.release()\n\n        # new threads can be spawned while we were waiting for the other\n        # threads to complete\n\n\ndef main_thread():\n    \"\"\"Return the main thread object.\n\n    In normal conditions, the main thread is the thread from which the\n    Python interpreter was started.\n    \"\"\"\n    return _main_thread\n\n# get thread-local implementation, either from the thread\n# module, or from the python fallback\n\ntry:\n    from _thread import _local as local\nexcept ImportError:\n    from _threading_local import local\n\n\ndef _after_fork():\n    \"\"\"\n    Cleanup threading module state that should not exist after a fork.\n    \"\"\"\n    # Reset _active_limbo_lock, in case we forked while the lock was held\n    # by another (non-forked) thread.  http://bugs.python.org/issue874900\n    global _active_limbo_lock, _main_thread\n    global _shutdown_locks_lock, _shutdown_locks\n    _active_limbo_lock = RLock()\n\n    # fork() only copied the current thread; clear references to others.\n    new_active = {}\n\n    try:\n        current = _active[get_ident()]\n    except KeyError:\n        # fork() was called in a thread which was not spawned\n        # by threading.Thread. For example, a thread spawned\n        # by thread.start_new_thread().\n        current = _MainThread()\n\n    _main_thread = current\n\n    # reset _shutdown() locks: threads re-register their _tstate_lock below\n    _shutdown_locks_lock = _allocate_lock()\n    _shutdown_locks = set()\n\n    with _active_limbo_lock:\n        # Dangling thread instances must still have their locks reset,\n        # because someone may join() them.\n        threads = set(_enumerate())\n        threads.update(_dangling)\n        for thread in threads:\n            # Any lock/condition variable may be currently locked or in an\n            # invalid state, so we reinitialize them.\n            if thread is current:\n                # There is only one active thread. We reset the ident to\n                # its new value since it can have changed.\n                thread._reset_internal_locks(True)\n                ident = get_ident()\n                if isinstance(thread, _DummyThread):\n                    thread.__class__ = _MainThread\n                    thread._name = 'MainThread'\n                    thread._daemonic = False\n                    thread._set_tstate_lock()\n                thread._ident = ident\n                new_active[ident] = thread\n            else:\n                # All the others are already stopped.\n                thread._reset_internal_locks(False)\n                thread._stop()\n\n        _limbo.clear()\n        _active.clear()\n        _active.update(new_active)\n        assert len(_active) == 1\n\n\nif hasattr(_os, \"register_at_fork\"):\n    _os.register_at_fork(after_in_child=_after_fork)\n", 1673], "/usr/local/lib/python3.11/concurrent/futures/_base.py": ["# Copyright 2009 Brian Quinlan. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n__author__ = 'Brian Quinlan (brian@sweetapp.com)'\n\nimport collections\nimport logging\nimport threading\nimport time\nimport types\n\nFIRST_COMPLETED = 'FIRST_COMPLETED'\nFIRST_EXCEPTION = 'FIRST_EXCEPTION'\nALL_COMPLETED = 'ALL_COMPLETED'\n_AS_COMPLETED = '_AS_COMPLETED'\n\n# Possible future states (for internal use by the futures package).\nPENDING = 'PENDING'\nRUNNING = 'RUNNING'\n# The future was cancelled by the user...\nCANCELLED = 'CANCELLED'\n# ...and _Waiter.add_cancelled() was called by a worker.\nCANCELLED_AND_NOTIFIED = 'CANCELLED_AND_NOTIFIED'\nFINISHED = 'FINISHED'\n\n_FUTURE_STATES = [\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    CANCELLED_AND_NOTIFIED,\n    FINISHED\n]\n\n_STATE_TO_DESCRIPTION_MAP = {\n    PENDING: \"pending\",\n    RUNNING: \"running\",\n    CANCELLED: \"cancelled\",\n    CANCELLED_AND_NOTIFIED: \"cancelled\",\n    FINISHED: \"finished\"\n}\n\n# Logger for internal use by the futures package.\nLOGGER = logging.getLogger(\"concurrent.futures\")\n\nclass Error(Exception):\n    \"\"\"Base class for all future-related exceptions.\"\"\"\n    pass\n\nclass CancelledError(Error):\n    \"\"\"The Future was cancelled.\"\"\"\n    pass\n\nTimeoutError = TimeoutError  # make local alias for the standard exception\n\nclass InvalidStateError(Error):\n    \"\"\"The operation is not allowed in this state.\"\"\"\n    pass\n\nclass _Waiter(object):\n    \"\"\"Provides the event that wait() and as_completed() block on.\"\"\"\n    def __init__(self):\n        self.event = threading.Event()\n        self.finished_futures = []\n\n    def add_result(self, future):\n        self.finished_futures.append(future)\n\n    def add_exception(self, future):\n        self.finished_futures.append(future)\n\n    def add_cancelled(self, future):\n        self.finished_futures.append(future)\n\nclass _AsCompletedWaiter(_Waiter):\n    \"\"\"Used by as_completed().\"\"\"\n\n    def __init__(self):\n        super(_AsCompletedWaiter, self).__init__()\n        self.lock = threading.Lock()\n\n    def add_result(self, future):\n        with self.lock:\n            super(_AsCompletedWaiter, self).add_result(future)\n            self.event.set()\n\n    def add_exception(self, future):\n        with self.lock:\n            super(_AsCompletedWaiter, self).add_exception(future)\n            self.event.set()\n\n    def add_cancelled(self, future):\n        with self.lock:\n            super(_AsCompletedWaiter, self).add_cancelled(future)\n            self.event.set()\n\nclass _FirstCompletedWaiter(_Waiter):\n    \"\"\"Used by wait(return_when=FIRST_COMPLETED).\"\"\"\n\n    def add_result(self, future):\n        super().add_result(future)\n        self.event.set()\n\n    def add_exception(self, future):\n        super().add_exception(future)\n        self.event.set()\n\n    def add_cancelled(self, future):\n        super().add_cancelled(future)\n        self.event.set()\n\nclass _AllCompletedWaiter(_Waiter):\n    \"\"\"Used by wait(return_when=FIRST_EXCEPTION and ALL_COMPLETED).\"\"\"\n\n    def __init__(self, num_pending_calls, stop_on_exception):\n        self.num_pending_calls = num_pending_calls\n        self.stop_on_exception = stop_on_exception\n        self.lock = threading.Lock()\n        super().__init__()\n\n    def _decrement_pending_calls(self):\n        with self.lock:\n            self.num_pending_calls -= 1\n            if not self.num_pending_calls:\n                self.event.set()\n\n    def add_result(self, future):\n        super().add_result(future)\n        self._decrement_pending_calls()\n\n    def add_exception(self, future):\n        super().add_exception(future)\n        if self.stop_on_exception:\n            self.event.set()\n        else:\n            self._decrement_pending_calls()\n\n    def add_cancelled(self, future):\n        super().add_cancelled(future)\n        self._decrement_pending_calls()\n\nclass _AcquireFutures(object):\n    \"\"\"A context manager that does an ordered acquire of Future conditions.\"\"\"\n\n    def __init__(self, futures):\n        self.futures = sorted(futures, key=id)\n\n    def __enter__(self):\n        for future in self.futures:\n            future._condition.acquire()\n\n    def __exit__(self, *args):\n        for future in self.futures:\n            future._condition.release()\n\ndef _create_and_install_waiters(fs, return_when):\n    if return_when == _AS_COMPLETED:\n        waiter = _AsCompletedWaiter()\n    elif return_when == FIRST_COMPLETED:\n        waiter = _FirstCompletedWaiter()\n    else:\n        pending_count = sum(\n                f._state not in [CANCELLED_AND_NOTIFIED, FINISHED] for f in fs)\n\n        if return_when == FIRST_EXCEPTION:\n            waiter = _AllCompletedWaiter(pending_count, stop_on_exception=True)\n        elif return_when == ALL_COMPLETED:\n            waiter = _AllCompletedWaiter(pending_count, stop_on_exception=False)\n        else:\n            raise ValueError(\"Invalid return condition: %r\" % return_when)\n\n    for f in fs:\n        f._waiters.append(waiter)\n\n    return waiter\n\n\ndef _yield_finished_futures(fs, waiter, ref_collect):\n    \"\"\"\n    Iterate on the list *fs*, yielding finished futures one by one in\n    reverse order.\n    Before yielding a future, *waiter* is removed from its waiters\n    and the future is removed from each set in the collection of sets\n    *ref_collect*.\n\n    The aim of this function is to avoid keeping stale references after\n    the future is yielded and before the iterator resumes.\n    \"\"\"\n    while fs:\n        f = fs[-1]\n        for futures_set in ref_collect:\n            futures_set.remove(f)\n        with f._condition:\n            f._waiters.remove(waiter)\n        del f\n        # Careful not to keep a reference to the popped value\n        yield fs.pop()\n\n\ndef as_completed(fs, timeout=None):\n    \"\"\"An iterator over the given futures that yields each as it completes.\n\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            iterate over.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n\n    Returns:\n        An iterator that yields the given Futures as they complete (finished or\n        cancelled). If any given Futures are duplicated, they will be returned\n        once.\n\n    Raises:\n        TimeoutError: If the entire result iterator could not be generated\n            before the given timeout.\n    \"\"\"\n    if timeout is not None:\n        end_time = timeout + time.monotonic()\n\n    fs = set(fs)\n    total_futures = len(fs)\n    with _AcquireFutures(fs):\n        finished = set(\n                f for f in fs\n                if f._state in [CANCELLED_AND_NOTIFIED, FINISHED])\n        pending = fs - finished\n        waiter = _create_and_install_waiters(fs, _AS_COMPLETED)\n    finished = list(finished)\n    try:\n        yield from _yield_finished_futures(finished, waiter,\n                                           ref_collect=(fs,))\n\n        while pending:\n            if timeout is None:\n                wait_timeout = None\n            else:\n                wait_timeout = end_time - time.monotonic()\n                if wait_timeout < 0:\n                    raise TimeoutError(\n                            '%d (of %d) futures unfinished' % (\n                            len(pending), total_futures))\n\n            waiter.event.wait(wait_timeout)\n\n            with waiter.lock:\n                finished = waiter.finished_futures\n                waiter.finished_futures = []\n                waiter.event.clear()\n\n            # reverse to keep finishing order\n            finished.reverse()\n            yield from _yield_finished_futures(finished, waiter,\n                                               ref_collect=(fs, pending))\n\n    finally:\n        # Remove waiter from unfinished futures\n        for f in fs:\n            with f._condition:\n                f._waiters.remove(waiter)\n\nDoneAndNotDoneFutures = collections.namedtuple(\n        'DoneAndNotDoneFutures', 'done not_done')\ndef wait(fs, timeout=None, return_when=ALL_COMPLETED):\n    \"\"\"Wait for the futures in the given sequence to complete.\n\n    Args:\n        fs: The sequence of Futures (possibly created by different Executors) to\n            wait upon.\n        timeout: The maximum number of seconds to wait. If None, then there\n            is no limit on the wait time.\n        return_when: Indicates when this function should return. The options\n            are:\n\n            FIRST_COMPLETED - Return when any future finishes or is\n                              cancelled.\n            FIRST_EXCEPTION - Return when any future finishes by raising an\n                              exception. If no future raises an exception\n                              then it is equivalent to ALL_COMPLETED.\n            ALL_COMPLETED -   Return when all futures finish or are cancelled.\n\n    Returns:\n        A named 2-tuple of sets. The first set, named 'done', contains the\n        futures that completed (is finished or cancelled) before the wait\n        completed. The second set, named 'not_done', contains uncompleted\n        futures. Duplicate futures given to *fs* are removed and will be\n        returned only once.\n    \"\"\"\n    fs = set(fs)\n    with _AcquireFutures(fs):\n        done = {f for f in fs\n                   if f._state in [CANCELLED_AND_NOTIFIED, FINISHED]}\n        not_done = fs - done\n        if (return_when == FIRST_COMPLETED) and done:\n            return DoneAndNotDoneFutures(done, not_done)\n        elif (return_when == FIRST_EXCEPTION) and done:\n            if any(f for f in done\n                   if not f.cancelled() and f.exception() is not None):\n                return DoneAndNotDoneFutures(done, not_done)\n\n        if len(done) == len(fs):\n            return DoneAndNotDoneFutures(done, not_done)\n\n        waiter = _create_and_install_waiters(fs, return_when)\n\n    waiter.event.wait(timeout)\n    for f in fs:\n        with f._condition:\n            f._waiters.remove(waiter)\n\n    done.update(waiter.finished_futures)\n    return DoneAndNotDoneFutures(done, fs - done)\n\n\ndef _result_or_cancel(fut, timeout=None):\n    try:\n        try:\n            return fut.result(timeout)\n        finally:\n            fut.cancel()\n    finally:\n        # Break a reference cycle with the exception in self._exception\n        del fut\n\n\nclass Future(object):\n    \"\"\"Represents the result of an asynchronous computation.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the future. Should not be called by clients.\"\"\"\n        self._condition = threading.Condition()\n        self._state = PENDING\n        self._result = None\n        self._exception = None\n        self._waiters = []\n        self._done_callbacks = []\n\n    def _invoke_callbacks(self):\n        for callback in self._done_callbacks:\n            try:\n                callback(self)\n            except Exception:\n                LOGGER.exception('exception calling callback for %r', self)\n\n    def __repr__(self):\n        with self._condition:\n            if self._state == FINISHED:\n                if self._exception:\n                    return '<%s at %#x state=%s raised %s>' % (\n                        self.__class__.__name__,\n                        id(self),\n                        _STATE_TO_DESCRIPTION_MAP[self._state],\n                        self._exception.__class__.__name__)\n                else:\n                    return '<%s at %#x state=%s returned %s>' % (\n                        self.__class__.__name__,\n                        id(self),\n                        _STATE_TO_DESCRIPTION_MAP[self._state],\n                        self._result.__class__.__name__)\n            return '<%s at %#x state=%s>' % (\n                    self.__class__.__name__,\n                    id(self),\n                   _STATE_TO_DESCRIPTION_MAP[self._state])\n\n    def cancel(self):\n        \"\"\"Cancel the future if possible.\n\n        Returns True if the future was cancelled, False otherwise. A future\n        cannot be cancelled if it is running or has already completed.\n        \"\"\"\n        with self._condition:\n            if self._state in [RUNNING, FINISHED]:\n                return False\n\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                return True\n\n            self._state = CANCELLED\n            self._condition.notify_all()\n\n        self._invoke_callbacks()\n        return True\n\n    def cancelled(self):\n        \"\"\"Return True if the future was cancelled.\"\"\"\n        with self._condition:\n            return self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]\n\n    def running(self):\n        \"\"\"Return True if the future is currently executing.\"\"\"\n        with self._condition:\n            return self._state == RUNNING\n\n    def done(self):\n        \"\"\"Return True if the future was cancelled or finished executing.\"\"\"\n        with self._condition:\n            return self._state in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]\n\n    def __get_result(self):\n        if self._exception:\n            try:\n                raise self._exception\n            finally:\n                # Break a reference cycle with the exception in self._exception\n                self = None\n        else:\n            return self._result\n\n    def add_done_callback(self, fn):\n        \"\"\"Attaches a callable that will be called when the future finishes.\n\n        Args:\n            fn: A callable that will be called with this future as its only\n                argument when the future completes or is cancelled. The callable\n                will always be called by a thread in the same process in which\n                it was added. If the future has already completed or been\n                cancelled then the callable will be called immediately. These\n                callables are called in the order that they were added.\n        \"\"\"\n        with self._condition:\n            if self._state not in [CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED]:\n                self._done_callbacks.append(fn)\n                return\n        try:\n            fn(self)\n        except Exception:\n            LOGGER.exception('exception calling callback for %r', self)\n\n    def result(self, timeout=None):\n        \"\"\"Return the result of the call that the future represents.\n\n        Args:\n            timeout: The number of seconds to wait for the result if the future\n                isn't done. If None, then there is no limit on the wait time.\n\n        Returns:\n            The result of the call that the future represents.\n\n        Raises:\n            CancelledError: If the future was cancelled.\n            TimeoutError: If the future didn't finish executing before the given\n                timeout.\n            Exception: If the call raised then that exception will be raised.\n        \"\"\"\n        try:\n            with self._condition:\n                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                    raise CancelledError()\n                elif self._state == FINISHED:\n                    return self.__get_result()\n\n                self._condition.wait(timeout)\n\n                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                    raise CancelledError()\n                elif self._state == FINISHED:\n                    return self.__get_result()\n                else:\n                    raise TimeoutError()\n        finally:\n            # Break a reference cycle with the exception in self._exception\n            self = None\n\n    def exception(self, timeout=None):\n        \"\"\"Return the exception raised by the call that the future represents.\n\n        Args:\n            timeout: The number of seconds to wait for the exception if the\n                future isn't done. If None, then there is no limit on the wait\n                time.\n\n        Returns:\n            The exception raised by the call that the future represents or None\n            if the call completed without raising.\n\n        Raises:\n            CancelledError: If the future was cancelled.\n            TimeoutError: If the future didn't finish executing before the given\n                timeout.\n        \"\"\"\n\n        with self._condition:\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self._exception\n\n            self._condition.wait(timeout)\n\n            if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:\n                raise CancelledError()\n            elif self._state == FINISHED:\n                return self._exception\n            else:\n                raise TimeoutError()\n\n    # The following methods should only be used by Executors and in tests.\n    def set_running_or_notify_cancel(self):\n        \"\"\"Mark the future as running or process any cancel notifications.\n\n        Should only be used by Executor implementations and unit tests.\n\n        If the future has been cancelled (cancel() was called and returned\n        True) then any threads waiting on the future completing (though calls\n        to as_completed() or wait()) are notified and False is returned.\n\n        If the future was not cancelled then it is put in the running state\n        (future calls to running() will return True) and True is returned.\n\n        This method should be called by Executor implementations before\n        executing the work associated with this future. If this method returns\n        False then the work should not be executed.\n\n        Returns:\n            False if the Future was cancelled, True otherwise.\n\n        Raises:\n            RuntimeError: if this method was already called or if set_result()\n                or set_exception() was called.\n        \"\"\"\n        with self._condition:\n            if self._state == CANCELLED:\n                self._state = CANCELLED_AND_NOTIFIED\n                for waiter in self._waiters:\n                    waiter.add_cancelled(self)\n                # self._condition.notify_all() is not necessary because\n                # self.cancel() triggers a notification.\n                return False\n            elif self._state == PENDING:\n                self._state = RUNNING\n                return True\n            else:\n                LOGGER.critical('Future %s in unexpected state: %s',\n                                id(self),\n                                self._state)\n                raise RuntimeError('Future in unexpected state')\n\n    def set_result(self, result):\n        \"\"\"Sets the return value of work associated with the future.\n\n        Should only be used by Executor implementations and unit tests.\n        \"\"\"\n        with self._condition:\n            if self._state in {CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED}:\n                raise InvalidStateError('{}: {!r}'.format(self._state, self))\n            self._result = result\n            self._state = FINISHED\n            for waiter in self._waiters:\n                waiter.add_result(self)\n            self._condition.notify_all()\n        self._invoke_callbacks()\n\n    def set_exception(self, exception):\n        \"\"\"Sets the result of the future as being the given exception.\n\n        Should only be used by Executor implementations and unit tests.\n        \"\"\"\n        with self._condition:\n            if self._state in {CANCELLED, CANCELLED_AND_NOTIFIED, FINISHED}:\n                raise InvalidStateError('{}: {!r}'.format(self._state, self))\n            self._exception = exception\n            self._state = FINISHED\n            for waiter in self._waiters:\n                waiter.add_exception(self)\n            self._condition.notify_all()\n        self._invoke_callbacks()\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\nclass Executor(object):\n    \"\"\"This is an abstract base class for concrete asynchronous executors.\"\"\"\n\n    def submit(self, fn, /, *args, **kwargs):\n        \"\"\"Submits a callable to be executed with the given arguments.\n\n        Schedules the callable to be executed as fn(*args, **kwargs) and returns\n        a Future instance representing the execution of the callable.\n\n        Returns:\n            A Future representing the given call.\n        \"\"\"\n        raise NotImplementedError()\n\n    def map(self, fn, *iterables, timeout=None, chunksize=1):\n        \"\"\"Returns an iterator equivalent to map(fn, iter).\n\n        Args:\n            fn: A callable that will take as many arguments as there are\n                passed iterables.\n            timeout: The maximum number of seconds to wait. If None, then there\n                is no limit on the wait time.\n            chunksize: The size of the chunks the iterable will be broken into\n                before being passed to a child process. This argument is only\n                used by ProcessPoolExecutor; it is ignored by\n                ThreadPoolExecutor.\n\n        Returns:\n            An iterator equivalent to: map(func, *iterables) but the calls may\n            be evaluated out-of-order.\n\n        Raises:\n            TimeoutError: If the entire result iterator could not be generated\n                before the given timeout.\n            Exception: If fn(*args) raises for any values.\n        \"\"\"\n        if timeout is not None:\n            end_time = timeout + time.monotonic()\n\n        fs = [self.submit(fn, *args) for args in zip(*iterables)]\n\n        # Yield must be hidden in closure so that the futures are submitted\n        # before the first iterator value is required.\n        def result_iterator():\n            try:\n                # reverse to keep finishing order\n                fs.reverse()\n                while fs:\n                    # Careful not to keep a reference to the popped future\n                    if timeout is None:\n                        yield _result_or_cancel(fs.pop())\n                    else:\n                        yield _result_or_cancel(fs.pop(), end_time - time.monotonic())\n            finally:\n                for future in fs:\n                    future.cancel()\n        return result_iterator()\n\n    def shutdown(self, wait=True, *, cancel_futures=False):\n        \"\"\"Clean-up the resources associated with the Executor.\n\n        It is safe to call this method several times. Otherwise, no other\n        methods can be called after this one.\n\n        Args:\n            wait: If True then shutdown will not return until all running\n                futures have finished executing and the resources used by the\n                executor have been reclaimed.\n            cancel_futures: If True then shutdown will cancel all pending\n                futures. Futures that are completed or running will not be\n                cancelled.\n        \"\"\"\n        pass\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.shutdown(wait=True)\n        return False\n\n\nclass BrokenExecutor(RuntimeError):\n    \"\"\"\n    Raised when a executor has become non-functional after a severe failure.\n    \"\"\"\n", 654], "/usr/local/lib/python3.11/concurrent/futures/thread.py": ["# Copyright 2009 Brian Quinlan. All Rights Reserved.\n# Licensed to PSF under a Contributor Agreement.\n\n\"\"\"Implements ThreadPoolExecutor.\"\"\"\n\n__author__ = 'Brian Quinlan (brian@sweetapp.com)'\n\nfrom concurrent.futures import _base\nimport itertools\nimport queue\nimport threading\nimport types\nimport weakref\nimport os\n\n\n_threads_queues = weakref.WeakKeyDictionary()\n_shutdown = False\n# Lock that ensures that new workers are not created while the interpreter is\n# shutting down. Must be held while mutating _threads_queues and _shutdown.\n_global_shutdown_lock = threading.Lock()\n\ndef _python_exit():\n    global _shutdown\n    with _global_shutdown_lock:\n        _shutdown = True\n    items = list(_threads_queues.items())\n    for t, q in items:\n        q.put(None)\n    for t, q in items:\n        t.join()\n\n# Register for `_python_exit()` to be called just before joining all\n# non-daemon threads. This is used instead of `atexit.register()` for\n# compatibility with subinterpreters, which no longer support daemon threads.\n# See bpo-39812 for context.\nthreading._register_atexit(_python_exit)\n\n# At fork, reinitialize the `_global_shutdown_lock` lock in the child process\nif hasattr(os, 'register_at_fork'):\n    os.register_at_fork(before=_global_shutdown_lock.acquire,\n                        after_in_child=_global_shutdown_lock._at_fork_reinit,\n                        after_in_parent=_global_shutdown_lock.release)\n\n\nclass _WorkItem(object):\n    def __init__(self, future, fn, args, kwargs):\n        self.future = future\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n\n    def run(self):\n        if not self.future.set_running_or_notify_cancel():\n            return\n\n        try:\n            result = self.fn(*self.args, **self.kwargs)\n        except BaseException as exc:\n            self.future.set_exception(exc)\n            # Break a reference cycle with the exception 'exc'\n            self = None\n        else:\n            self.future.set_result(result)\n\n    __class_getitem__ = classmethod(types.GenericAlias)\n\n\ndef _worker(executor_reference, work_queue, initializer, initargs):\n    if initializer is not None:\n        try:\n            initializer(*initargs)\n        except BaseException:\n            _base.LOGGER.critical('Exception in initializer:', exc_info=True)\n            executor = executor_reference()\n            if executor is not None:\n                executor._initializer_failed()\n            return\n    try:\n        while True:\n            work_item = work_queue.get(block=True)\n            if work_item is not None:\n                work_item.run()\n                # Delete references to object. See issue16284\n                del work_item\n\n                # attempt to increment idle count\n                executor = executor_reference()\n                if executor is not None:\n                    executor._idle_semaphore.release()\n                del executor\n                continue\n\n            executor = executor_reference()\n            # Exit if:\n            #   - The interpreter is shutting down OR\n            #   - The executor that owns the worker has been collected OR\n            #   - The executor that owns the worker has been shutdown.\n            if _shutdown or executor is None or executor._shutdown:\n                # Flag the executor as shutting down as early as possible if it\n                # is not gc-ed yet.\n                if executor is not None:\n                    executor._shutdown = True\n                # Notice other workers\n                work_queue.put(None)\n                return\n            del executor\n    except BaseException:\n        _base.LOGGER.critical('Exception in worker', exc_info=True)\n\n\nclass BrokenThreadPool(_base.BrokenExecutor):\n    \"\"\"\n    Raised when a worker thread in a ThreadPoolExecutor failed initializing.\n    \"\"\"\n\n\nclass ThreadPoolExecutor(_base.Executor):\n\n    # Used to assign unique thread names when thread_name_prefix is not supplied.\n    _counter = itertools.count().__next__\n\n    def __init__(self, max_workers=None, thread_name_prefix='',\n                 initializer=None, initargs=()):\n        \"\"\"Initializes a new ThreadPoolExecutor instance.\n\n        Args:\n            max_workers: The maximum number of threads that can be used to\n                execute the given calls.\n            thread_name_prefix: An optional name prefix to give our threads.\n            initializer: A callable used to initialize worker threads.\n            initargs: A tuple of arguments to pass to the initializer.\n        \"\"\"\n        if max_workers is None:\n            # ThreadPoolExecutor is often used to:\n            # * CPU bound task which releases GIL\n            # * I/O bound task (which releases GIL, of course)\n            #\n            # We use cpu_count + 4 for both types of tasks.\n            # But we limit it to 32 to avoid consuming surprisingly large resource\n            # on many core machine.\n            max_workers = min(32, (os.cpu_count() or 1) + 4)\n        if max_workers <= 0:\n            raise ValueError(\"max_workers must be greater than 0\")\n\n        if initializer is not None and not callable(initializer):\n            raise TypeError(\"initializer must be a callable\")\n\n        self._max_workers = max_workers\n        self._work_queue = queue.SimpleQueue()\n        self._idle_semaphore = threading.Semaphore(0)\n        self._threads = set()\n        self._broken = False\n        self._shutdown = False\n        self._shutdown_lock = threading.Lock()\n        self._thread_name_prefix = (thread_name_prefix or\n                                    (\"ThreadPoolExecutor-%d\" % self._counter()))\n        self._initializer = initializer\n        self._initargs = initargs\n\n    def submit(self, fn, /, *args, **kwargs):\n        with self._shutdown_lock, _global_shutdown_lock:\n            if self._broken:\n                raise BrokenThreadPool(self._broken)\n\n            if self._shutdown:\n                raise RuntimeError('cannot schedule new futures after shutdown')\n            if _shutdown:\n                raise RuntimeError('cannot schedule new futures after '\n                                   'interpreter shutdown')\n\n            f = _base.Future()\n            w = _WorkItem(f, fn, args, kwargs)\n\n            self._work_queue.put(w)\n            self._adjust_thread_count()\n            return f\n    submit.__doc__ = _base.Executor.submit.__doc__\n\n    def _adjust_thread_count(self):\n        # if idle threads are available, don't spin new threads\n        if self._idle_semaphore.acquire(timeout=0):\n            return\n\n        # When the executor gets lost, the weakref callback will wake up\n        # the worker threads.\n        def weakref_cb(_, q=self._work_queue):\n            q.put(None)\n\n        num_threads = len(self._threads)\n        if num_threads < self._max_workers:\n            thread_name = '%s_%d' % (self._thread_name_prefix or self,\n                                     num_threads)\n            t = threading.Thread(name=thread_name, target=_worker,\n                                 args=(weakref.ref(self, weakref_cb),\n                                       self._work_queue,\n                                       self._initializer,\n                                       self._initargs))\n            t.start()\n            self._threads.add(t)\n            _threads_queues[t] = self._work_queue\n\n    def _initializer_failed(self):\n        with self._shutdown_lock:\n            self._broken = ('A thread initializer failed, the thread pool '\n                            'is not usable anymore')\n            # Drain work queue and mark pending futures failed\n            while True:\n                try:\n                    work_item = self._work_queue.get_nowait()\n                except queue.Empty:\n                    break\n                if work_item is not None:\n                    work_item.future.set_exception(BrokenThreadPool(self._broken))\n\n    def shutdown(self, wait=True, *, cancel_futures=False):\n        with self._shutdown_lock:\n            self._shutdown = True\n            if cancel_futures:\n                # Drain all work items from the queue, and then cancel their\n                # associated futures.\n                while True:\n                    try:\n                        work_item = self._work_queue.get_nowait()\n                    except queue.Empty:\n                        break\n                    if work_item is not None:\n                        work_item.future.cancel()\n\n            # Send a wake-up to prevent threads calling\n            # _work_queue.get(block=True) from permanently blocking.\n            self._work_queue.put(None)\n        if wait:\n            for t in self._threads:\n                t.join()\n    shutdown.__doc__ = _base.Executor.shutdown.__doc__\n", 236], "/usr/local/lib/python3.11/asyncio/base_futures.py": ["__all__ = ()\n\nimport reprlib\nfrom _thread import get_ident\n\nfrom . import format_helpers\n\n# States for Future.\n_PENDING = 'PENDING'\n_CANCELLED = 'CANCELLED'\n_FINISHED = 'FINISHED'\n\n\ndef isfuture(obj):\n    \"\"\"Check for a Future.\n\n    This returns True when obj is a Future instance or is advertising\n    itself as duck-type compatible by setting _asyncio_future_blocking.\n    See comment in Future for more details.\n    \"\"\"\n    return (hasattr(obj.__class__, '_asyncio_future_blocking') and\n            obj._asyncio_future_blocking is not None)\n\n\ndef _format_callbacks(cb):\n    \"\"\"helper function for Future.__repr__\"\"\"\n    size = len(cb)\n    if not size:\n        cb = ''\n\n    def format_cb(callback):\n        return format_helpers._format_callback_source(callback, ())\n\n    if size == 1:\n        cb = format_cb(cb[0][0])\n    elif size == 2:\n        cb = '{}, {}'.format(format_cb(cb[0][0]), format_cb(cb[1][0]))\n    elif size > 2:\n        cb = '{}, <{} more>, {}'.format(format_cb(cb[0][0]),\n                                        size - 2,\n                                        format_cb(cb[-1][0]))\n    return f'cb=[{cb}]'\n\n\ndef _future_repr_info(future):\n    # (Future) -> str\n    \"\"\"helper function for Future.__repr__\"\"\"\n    info = [future._state.lower()]\n    if future._state == _FINISHED:\n        if future._exception is not None:\n            info.append(f'exception={future._exception!r}')\n        else:\n            # use reprlib to limit the length of the output, especially\n            # for very long strings\n            result = reprlib.repr(future._result)\n            info.append(f'result={result}')\n    if future._callbacks:\n        info.append(_format_callbacks(future._callbacks))\n    if future._source_traceback:\n        frame = future._source_traceback[-1]\n        info.append(f'created at {frame[0]}:{frame[1]}')\n    return info\n\n\n@reprlib.recursive_repr()\ndef _future_repr(future):\n    info = ' '.join(_future_repr_info(future))\n    return f'<{future.__class__.__name__} {info}>'\n", 68], "/usr/local/lib/python3.11/asyncio/threads.py": ["\"\"\"High-level support for working with threads in asyncio\"\"\"\n\nimport functools\nimport contextvars\n\nfrom . import events\n\n\n__all__ = \"to_thread\",\n\n\nasync def to_thread(func, /, *args, **kwargs):\n    \"\"\"Asynchronously run function *func* in a separate thread.\n\n    Any *args and **kwargs supplied for this function are directly passed\n    to *func*. Also, the current :class:`contextvars.Context` is propagated,\n    allowing context variables from the main thread to be accessed in the\n    separate thread.\n\n    Return a coroutine that can be awaited to get the eventual result of *func*.\n    \"\"\"\n    loop = events.get_running_loop()\n    ctx = contextvars.copy_context()\n    func_call = functools.partial(ctx.run, func, *args, **kwargs)\n    return await loop.run_in_executor(None, func_call)\n", 25], "/app/app/main.py": ["import asyncio\nimport contextlib\nimport json\nimport logging\nimport os\nfrom contextlib import asynccontextmanager\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom fastapi import FastAPI, HTTPException, Query, WebSocket, WebSocketDisconnect\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom prometheus_client import make_asgi_app\nfrom dotenv import load_dotenv\n\nfrom .core.config import Settings, get_settings, hot_reload, validate_settings\nfrom .services import MarketDataService\nfrom .services.options_service import OptionContract, OptionsChain, options_service\nfrom .observability.trace import maybe_trace\n\n# Load environment variables\nload_dotenv()\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Global service instance\nmarket_service = MarketDataService()\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    await market_service.start_background_tasks()\n    logger.info(\"Market Data Service started\")\n    yield\n    # Shutdown\n    market_service.background_tasks_running = False\n    await market_service.data_collector.stop()\n    logger.info(\"Market Data Service stopped\")\n\napp = FastAPI(\n    title=\"Market Data Service\",\n    description=\"Reliable real-time and historical stock data\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\nmetrics_app = make_asgi_app()\napp.mount(\"/metrics\", metrics_app)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.get(\"/\")\nasync def root():\n    stats = await market_service.get_stats()\n    settings = get_settings()\n    return {\n        \"service\": \"Market Data Service\",\n        \"status\": \"running\",\n        \"timestamp\": datetime.now().isoformat(),\n        \"env\": settings.env,\n        \"policy_version\": settings.policy_version,\n        \"stats\": stats,\n        \"endpoints\": {\n            \"stock_price\": \"/stocks/{symbol}/price\",\n            \"historical\": \"/stocks/{symbol}/history\",\n            \"company_profile\": \"/stocks/{symbol}/profile\",\n            \"news_sentiment\": \"/stocks/{symbol}/sentiment\",\n            \"options_metrics\": \"/options/{symbol}/metrics\",\n            \"options_metrics_history\": \"/options/{symbol}/metrics/history\",\n            \"unusual_options_activity\": \"/options/{symbol}/unusual\",\n            \"options_flow_analysis\": \"/options/{symbol}/flow\",\n            \"macro_snapshot\": \"/factors/macro\",\n            \"macro_history\": \"/factors/macro/{factor_key}/history\",\n            \"macro_refresh\": \"/admin/macro/refresh\",\n            \"batch_quotes\": \"/stocks/batch\",\n            \"health\": \"/health\",\n            \"websocket\": \"/ws/{symbol}\"\n        }\n    }\n\n@app.get(\"/health\")\nasync def health_check():\n    stats = await market_service.get_stats()\n    settings = get_settings()\n    return {\n        \"status\": \"healthy\",\n        \"service\": \"market-data-service\",\n        \"timestamp\": datetime.now().isoformat(),\n        \"env\": settings.env,\n        \"policy_version\": settings.policy_version,\n        \"providers_status\": {\n            provider[\"name\"]: provider[\"available\"]\n            for provider in stats[\"providers\"]\n        },\n        \"macro\": stats.get(\"macro\", {}),\n        \"options_metrics\": stats.get(\"options_metrics\", {})\n    }\n\n\n@app.post(\"/ops/validate\")\ndef ops_validate():\n    candidate = Settings()\n    ok, reason = validate_settings(candidate)\n    return {\"ok\": ok, \"reason\": reason, \"policy_version\": candidate.policy_version}\n\n\n@app.post(\"/ops/reload\")\nasync def ops_reload():\n    result = hot_reload()\n    if result.get(\"ok\"):\n        market_service.reload_configuration()\n        result[\"policy_version\"] = get_settings().policy_version\n    return result\n\n\n@app.get(\"/stats/providers\")\nasync def stats_providers():\n    registry = market_service.registry\n    breakers = market_service.breakers\n    settings = get_settings()\n\n    providers = []\n    for name, entry in registry.providers.items():\n        providers.append(\n            {\n                \"provider\": name,\n                \"state\": breakers.get_state(name),\n                \"capabilities\": sorted(entry.capabilities),\n                \"latency_p95_ms\": entry.stats.latency_p95_ms,\n                \"error_ewma\": entry.stats.error_ewma,\n                \"completeness_deficit\": entry.stats.completeness_deficit,\n                \"health_score\": registry.health_score(name),\n                \"history\": [{\"t\": t, \"h\": h} for (t, h) in entry.h_history],\n            }\n        )\n\n    return {\n        \"policy_version\": settings.policy_version,\n        \"policy\": {\n            \"bars_1m\": settings.POLICY_BARS_1M,\n            \"eod\": settings.POLICY_EOD,\n            \"quotes_l1\": settings.POLICY_QUOTES_L1,\n            \"options_chain\": settings.POLICY_OPTIONS_CHAIN,\n        },\n        \"registered_capabilities\": registry.capabilities_map(),\n        \"providers\": providers,\n    }\n\n\n@app.get(\"/stats/cadence\")\nasync def stats_cadence():\n    \"\"\"Return universe tiering and cadence policy.\"\"\"\n    settings = get_settings()\n    return {\n        \"tiers\": {\"max\": settings.TIER_MAXS},\n        \"cadence\": {\n            \"T0\": settings.CADENCE_T0,\n            \"T1\": settings.CADENCE_T1,\n            \"T2\": settings.CADENCE_T2,\n        },\n        \"use_rlc\": settings.USE_RLC,\n        \"local_sweep\": settings.LOCAL_SWEEP_ENABLED,\n        \"policy_version\": settings.policy_version,\n    }\n\n\n@app.get(\"/ops/cursor/{symbol}/{interval}/{source}\")\nasync def read_cursor(symbol: str, interval: str, source: str):\n    \"\"\"Read ingestion cursor for a symbol/interval/source.\"\"\"\n    from .services.database import db_service\n    ts = await db_service.get_cursor(symbol, interval, source)\n    return {\n        \"symbol\": symbol,\n        \"interval\": interval,\n        \"source\": source,\n        \"last_ts\": ts.isoformat() + \"Z\" if ts else None,\n    }\n\n\n@app.post(\"/ops/backfill\")\nasync def trigger_backfill(payload: dict):\n    \"\"\"\n    Manually trigger a backfill.\n    Payload: {symbol, interval, start, end, priority}\n    \"\"\"\n    from .services.database import db_service\n    req = {**payload}\n    with maybe_trace(f\"backfill_{req.get('symbol', 'unknown')}\"):\n        try:\n            start = datetime.fromisoformat(req[\"start\"].replace(\"Z\", \"\"))\n            end = datetime.fromisoformat(req[\"end\"].replace(\"Z\", \"\"))\n        except Exception:\n            raise HTTPException(400, \"Invalid start/end ISO8601\")\n\n        await db_service.enqueue_backfill(\n            req[\"symbol\"], req.get(\"interval\", \"1m\"), start, end, req.get(\"priority\", \"T2\")\n        )\n        return {\"enqueued\": True}\n\n@app.get(\"/factors/macro\")\nasync def get_macro_factors(factors: Optional[List[str]] = Query(None)):\n    \"\"\"Return snapshot of configured macro factors.\"\"\"\n    return await market_service.get_macro_snapshot(factors)\n\n\n@app.get(\"/factors/macro/{factor_key}/history\")\nasync def get_macro_history_endpoint(factor_key: str, lookback_days: int = 90):\n    \"\"\"Return macro factor history for the specified key.\"\"\"\n    try:\n        return await market_service.get_macro_history(factor_key, lookback_days)\n    except ValueError:\n        raise HTTPException(status_code=404, detail=f\"Unknown macro factor {factor_key.upper()}\")\n\n\n@app.post(\"/admin/macro/refresh\")\nasync def refresh_macro_endpoint(factor: Optional[str] = Query(None)):\n    \"\"\"Trigger a manual macro factor refresh.\"\"\"\n    return await market_service.refresh_macro_factors(factor)\n\n\n@app.get(\"/stocks/{symbol}/price\")\nasync def get_stock_price(symbol: str):\n    \"\"\"Get current stock price\"\"\"\n    with maybe_trace(f\"get_price_{symbol}\"):\n        return await market_service.get_stock_price(symbol.upper())\n\n@app.get(\"/stocks/{symbol}/history\")\nasync def get_historical_data(symbol: str, period: str = \"1mo\"):\n    \"\"\"Get historical stock data\"\"\"\n    with maybe_trace(f\"get_history_{symbol}_{period}\"):\n        return await market_service.get_historical_data(symbol.upper(), period)\n\n\n@app.get(\"/stocks/{symbol}/intraday\")\nasync def get_intraday_data(symbol: str, interval: str = \"1m\"):\n    \"\"\"Get intraday stock data (1-minute bars).\"\"\"\n    return await market_service.get_intraday_data(symbol.upper(), interval)\n\n\n@app.post(\"/stocks/batch\")\nasync def get_multiple_stocks(symbols: List[str]):\n    \"\"\"Get prices for multiple stocks\"\"\"\n    results = []\n    for symbol in symbols:\n        try:\n            data = await market_service.get_stock_price(symbol.upper())\n            results.append({\"status\": \"success\", **data})\n        except Exception as e:\n            results.append({\n                \"status\": \"error\",\n                \"symbol\": symbol.upper(),\n                \"error\": str(e)\n            })\n    return {\"results\": results}\n\n@app.websocket(\"/ws/{symbol}\")\nasync def websocket_endpoint(websocket: WebSocket, symbol: str):\n    \"\"\"WebSocket endpoint for real-time price updates\"\"\"\n    await market_service.connection_manager.connect(websocket, symbol.upper())\n    try:\n        # Send initial data\n        try:\n            initial_data = await market_service.get_stock_price(symbol.upper())\n            await websocket.send_text(json.dumps(initial_data))\n        except:\n            pass\n        \n        # Keep connection alive and handle client messages\n        while True:\n            try:\n                # Wait for client message (ping/pong or subscription changes)\n                message = await asyncio.wait_for(websocket.receive_text(), timeout=30)\n                # Echo back for now (can add subscription management later)\n                await websocket.send_text(json.dumps({\"status\": \"received\", \"message\": message}))\n            except asyncio.TimeoutError:\n                # Send ping to keep connection alive\n                await websocket.send_text(json.dumps({\"type\": \"ping\", \"timestamp\": datetime.now().isoformat()}))\n            except Exception as e:\n                logger.error(f\"WebSocket error: {e}\")\n                break\n    except WebSocketDisconnect:\n        logger.info(f\"Client disconnected from {symbol}\")\n    finally:\n        market_service.connection_manager.disconnect(websocket)\n\n\ndef _find_contract(contracts: List[OptionContract], target_symbol: Optional[str]) -> Optional[OptionContract]:\n    if not target_symbol:\n        return None\n    for contract in contracts:\n        if contract.symbol == target_symbol:\n            return contract\n    return None\n\n\nasync def _options_chain_payload(symbol: str) -> Tuple[Dict[str, Any], OptionsChain]:\n    \"\"\"Fetch the latest options chain and return a summary payload.\"\"\"\n    chain = await options_service.fetch_options_chain(symbol)\n    total_calls = len(chain.calls)\n    total_puts = len(chain.puts)\n    expiries = [exp.isoformat() for exp in chain.expiries]\n\n    return {\n        \"type\": \"options_chain\",\n        \"symbol\": symbol,\n        \"underlying_price\": chain.underlying_price,\n        \"timestamp\": datetime.now().isoformat(),\n        \"calls\": total_calls,\n        \"puts\": total_puts,\n        \"expiries\": expiries,\n    }, chain\n\n\ndef _options_update_payload(symbol: str, chain: OptionsChain, metrics) -> Dict[str, Any]:\n    \"\"\"Build a payload for incremental options metrics updates.\"\"\"\n    call_volume = metrics.call_volume or 0\n    put_volume = metrics.put_volume or 0\n    total_volume = call_volume + put_volume\n    volume_ratio = (call_volume / put_volume) if put_volume else None\n    iv_rank = metrics.metadata.get(\"iv_rank\")\n\n    atm_call_symbol = metrics.metadata.get(\"atm_call\")\n    atm_put_symbol = metrics.metadata.get(\"atm_put\")\n    atm_call = _find_contract(chain.calls, atm_call_symbol)\n    atm_put = _find_contract(chain.puts, atm_put_symbol)\n\n    if iv_rank is None and metrics.atm_iv is not None:\n        iv_rank = max(0.0, min(100.0, metrics.atm_iv * 100))\n\n    return {\n        \"type\": \"options_update\",\n        \"symbol\": symbol,\n        \"underlying_price\": chain.underlying_price,\n        \"timestamp\": datetime.now().isoformat(),\n        \"iv_rank\": iv_rank,\n        \"atm_call_iv\": (atm_call.implied_volatility if atm_call else metrics.atm_iv),\n        \"atm_put_iv\": (atm_put.implied_volatility if atm_put else metrics.atm_iv),\n        \"volume_ratio\": volume_ratio,\n        \"total_volume\": total_volume,\n    }\n\n\nasync def _options_consumer(websocket: WebSocket):\n    \"\"\"Listen for client messages to keep the WebSocket alive.\"\"\"\n    try:\n        while True:\n            message = await websocket.receive_text()\n            if message.strip().lower() == \"ping\":\n                await websocket.send_text(json.dumps({\"type\": \"pong\", \"timestamp\": datetime.now().isoformat()}))\n    except WebSocketDisconnect:\n        raise\n    except Exception as exc:\n        logger.error(\"Options WebSocket consumer error: %s\", exc)\n\n\nasync def _options_producer(websocket: WebSocket, symbol: str, interval: int):\n    \"\"\"Continuously push options updates to the client.\"\"\"\n    try:\n        chain_payload, chain = await _options_chain_payload(symbol)\n    except Exception as exc:\n        logger.error(\"Error fetching initial options chain for %s: %s\", symbol, exc)\n        await websocket.send_text(\n            json.dumps(\n                {\n                    \"type\": \"options_error\",\n                    \"symbol\": symbol,\n                    \"timestamp\": datetime.now().isoformat(),\n                    \"error\": \"Failed to load options chain\",\n                }\n            )\n        )\n        raise\n\n    await websocket.send_text(json.dumps(chain_payload))\n\n    async def send_update(current_chain: OptionsChain):\n        try:\n            metrics = options_service.calculate_chain_metrics(current_chain)\n            update = _options_update_payload(symbol, current_chain, metrics)\n            await websocket.send_text(json.dumps(update))\n        except Exception as exc:\n            logger.error(\"Error generating options update for %s: %s\", symbol, exc)\n            await websocket.send_text(\n                json.dumps(\n                    {\n                        \"type\": \"options_error\",\n                        \"symbol\": symbol,\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"error\": \"Failed to generate options update\",\n                    }\n                )\n            )\n\n    # Send initial metrics right away\n    await send_update(chain)\n\n    refresh_interval = max(1, interval)\n    while True:\n        await asyncio.sleep(refresh_interval)\n        try:\n            chain = await options_service.fetch_options_chain(symbol)\n        except Exception as exc:\n            logger.error(\"Error refreshing options chain for %s: %s\", symbol, exc)\n            await websocket.send_text(\n                json.dumps(\n                    {\n                        \"type\": \"options_error\",\n                        \"symbol\": symbol,\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"error\": \"Failed to refresh options chain\",\n                    }\n                )\n            )\n            continue\n\n        await send_update(chain)\n\n\nasync def _handle_options_websocket(websocket: WebSocket, symbol: Optional[str]):\n    \"\"\"Shared handler for options WebSocket connections with symbol from path or query.\"\"\"\n    if not symbol:\n        symbol = websocket.query_params.get(\"symbol\")\n    if not symbol:\n        await websocket.accept()\n        await websocket.send_text(json.dumps({\"type\": \"error\", \"error\": \"symbol query parameter is required\"}))\n        await websocket.close(code=4400)\n        return\n\n    symbol = symbol.upper()\n    await websocket.accept()\n\n    interval = getattr(market_service, \"update_interval\", 5)\n    consumer_task = asyncio.create_task(_options_consumer(websocket))\n    producer_task = asyncio.create_task(_options_producer(websocket, symbol, interval))\n\n    try:\n        done, pending = await asyncio.wait(\n            [consumer_task, producer_task],\n            return_when=asyncio.FIRST_EXCEPTION,\n        )\n        for task in done:\n            exc = task.exception()\n            if exc and not isinstance(exc, WebSocketDisconnect):\n                logger.error(\"Options WebSocket task error for %s: %s\", symbol, exc)\n    except WebSocketDisconnect:\n        logger.info(\"Options WebSocket client disconnected for %s\", symbol)\n    finally:\n        for task in (consumer_task, producer_task):\n            task.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await task\n        with contextlib.suppress(Exception):\n            await websocket.close()\n\n\n@app.websocket(\"/ws/options\")\nasync def options_websocket_query(websocket: WebSocket):\n    \"\"\"Options WebSocket endpoint using symbol query parameter.\"\"\"\n    await _handle_options_websocket(websocket, None)\n\n\n@app.websocket(\"/ws/options/{symbol}\")\nasync def options_websocket_path(websocket: WebSocket, symbol: str):\n    \"\"\"Options WebSocket endpoint with symbol in the path.\"\"\"\n    await _handle_options_websocket(websocket, symbol)\n\n\n@app.get(\"/options/{symbol}/chain\")\nasync def get_options_chain(symbol: str):\n    \"\"\"Return the full options chain for a symbol.\"\"\"\n    with maybe_trace(f\"get_options_chain_{symbol}\"):\n        try:\n            chain = await options_service.fetch_options_chain(symbol.upper())\n        except Exception as exc:\n            logger.error(\"Error fetching options chain for %s: %s\", symbol, exc)\n            raise HTTPException(status_code=502, detail=f\"Unable to fetch options chain for {symbol.upper()}\") from exc\n\n        return jsonable_encoder(chain)\n\n\ndef _validate_sentiment(sentiment: str, allowed: List[str]) -> str:\n    normalized = (sentiment or \"all\").lower()\n    if normalized not in allowed:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid sentiment '{sentiment}'. Expected one of {', '.join(allowed)}.\",\n        )\n    return normalized\n\n\ndef _validate_complexity(complexity: str, allowed: List[str]) -> str:\n    normalized = (complexity or \"all\").lower()\n    if normalized not in allowed:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid complexity '{complexity}'. Expected one of {', '.join(allowed)}.\",\n        )\n    return normalized\n\n\n@app.get(\"/options/{symbol}/strategies\")\nasync def get_options_strategies(\n    symbol: str,\n    sentiment: str = Query(\"all\", description=\"Filter by sentiment: bullish, bearish, neutral, or all\"),\n    complexity: str = Query(\"all\", description=\"Filter by complexity: beginner, intermediate, advanced, or all\"),\n):\n    \"\"\"Return advanced options strategies derived from the options chain.\"\"\"\n    sentiment_normalized = _validate_sentiment(sentiment, [\"bullish\", \"bearish\", \"neutral\", \"all\"])\n    complexity_normalized = _validate_complexity(complexity, [\"beginner\", \"intermediate\", \"advanced\", \"all\"])\n\n    try:\n        strategies = await options_service.get_advanced_strategies(\n            symbol.upper(), sentiment=sentiment_normalized, complexity=complexity_normalized\n        )\n    except Exception as exc:\n        logger.error(\"Error generating strategies for %s: %s\", symbol, exc)\n        raise HTTPException(status_code=502, detail=f\"Unable to generate strategies for {symbol.upper()}\") from exc\n\n    payload = {\"symbol\": symbol.upper(), \"count\": len(strategies), \"strategies\": strategies}\n    return jsonable_encoder(payload)\n\n\n@app.get(\"/options/{symbol}/suggestions\")\nasync def get_options_suggestions(\n    symbol: str,\n    sentiment: str = Query(\"bullish\", description=\"Trading bias for suggestions\"),\n    target_delta: float = Query(0.3, ge=0, le=1, description=\"Approximate option delta to target\"),\n    max_dte: int = Query(7, ge=1, le=60, description=\"Maximum days to expiration\"),\n    min_liquidity: float = Query(50, ge=0, le=100, description=\"Minimum liquidity score threshold\"),\n):\n    \"\"\"Return tailored day-trading suggestions built from the options chain.\"\"\"\n    sentiment_normalized = _validate_sentiment(sentiment, [\"bullish\", \"bearish\", \"neutral\"])\n\n    try:\n        chain = await options_service.fetch_options_chain(symbol.upper())\n        suggestions = options_service.suggest_day_trade(\n            symbol.upper(),\n            sentiment_normalized,\n            chain.underlying_price,\n            target_delta=target_delta,\n            max_dte=max_dte,\n            min_liquidity=min_liquidity,\n        )\n    except Exception as exc:\n        logger.error(\"Error generating suggestions for %s: %s\", symbol, exc)\n        raise HTTPException(status_code=502, detail=f\"Unable to generate suggestions for {symbol.upper()}\") from exc\n\n    if not suggestions:\n        raise HTTPException(\n            status_code=404,\n            detail=f\"No trade suggestions available for {symbol.upper()} with current filters\",\n        )\n\n    payload = {\n        \"symbol\": symbol.upper(),\n        \"underlying_price\": chain.underlying_price,\n        \"suggestions\": suggestions,\n    }\n    return jsonable_encoder(payload)\n\n\n@app.get(\"/options/{symbol}/metrics\")\nasync def get_options_metrics_endpoint(symbol: str):\n    \"\"\"Return latest ATM IV, skew, and implied move metrics.\"\"\"\n    with maybe_trace(f\"get_options_metrics_{symbol}\"):\n        return await market_service.get_options_metrics(symbol.upper())\n\n\n@app.get(\"/options/{symbol}/metrics/history\")\nasync def get_options_metrics_history_endpoint(symbol: str, limit: int = 50):\n    \"\"\"Return historical options metrics records.\"\"\"\n    history = await market_service.get_options_metrics_history(symbol.upper(), limit)\n    return {\"symbol\": symbol.upper(), \"metrics\": history}\n\n@app.get(\"/options/{symbol}/unusual\")\nasync def get_unusual_options_activity_endpoint(\n    symbol: str, \n    lookback_days: int = Query(20, ge=1, le=90, description=\"Days to look back for unusual activity\")\n):\n    \"\"\"Detect and return unusual options activity for a symbol\"\"\"\n    return await market_service.get_unusual_options_activity(symbol.upper(), lookback_days)\n\n@app.get(\"/options/{symbol}/flow\")\nasync def get_options_flow_analysis_endpoint(symbol: str):\n    \"\"\"Get comprehensive options flow analysis including unusual activity and smart money signals\"\"\"\n    return await market_service.get_options_flow_analysis(symbol.upper())\n\n@app.get(\"/stocks/{symbol}/profile\")\nasync def get_company_profile(symbol: str):\n    \"\"\"Get company profile data\"\"\"\n    with maybe_trace(f\"get_profile_{symbol}\"):\n        return await market_service.get_company_profile(symbol.upper())\n\n@app.get(\"/stocks/{symbol}/sentiment\")\nasync def get_news_sentiment(symbol: str):\n    \"\"\"Get news sentiment data\"\"\"\n    return await market_service.get_news_sentiment(symbol.upper())\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\n        app,\n        host=\"0.0.0.0\",\n        port=8001,\n        log_level=\"info\",\n        reload=True\n    )\n\n", 616], "/usr/local/lib/python3.11/site-packages/fastapi/routing.py": ["import dataclasses\nimport email.message\nimport functools\nimport inspect\nimport json\nimport sys\nfrom contextlib import AsyncExitStack, asynccontextmanager\nfrom enum import Enum, IntEnum\nfrom typing import (\n    Any,\n    AsyncIterator,\n    Awaitable,\n    Callable,\n    Collection,\n    Coroutine,\n    Dict,\n    List,\n    Mapping,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    Type,\n    Union,\n)\n\nfrom fastapi import params\nfrom fastapi._compat import (\n    ModelField,\n    Undefined,\n    _get_model_config,\n    _model_dump,\n    _normalize_errors,\n    lenient_issubclass,\n)\nfrom fastapi.datastructures import Default, DefaultPlaceholder\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    _should_embed_body_fields,\n    get_body_field,\n    get_dependant,\n    get_flat_dependant,\n    get_parameterless_sub_dependant,\n    get_typed_return_annotation,\n    solve_dependencies,\n)\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.exceptions import (\n    FastAPIError,\n    RequestValidationError,\n    ResponseValidationError,\n    WebSocketRequestValidationError,\n)\nfrom fastapi.types import DecoratedCallable, IncEx\nfrom fastapi.utils import (\n    create_cloned_field,\n    create_model_field,\n    generate_unique_id,\n    get_value_or_default,\n    is_body_allowed_for_status_code,\n)\nfrom pydantic import BaseModel\nfrom starlette import routing\nfrom starlette._exception_handler import wrap_app_handling_exceptions\nfrom starlette._utils import is_async_callable\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import (\n    BaseRoute,\n    Match,\n    compile_path,\n    get_name,\n)\nfrom starlette.routing import Mount as Mount  # noqa\nfrom starlette.types import AppType, ASGIApp, Lifespan, Receive, Scope, Send\nfrom starlette.websockets import WebSocket\nfrom typing_extensions import Annotated, Doc, deprecated\n\nif sys.version_info >= (3, 13):  # pragma: no cover\n    from inspect import iscoroutinefunction\nelse:  # pragma: no cover\n    from asyncio import iscoroutinefunction\n\n\n# Copy of starlette.routing.request_response modified to include the\n# dependencies' AsyncExitStack\ndef request_response(\n    func: Callable[[Request], Union[Awaitable[Response], Response]],\n) -> ASGIApp:\n    \"\"\"\n    Takes a function or coroutine `func(request) -> response`,\n    and returns an ASGI application.\n    \"\"\"\n    f: Callable[[Request], Awaitable[Response]] = (\n        func if is_async_callable(func) else functools.partial(run_in_threadpool, func)  # type:ignore\n    )\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive, send)\n\n        async def app(scope: Scope, receive: Receive, send: Send) -> None:\n            # Starts customization\n            response_awaited = False\n            async with AsyncExitStack() as stack:\n                scope[\"fastapi_inner_astack\"] = stack\n                # Same as in Starlette\n                response = await f(request)\n                await response(scope, receive, send)\n                # Continues customization\n                response_awaited = True\n            if not response_awaited:\n                raise FastAPIError(\n                    \"Response not awaited. There's a high chance that the \"\n                    \"application code is raising an exception and a dependency with yield \"\n                    \"has a block with a bare except, or a block with except Exception, \"\n                    \"and is not raising the exception again. Read more about it in the \"\n                    \"docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except\"\n                )\n\n        # Same as in Starlette\n        await wrap_app_handling_exceptions(app, request)(scope, receive, send)\n\n    return app\n\n\n# Copy of starlette.routing.websocket_session modified to include the\n# dependencies' AsyncExitStack\ndef websocket_session(\n    func: Callable[[WebSocket], Awaitable[None]],\n) -> ASGIApp:\n    \"\"\"\n    Takes a coroutine `func(session)`, and returns an ASGI application.\n    \"\"\"\n    # assert asyncio.iscoroutinefunction(func), \"WebSocket endpoints must be async\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        session = WebSocket(scope, receive=receive, send=send)\n\n        async def app(scope: Scope, receive: Receive, send: Send) -> None:\n            # Starts customization\n            async with AsyncExitStack() as stack:\n                scope[\"fastapi_inner_astack\"] = stack\n                # Same as in Starlette\n                await func(session)\n\n        # Same as in Starlette\n        await wrap_app_handling_exceptions(app, session)(scope, receive, send)\n\n    return app\n\n\ndef _prepare_response_content(\n    res: Any,\n    *,\n    exclude_unset: bool,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -> Any:\n    if isinstance(res, BaseModel):\n        read_with_orm_mode = getattr(_get_model_config(res), \"read_with_orm_mode\", None)\n        if read_with_orm_mode:\n            # Let from_orm extract the data from this model instead of converting\n            # it now to a dict.\n            # Otherwise, there's no way to extract lazy data that requires attribute\n            # access instead of dict iteration, e.g. lazy relationships.\n            return res\n        return _model_dump(\n            res,\n            by_alias=True,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    elif isinstance(res, list):\n        return [\n            _prepare_response_content(\n                item,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for item in res\n        ]\n    elif isinstance(res, dict):\n        return {\n            k: _prepare_response_content(\n                v,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for k, v in res.items()\n        }\n    elif dataclasses.is_dataclass(res):\n        assert not isinstance(res, type)\n        return dataclasses.asdict(res)\n    return res\n\n\ndef _merge_lifespan_context(\n    original_context: Lifespan[Any], nested_context: Lifespan[Any]\n) -> Lifespan[Any]:\n    @asynccontextmanager\n    async def merged_lifespan(\n        app: AppType,\n    ) -> AsyncIterator[Optional[Mapping[str, Any]]]:\n        async with original_context(app) as maybe_original_state:\n            async with nested_context(app) as maybe_nested_state:\n                if maybe_nested_state is None and maybe_original_state is None:\n                    yield None  # old ASGI compatibility\n                else:\n                    yield {**(maybe_nested_state or {}), **(maybe_original_state or {})}\n\n    return merged_lifespan  # type: ignore[return-value]\n\n\nasync def serialize_response(\n    *,\n    field: Optional[ModelField] = None,\n    response_content: Any,\n    include: Optional[IncEx] = None,\n    exclude: Optional[IncEx] = None,\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    is_coroutine: bool = True,\n) -> Any:\n    if field:\n        errors = []\n        if not hasattr(field, \"serialize\"):\n            # pydantic v1\n            response_content = _prepare_response_content(\n                response_content,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n        if is_coroutine:\n            value, errors_ = field.validate(response_content, {}, loc=(\"response\",))\n        else:\n            value, errors_ = await run_in_threadpool(\n                field.validate, response_content, {}, loc=(\"response\",)\n            )\n        if isinstance(errors_, list):\n            errors.extend(errors_)\n        elif errors_:\n            errors.append(errors_)\n        if errors:\n            raise ResponseValidationError(\n                errors=_normalize_errors(errors), body=response_content\n            )\n\n        if hasattr(field, \"serialize\"):\n            return field.serialize(\n                value,\n                include=include,\n                exclude=exclude,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    else:\n        return jsonable_encoder(response_content)\n\n\nasync def run_endpoint_function(\n    *, dependant: Dependant, values: Dict[str, Any], is_coroutine: bool\n) -> Any:\n    # Only called by get_request_handler. Has been split into its own function to\n    # facilitate profiling endpoints, since inner functions are harder to profile.\n    assert dependant.call is not None, \"dependant.call must be a function\"\n\n    if is_coroutine:\n        return await dependant.call(**values)\n    else:\n        return await run_in_threadpool(dependant.call, **values)\n\n\ndef get_request_handler(\n    dependant: Dependant,\n    body_field: Optional[ModelField] = None,\n    status_code: Optional[int] = None,\n    response_class: Union[Type[Response], DefaultPlaceholder] = Default(JSONResponse),\n    response_field: Optional[ModelField] = None,\n    response_model_include: Optional[IncEx] = None,\n    response_model_exclude: Optional[IncEx] = None,\n    response_model_by_alias: bool = True,\n    response_model_exclude_unset: bool = False,\n    response_model_exclude_defaults: bool = False,\n    response_model_exclude_none: bool = False,\n    dependency_overrides_provider: Optional[Any] = None,\n    embed_body_fields: bool = False,\n) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.field_info, params.Form)\n    if isinstance(response_class, DefaultPlaceholder):\n        actual_response_class: Type[Response] = response_class.value\n    else:\n        actual_response_class = response_class\n\n    async def app(request: Request) -> Response:\n        response: Union[Response, None] = None\n        file_stack = request.scope.get(\"fastapi_middleware_astack\")\n        assert isinstance(file_stack, AsyncExitStack), (\n            \"fastapi_middleware_astack not found in request scope\"\n        )\n\n        # Read body and auto-close files\n        try:\n            body: Any = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                    file_stack.push_async_callback(body.close)\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        json_body: Any = Undefined\n                        content_type_value = request.headers.get(\"content-type\")\n                        if not content_type_value:\n                            json_body = await request.json()\n                        else:\n                            message = email.message.Message()\n                            message[\"content-type\"] = content_type_value\n                            if message.get_content_maintype() == \"application\":\n                                subtype = message.get_content_subtype()\n                                if subtype == \"json\" or subtype.endswith(\"+json\"):\n                                    json_body = await request.json()\n                        if json_body != Undefined:\n                            body = json_body\n                        else:\n                            body = body_bytes\n        except json.JSONDecodeError as e:\n            validation_error = RequestValidationError(\n                [\n                    {\n                        \"type\": \"json_invalid\",\n                        \"loc\": (\"body\", e.pos),\n                        \"msg\": \"JSON decode error\",\n                        \"input\": {},\n                        \"ctx\": {\"error\": e.msg},\n                    }\n                ],\n                body=e.doc,\n            )\n            raise validation_error from e\n        except HTTPException:\n            # If a middleware raises an HTTPException, it should be raised again\n            raise\n        except Exception as e:\n            http_error = HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            )\n            raise http_error from e\n\n        # Solve dependencies and run path operation function, auto-closing dependencies\n        errors: List[Any] = []\n        async_exit_stack = request.scope.get(\"fastapi_inner_astack\")\n        assert isinstance(async_exit_stack, AsyncExitStack), (\n            \"fastapi_inner_astack not found in request scope\"\n        )\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n            async_exit_stack=async_exit_stack,\n            embed_body_fields=embed_body_fields,\n        )\n        errors = solved_result.errors\n        if not errors:\n            raw_response = await run_endpoint_function(\n                dependant=dependant,\n                values=solved_result.values,\n                is_coroutine=is_coroutine,\n            )\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = solved_result.background_tasks\n                response = raw_response\n            else:\n                response_args: Dict[str, Any] = {\n                    \"background\": solved_result.background_tasks\n                }\n                # If status_code was set, use it, otherwise use the default from the\n                # response class, in the case of redirect it's 307\n                current_status_code = (\n                    status_code if status_code else solved_result.response.status_code\n                )\n                if current_status_code is not None:\n                    response_args[\"status_code\"] = current_status_code\n                if solved_result.response.status_code:\n                    response_args[\"status_code\"] = solved_result.response.status_code\n                content = await serialize_response(\n                    field=response_field,\n                    response_content=raw_response,\n                    include=response_model_include,\n                    exclude=response_model_exclude,\n                    by_alias=response_model_by_alias,\n                    exclude_unset=response_model_exclude_unset,\n                    exclude_defaults=response_model_exclude_defaults,\n                    exclude_none=response_model_exclude_none,\n                    is_coroutine=is_coroutine,\n                )\n                response = actual_response_class(content, **response_args)\n                if not is_body_allowed_for_status_code(response.status_code):\n                    response.body = b\"\"\n                response.headers.raw.extend(solved_result.response.headers.raw)\n        if errors:\n            validation_error = RequestValidationError(\n                _normalize_errors(errors), body=body\n            )\n            raise validation_error\n\n        # Return response\n        assert response\n        return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n    embed_body_fields: bool = False,\n) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:\n    async def app(websocket: WebSocket) -> None:\n        async_exit_stack = websocket.scope.get(\"fastapi_inner_astack\")\n        assert isinstance(async_exit_stack, AsyncExitStack), (\n            \"fastapi_inner_astack not found in request scope\"\n        )\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n            async_exit_stack=async_exit_stack,\n            embed_body_fields=embed_body_fields,\n        )\n        if solved_result.errors:\n            raise WebSocketRequestValidationError(\n                _normalize_errors(solved_result.errors)\n            )\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**solved_result.values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        name: Optional[str] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        dependency_overrides_provider: Optional[Any] = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependencies = list(dependencies or [])\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self._flat_dependant = get_flat_dependant(self.dependant)\n        self._embed_body_fields = _should_embed_body_fields(\n            self._flat_dependant.body_params\n        )\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n                embed_body_fields=self._embed_body_fields,\n            )\n        )\n\n    def matches(self, scope: Scope) -> Tuple[Match, Scope]:\n        match, child_scope = super().matches(scope)\n        if match != Match.NONE:\n            child_scope[\"route\"] = self\n        return match, child_scope\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        name: Optional[str] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        dependency_overrides_provider: Optional[Any] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Union[\n            Callable[[\"APIRoute\"], str], DefaultPlaceholder\n        ] = Default(generate_unique_id),\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        if isinstance(response_model, DefaultPlaceholder):\n            return_annotation = get_typed_return_annotation(endpoint)\n            if lenient_issubclass(return_annotation, Response):\n                response_model = None\n            else:\n                response_model = return_annotation\n        self.response_model = response_model\n        self.summary = summary\n        self.response_description = response_description\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_exclude_unset = response_model_exclude_unset\n        self.response_model_exclude_defaults = response_model_exclude_defaults\n        self.response_model_exclude_none = response_model_exclude_none\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.callbacks = callbacks\n        self.openapi_extra = openapi_extra\n        self.generate_unique_id_function = generate_unique_id_function\n        self.tags = tags or []\n        self.responses = responses or {}\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods: Set[str] = {method.upper() for method in methods}\n        if isinstance(generate_unique_id_function, DefaultPlaceholder):\n            current_generate_unique_id: Callable[[APIRoute], str] = (\n                generate_unique_id_function.value\n            )\n        else:\n            current_generate_unique_id = generate_unique_id_function\n        self.unique_id = self.operation_id or current_generate_unique_id(self)\n        # normalize enums e.g. http.HTTPStatus\n        if isinstance(status_code, IntEnum):\n            status_code = int(status_code)\n        self.status_code = status_code\n        if self.response_model:\n            assert is_body_allowed_for_status_code(status_code), (\n                f\"Status code {status_code} must not have a response body\"\n            )\n            response_name = \"Response_\" + self.unique_id\n            self.response_field = create_model_field(\n                name=response_name,\n                type_=self.response_model,\n                mode=\"serialization\",\n            )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will always be created.\n            # TODO: remove when deprecating Pydantic v1\n            self.secure_cloned_response_field: Optional[ModelField] = (\n                create_cloned_field(self.response_field)\n            )\n        else:\n            self.response_field = None  # type: ignore\n            self.secure_cloned_response_field = None\n        self.dependencies = list(dependencies or [])\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        # if a \"form feed\" character (page break) is found in the description text,\n        # truncate description text to the content preceding the first \"form feed\"\n        self.description = self.description.split(\"\\f\")[0].strip()\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert is_body_allowed_for_status_code(additional_status_code), (\n                    f\"Status code {additional_status_code} must not have a response body\"\n                )\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                response_field = create_model_field(\n                    name=response_name, type_=model, mode=\"serialization\"\n                )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], ModelField] = response_fields\n        else:\n            self.response_fields = {}\n\n        assert callable(endpoint), \"An endpoint must be a callable\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self._flat_dependant = get_flat_dependant(self.dependant)\n        self._embed_body_fields = _should_embed_body_fields(\n            self._flat_dependant.body_params\n        )\n        self.body_field = get_body_field(\n            flat_dependant=self._flat_dependant,\n            name=self.unique_id,\n            embed_body_fields=self._embed_body_fields,\n        )\n        self.app = request_response(self.get_route_handler())\n\n    def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n        return get_request_handler(\n            dependant=self.dependant,\n            body_field=self.body_field,\n            status_code=self.status_code,\n            response_class=self.response_class,\n            response_field=self.secure_cloned_response_field,\n            response_model_include=self.response_model_include,\n            response_model_exclude=self.response_model_exclude,\n            response_model_by_alias=self.response_model_by_alias,\n            response_model_exclude_unset=self.response_model_exclude_unset,\n            response_model_exclude_defaults=self.response_model_exclude_defaults,\n            response_model_exclude_none=self.response_model_exclude_none,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            embed_body_fields=self._embed_body_fields,\n        )\n\n    def matches(self, scope: Scope) -> Tuple[Match, Scope]:\n        match, child_scope = super().matches(scope)\n        if match != Match.NONE:\n            child_scope[\"route\"] = self\n        return match, child_scope\n\n\nclass APIRouter(routing.Router):\n    \"\"\"\n    `APIRouter` class, used to group *path operations*, for example to structure\n    an app in multiple files. It would then be included in the `FastAPI` app, or\n    in another `APIRouter` (ultimately included in the app).\n\n    Read more about it in the\n    [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n    ## Example\n\n    ```python\n    from fastapi import APIRouter, FastAPI\n\n    app = FastAPI()\n    router = APIRouter()\n\n\n    @router.get(\"/users/\", tags=[\"users\"])\n    async def read_users():\n        return [{\"username\": \"Rick\"}, {\"username\": \"Morty\"}]\n\n\n    app.include_router(router)\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        prefix: Annotated[str, Doc(\"An optional path prefix for the router.\")] = \"\",\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to all the *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to all the\n                *path operations* in this router.\n\n                Read more about it in the\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        default_response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                The default response class to be used.\n\n                Read more in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses to be shown in OpenAPI.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\n\n                And in the\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                OpenAPI callbacks that should apply to all *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        routes: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                **Note**: you probably shouldn't use this parameter, it is inherited\n                from Starlette and supported for compatibility.\n\n                ---\n\n                A list of routes to serve incoming HTTP and WebSocket requests.\n                \"\"\"\n            ),\n            deprecated(\n                \"\"\"\n                You normally wouldn't use this parameter with FastAPI, it is inherited\n                from Starlette and supported for compatibility.\n\n                In FastAPI, you normally would use the *path operation methods*,\n                like `router.get()`, `router.post()`, etc.\n                \"\"\"\n            ),\n        ] = None,\n        redirect_slashes: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Whether to detect and redirect slashes in URLs when the client doesn't\n                use the same format.\n                \"\"\"\n            ),\n        ] = True,\n        default: Annotated[\n            Optional[ASGIApp],\n            Doc(\n                \"\"\"\n                Default function handler for this router. Used to handle\n                404 Not Found errors.\n                \"\"\"\n            ),\n        ] = None,\n        dependency_overrides_provider: Annotated[\n            Optional[Any],\n            Doc(\n                \"\"\"\n                Only used internally by FastAPI to handle dependency overrides.\n\n                You shouldn't need to use it. It normally points to the `FastAPI` app\n                object.\n                \"\"\"\n            ),\n        ] = None,\n        route_class: Annotated[\n            Type[APIRoute],\n            Doc(\n                \"\"\"\n                Custom route (*path operation*) class to be used by this router.\n\n                Read more about it in the\n                [FastAPI docs for Custom Request and APIRoute class](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router).\n                \"\"\"\n            ),\n        ] = APIRoute,\n        on_startup: Annotated[\n            Optional[Sequence[Callable[[], Any]]],\n            Doc(\n                \"\"\"\n                A list of startup event handler functions.\n\n                You should instead use the `lifespan` handlers.\n\n                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        on_shutdown: Annotated[\n            Optional[Sequence[Callable[[], Any]]],\n            Doc(\n                \"\"\"\n                A list of shutdown event handler functions.\n\n                You should instead use the `lifespan` handlers.\n\n                Read more in the\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        # the generic to Lifespan[AppType] is the type of the top level application\n        # which the router cannot know statically, so we use typing.Any\n        lifespan: Annotated[\n            Optional[Lifespan[Any]],\n            Doc(\n                \"\"\"\n                A `Lifespan` context manager handler. This replaces `startup` and\n                `shutdown` functions with a single context manager.\n\n                Read more in the\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark all *path operations* in this router as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                To include (or not) all the *path operations* in this router in the\n                generated OpenAPI.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> None:\n        super().__init__(\n            routes=routes,\n            redirect_slashes=redirect_slashes,\n            default=default,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n            lifespan=lifespan,\n        )\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\"/\"), (\n                \"A path prefix must not end with '/', as the routes will start with '/'\"\n            )\n        self.prefix = prefix\n        self.tags: List[Union[str, Enum]] = tags or []\n        self.dependencies = list(dependencies or [])\n        self.deprecated = deprecated\n        self.include_in_schema = include_in_schema\n        self.responses = responses or {}\n        self.callbacks = callbacks or []\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.route_class = route_class\n        self.default_response_class = default_response_class\n        self.generate_unique_id_function = generate_unique_id_function\n\n    def route(\n        self,\n        path: str,\n        methods: Optional[Collection[str]] = None,\n        name: Optional[str] = None,\n        include_in_schema: bool = True,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_route(\n                path,\n                func,\n                methods=methods,\n                name=name,\n                include_in_schema=include_in_schema,\n            )\n            return func\n\n        return decorator\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        route_class_override: Optional[Type[APIRoute]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Union[\n            Callable[[APIRoute], str], DefaultPlaceholder\n        ] = Default(generate_unique_id),\n    ) -> None:\n        route_class = route_class_override or self.route_class\n        responses = responses or {}\n        combined_responses = {**self.responses, **responses}\n        current_response_class = get_value_or_default(\n            response_class, self.default_response_class\n        )\n        current_tags = self.tags.copy()\n        if tags:\n            current_tags.extend(tags)\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n        current_callbacks = self.callbacks.copy()\n        if callbacks:\n            current_callbacks.extend(callbacks)\n        current_generate_unique_id = get_value_or_default(\n            generate_unique_id_function, self.generate_unique_id_function\n        )\n        route = route_class(\n            self.prefix + path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=current_tags,\n            dependencies=current_dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=combined_responses,\n            deprecated=deprecated or self.deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema and self.include_in_schema,\n            response_class=current_response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            callbacks=current_callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=current_generate_unique_id,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Callable[[APIRoute], str] = Default(\n            generate_unique_id\n        ),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n                openapi_extra=openapi_extra,\n                generate_unique_id_function=generate_unique_id_function,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        name: Optional[str] = None,\n        *,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n    ) -> None:\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n\n        route = APIWebSocketRoute(\n            self.prefix + path,\n            endpoint=endpoint,\n            name=name,\n            dependencies=current_dependencies,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)\n\n    def websocket(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                WebSocket path.\n                \"\"\"\n            ),\n        ],\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A name for the WebSocket. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        *,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be used for this\n                WebSocket.\n\n                Read more about it in the\n                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n                \"\"\"\n            ),\n        ] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Decorate a WebSocket function.\n\n        Read more about it in the\n        [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n        **Example**\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI, WebSocket\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.websocket(\"/ws\")\n        async def websocket_endpoint(websocket: WebSocket):\n            await websocket.accept()\n            while True:\n                data = await websocket.receive_text()\n                await websocket.send_text(f\"Message text was: {data}\")\n\n        app.include_router(router)\n        ```\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(\n                path, func, name=name, dependencies=dependencies\n            )\n            return func\n\n        return decorator\n\n    def websocket_route(\n        self, path: str, name: Union[str, None] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: Annotated[\"APIRouter\", Doc(\"The `APIRouter` to include.\")],\n        *,\n        prefix: Annotated[str, Doc(\"An optional path prefix for the router.\")] = \"\",\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to all the *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to all the\n                *path operations* in this router.\n\n                Read more about it in the\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        default_response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                The default response class to be used.\n\n                Read more in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses to be shown in OpenAPI.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\n\n                And in the\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                OpenAPI callbacks that should apply to all *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark all *path operations* in this router as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include (or not) all the *path operations* in this router in the\n                generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = True,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> None:\n        \"\"\"\n        Include another `APIRouter` in the same current `APIRouter`.\n\n        Read more about it in the\n        [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n\n        app = FastAPI()\n        internal_router = APIRouter()\n        users_router = APIRouter()\n\n        @users_router.get(\"/users/\")\n        def read_users():\n            return [{\"name\": \"Rick\"}, {\"name\": \"Morty\"}]\n\n        internal_router.include_router(users_router)\n        app.include_router(internal_router)\n        ```\n        \"\"\"\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\"/\"), (\n                \"A path prefix must not end with '/', as the routes will start with '/'\"\n            )\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")  # noqa: B009\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise FastAPIError(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                use_response_class = get_value_or_default(\n                    route.response_class,\n                    router.default_response_class,\n                    default_response_class,\n                    self.default_response_class,\n                )\n                current_tags = []\n                if tags:\n                    current_tags.extend(tags)\n                if route.tags:\n                    current_tags.extend(route.tags)\n                current_dependencies: List[params.Depends] = []\n                if dependencies:\n                    current_dependencies.extend(dependencies)\n                if route.dependencies:\n                    current_dependencies.extend(route.dependencies)\n                current_callbacks = []\n                if callbacks:\n                    current_callbacks.extend(callbacks)\n                if route.callbacks:\n                    current_callbacks.extend(route.callbacks)\n                current_generate_unique_id = get_value_or_default(\n                    route.generate_unique_id_function,\n                    router.generate_unique_id_function,\n                    generate_unique_id_function,\n                    self.generate_unique_id_function,\n                )\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=current_tags,\n                    dependencies=current_dependencies,\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated or deprecated or self.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_exclude_unset=route.response_model_exclude_unset,\n                    response_model_exclude_defaults=route.response_model_exclude_defaults,\n                    response_model_exclude_none=route.response_model_exclude_none,\n                    include_in_schema=route.include_in_schema\n                    and self.include_in_schema\n                    and include_in_schema,\n                    response_class=use_response_class,\n                    name=route.name,\n                    route_class_override=type(route),\n                    callbacks=current_callbacks,\n                    openapi_extra=route.openapi_extra,\n                    generate_unique_id_function=current_generate_unique_id,\n                )\n            elif isinstance(route, routing.Route):\n                methods = list(route.methods or [])\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                current_dependencies = []\n                if dependencies:\n                    current_dependencies.extend(dependencies)\n                if route.dependencies:\n                    current_dependencies.extend(route.dependencies)\n                self.add_api_websocket_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    dependencies=current_dependencies,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n        for handler in router.on_startup:\n            self.add_event_handler(\"startup\", handler)\n        for handler in router.on_shutdown:\n            self.add_event_handler(\"shutdown\", handler)\n        self.lifespan_context = _merge_lifespan_context(\n            self.lifespan_context,\n            router.lifespan_context,\n        )\n\n    def get(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def put(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP PUT operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.put(\"/items/{item_id}\")\n        def replace_item(item_id: str, item: Item):\n            return {\"message\": \"Item replaced\", \"id\": item_id}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def post(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP POST operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.post(\"/items/\")\n        def create_item(item: Item):\n            return {\"message\": \"Item created\"}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def delete(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP DELETE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.delete(\"/items/{item_id}\")\n        def delete_item(item_id: str):\n            return {\"message\": \"Item deleted\"}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def options(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP OPTIONS operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.options(\"/items/\")\n        def get_item_options():\n            return {\"additions\": [\"Aji\", \"Guacamole\"]}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def head(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP HEAD operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.head(\"/items/\", status_code=204)\n        def get_items_headers(response: Response):\n            response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def patch(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP PATCH operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.patch(\"/items/\")\n        def update_item(item: Item):\n            return {\"message\": \"Item updated in place\"}\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def trace(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[params.Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP TRACE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import APIRouter, FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n        router = APIRouter()\n\n        @router.trace(\"/items/{item_id}\")\n        def trace_item(item_id: str):\n            return None\n\n        app.include_router(router)\n        ```\n        \"\"\"\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    @deprecated(\n        \"\"\"\n        on_event is deprecated, use lifespan event handlers instead.\n\n        Read more about it in the\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).\n        \"\"\"\n    )\n    def on_event(\n        self,\n        event_type: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The type of event. `startup` or `shutdown`.\n                \"\"\"\n            ),\n        ],\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add an event handler for the router.\n\n        `on_event` is deprecated, use `lifespan` event handlers instead.\n\n        Read more about it in the\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_event_handler(event_type, func)\n            return func\n\n        return decorator\n", 4515], "/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py": ["from __future__ import annotations\n\nfrom typing import Any\n\nfrom starlette._utils import is_async_callable\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.types import ASGIApp, ExceptionHandler, Message, Receive, Scope, Send\nfrom starlette.websockets import WebSocket\n\nExceptionHandlers = dict[Any, ExceptionHandler]\nStatusHandlers = dict[int, ExceptionHandler]\n\n\ndef _lookup_exception_handler(exc_handlers: ExceptionHandlers, exc: Exception) -> ExceptionHandler | None:\n    for cls in type(exc).__mro__:\n        if cls in exc_handlers:\n            return exc_handlers[cls]\n    return None\n\n\ndef wrap_app_handling_exceptions(app: ASGIApp, conn: Request | WebSocket) -> ASGIApp:\n    exception_handlers: ExceptionHandlers\n    status_handlers: StatusHandlers\n    try:\n        exception_handlers, status_handlers = conn.scope[\"starlette.exception_handlers\"]\n    except KeyError:\n        exception_handlers, status_handlers = {}, {}\n\n    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:\n        response_started = False\n\n        async def sender(message: Message) -> None:\n            nonlocal response_started\n\n            if message[\"type\"] == \"http.response.start\":\n                response_started = True\n            await send(message)\n\n        try:\n            await app(scope, receive, sender)\n        except Exception as exc:\n            handler = None\n\n            if isinstance(exc, HTTPException):\n                handler = status_handlers.get(exc.status_code)\n\n            if handler is None:\n                handler = _lookup_exception_handler(exception_handlers, exc)\n\n            if handler is None:\n                raise exc\n\n            if response_started:\n                raise RuntimeError(\"Caught handled exception, but response already started.\") from exc\n\n            if is_async_callable(handler):\n                response = await handler(conn, exc)\n            else:\n                response = await run_in_threadpool(handler, conn, exc)\n            if response is not None:\n                await response(scope, receive, sender)\n\n    return wrapped_app\n", 65], "/usr/local/lib/python3.11/site-packages/starlette/routing.py": ["from __future__ import annotations\n\nimport contextlib\nimport functools\nimport inspect\nimport re\nimport traceback\nimport types\nimport warnings\nfrom collections.abc import Awaitable, Collection, Generator, Sequence\nfrom contextlib import AbstractAsyncContextManager, AbstractContextManager, asynccontextmanager\nfrom enum import Enum\nfrom re import Pattern\nfrom typing import Any, Callable, TypeVar\n\nfrom starlette._exception_handler import wrap_app_handling_exceptions\nfrom starlette._utils import get_route_path, is_async_callable\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.convertors import CONVERTOR_TYPES, Convertor\nfrom starlette.datastructures import URL, Headers, URLPath\nfrom starlette.exceptions import HTTPException\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse, RedirectResponse, Response\nfrom starlette.types import ASGIApp, Lifespan, Receive, Scope, Send\nfrom starlette.websockets import WebSocket, WebSocketClose\n\n\nclass NoMatchFound(Exception):\n    \"\"\"\n    Raised by `.url_for(name, **path_params)` and `.url_path_for(name, **path_params)`\n    if no matching route exists.\n    \"\"\"\n\n    def __init__(self, name: str, path_params: dict[str, Any]) -> None:\n        params = \", \".join(list(path_params.keys()))\n        super().__init__(f'No route exists for name \"{name}\" and params \"{params}\".')\n\n\nclass Match(Enum):\n    NONE = 0\n    PARTIAL = 1\n    FULL = 2\n\n\ndef iscoroutinefunction_or_partial(obj: Any) -> bool:  # pragma: no cover\n    \"\"\"\n    Correctly determines if an object is a coroutine function,\n    including those wrapped in functools.partial objects.\n    \"\"\"\n    warnings.warn(\n        \"iscoroutinefunction_or_partial is deprecated, and will be removed in a future release.\",\n        DeprecationWarning,\n    )\n    while isinstance(obj, functools.partial):\n        obj = obj.func\n    return inspect.iscoroutinefunction(obj)\n\n\ndef request_response(\n    func: Callable[[Request], Awaitable[Response] | Response],\n) -> ASGIApp:\n    \"\"\"\n    Takes a function or coroutine `func(request) -> response`,\n    and returns an ASGI application.\n    \"\"\"\n    f: Callable[[Request], Awaitable[Response]] = (\n        func if is_async_callable(func) else functools.partial(run_in_threadpool, func)\n    )\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        request = Request(scope, receive, send)\n\n        async def app(scope: Scope, receive: Receive, send: Send) -> None:\n            response = await f(request)\n            await response(scope, receive, send)\n\n        await wrap_app_handling_exceptions(app, request)(scope, receive, send)\n\n    return app\n\n\ndef websocket_session(\n    func: Callable[[WebSocket], Awaitable[None]],\n) -> ASGIApp:\n    \"\"\"\n    Takes a coroutine `func(session)`, and returns an ASGI application.\n    \"\"\"\n    # assert asyncio.iscoroutinefunction(func), \"WebSocket endpoints must be async\"\n\n    async def app(scope: Scope, receive: Receive, send: Send) -> None:\n        session = WebSocket(scope, receive=receive, send=send)\n\n        async def app(scope: Scope, receive: Receive, send: Send) -> None:\n            await func(session)\n\n        await wrap_app_handling_exceptions(app, session)(scope, receive, send)\n\n    return app\n\n\ndef get_name(endpoint: Callable[..., Any]) -> str:\n    return getattr(endpoint, \"__name__\", endpoint.__class__.__name__)\n\n\ndef replace_params(\n    path: str,\n    param_convertors: dict[str, Convertor[Any]],\n    path_params: dict[str, str],\n) -> tuple[str, dict[str, str]]:\n    for key, value in list(path_params.items()):\n        if \"{\" + key + \"}\" in path:\n            convertor = param_convertors[key]\n            value = convertor.to_string(value)\n            path = path.replace(\"{\" + key + \"}\", value)\n            path_params.pop(key)\n    return path, path_params\n\n\n# Match parameters in URL paths, eg. '{param}', and '{param:int}'\nPARAM_REGEX = re.compile(\"{([a-zA-Z_][a-zA-Z0-9_]*)(:[a-zA-Z_][a-zA-Z0-9_]*)?}\")\n\n\ndef compile_path(\n    path: str,\n) -> tuple[Pattern[str], str, dict[str, Convertor[Any]]]:\n    \"\"\"\n    Given a path string, like: \"/{username:str}\",\n    or a host string, like: \"{subdomain}.mydomain.org\", return a three-tuple\n    of (regex, format, {param_name:convertor}).\n\n    regex:      \"/(?P<username>[^/]+)\"\n    format:     \"/{username}\"\n    convertors: {\"username\": StringConvertor()}\n    \"\"\"\n    is_host = not path.startswith(\"/\")\n\n    path_regex = \"^\"\n    path_format = \"\"\n    duplicated_params = set()\n\n    idx = 0\n    param_convertors = {}\n    for match in PARAM_REGEX.finditer(path):\n        param_name, convertor_type = match.groups(\"str\")\n        convertor_type = convertor_type.lstrip(\":\")\n        assert convertor_type in CONVERTOR_TYPES, f\"Unknown path convertor '{convertor_type}'\"\n        convertor = CONVERTOR_TYPES[convertor_type]\n\n        path_regex += re.escape(path[idx : match.start()])\n        path_regex += f\"(?P<{param_name}>{convertor.regex})\"\n\n        path_format += path[idx : match.start()]\n        path_format += \"{%s}\" % param_name\n\n        if param_name in param_convertors:\n            duplicated_params.add(param_name)\n\n        param_convertors[param_name] = convertor\n\n        idx = match.end()\n\n    if duplicated_params:\n        names = \", \".join(sorted(duplicated_params))\n        ending = \"s\" if len(duplicated_params) > 1 else \"\"\n        raise ValueError(f\"Duplicated param name{ending} {names} at path {path}\")\n\n    if is_host:\n        # Align with `Host.matches()` behavior, which ignores port.\n        hostname = path[idx:].split(\":\")[0]\n        path_regex += re.escape(hostname) + \"$\"\n    else:\n        path_regex += re.escape(path[idx:]) + \"$\"\n\n    path_format += path[idx:]\n\n    return re.compile(path_regex), path_format, param_convertors\n\n\nclass BaseRoute:\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        raise NotImplementedError()  # pragma: no cover\n\n    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath:\n        raise NotImplementedError()  # pragma: no cover\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        raise NotImplementedError()  # pragma: no cover\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        A route may be used in isolation as a stand-alone ASGI app.\n        This is a somewhat contrived case, as they'll almost always be used\n        within a Router, but could be useful for some tooling and minimal apps.\n        \"\"\"\n        match, child_scope = self.matches(scope)\n        if match == Match.NONE:\n            if scope[\"type\"] == \"http\":\n                response = PlainTextResponse(\"Not Found\", status_code=404)\n                await response(scope, receive, send)\n            elif scope[\"type\"] == \"websocket\":  # pragma: no branch\n                websocket_close = WebSocketClose()\n                await websocket_close(scope, receive, send)\n            return\n\n        scope.update(child_scope)\n        await self.handle(scope, receive, send)\n\n\nclass Route(BaseRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        methods: Collection[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n        middleware: Sequence[Middleware] | None = None,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.include_in_schema = include_in_schema\n\n        endpoint_handler = endpoint\n        while isinstance(endpoint_handler, functools.partial):\n            endpoint_handler = endpoint_handler.func\n        if inspect.isfunction(endpoint_handler) or inspect.ismethod(endpoint_handler):\n            # Endpoint is function or method. Treat it as `func(request) -> response`.\n            self.app = request_response(endpoint)\n            if methods is None:\n                methods = [\"GET\"]\n        else:\n            # Endpoint is a class. Treat it as ASGI.\n            self.app = endpoint\n\n        if middleware is not None:\n            for cls, args, kwargs in reversed(middleware):\n                self.app = cls(self.app, *args, **kwargs)\n\n        if methods is None:\n            self.methods = None\n        else:\n            self.methods = {method.upper() for method in methods}\n            if \"GET\" in self.methods:\n                self.methods.add(\"HEAD\")\n\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        path_params: dict[str, Any]\n        if scope[\"type\"] == \"http\":\n            route_path = get_route_path(scope)\n            match = self.path_regex.match(route_path)\n            if match:\n                matched_params = match.groupdict()\n                for key, value in matched_params.items():\n                    matched_params[key] = self.param_convertors[key].convert(value)\n                path_params = dict(scope.get(\"path_params\", {}))\n                path_params.update(matched_params)\n                child_scope = {\"endpoint\": self.endpoint, \"path_params\": path_params}\n                if self.methods and scope[\"method\"] not in self.methods:\n                    return Match.PARTIAL, child_scope\n                else:\n                    return Match.FULL, child_scope\n        return Match.NONE, {}\n\n    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath:\n        seen_params = set(path_params.keys())\n        expected_params = set(self.param_convertors.keys())\n\n        if name != self.name or seen_params != expected_params:\n            raise NoMatchFound(name, path_params)\n\n        path, remaining_params = replace_params(self.path_format, self.param_convertors, path_params)\n        assert not remaining_params\n        return URLPath(path=path, protocol=\"http\")\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.methods and scope[\"method\"] not in self.methods:\n            headers = {\"Allow\": \", \".join(self.methods)}\n            if \"app\" in scope:\n                raise HTTPException(status_code=405, headers=headers)\n            else:\n                response = PlainTextResponse(\"Method Not Allowed\", status_code=405, headers=headers)\n            await response(scope, receive, send)\n        else:\n            await self.app(scope, receive, send)\n\n    def __eq__(self, other: Any) -> bool:\n        return (\n            isinstance(other, Route)\n            and self.path == other.path\n            and self.endpoint == other.endpoint\n            and self.methods == other.methods\n        )\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        methods = sorted(self.methods or [])\n        path, name = self.path, self.name\n        return f\"{class_name}(path={path!r}, name={name!r}, methods={methods!r})\"\n\n\nclass WebSocketRoute(BaseRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        name: str | None = None,\n        middleware: Sequence[Middleware] | None = None,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n\n        endpoint_handler = endpoint\n        while isinstance(endpoint_handler, functools.partial):\n            endpoint_handler = endpoint_handler.func\n        if inspect.isfunction(endpoint_handler) or inspect.ismethod(endpoint_handler):\n            # Endpoint is function or method. Treat it as `func(websocket)`.\n            self.app = websocket_session(endpoint)\n        else:\n            # Endpoint is a class. Treat it as ASGI.\n            self.app = endpoint\n\n        if middleware is not None:\n            for cls, args, kwargs in reversed(middleware):\n                self.app = cls(self.app, *args, **kwargs)\n\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        path_params: dict[str, Any]\n        if scope[\"type\"] == \"websocket\":\n            route_path = get_route_path(scope)\n            match = self.path_regex.match(route_path)\n            if match:\n                matched_params = match.groupdict()\n                for key, value in matched_params.items():\n                    matched_params[key] = self.param_convertors[key].convert(value)\n                path_params = dict(scope.get(\"path_params\", {}))\n                path_params.update(matched_params)\n                child_scope = {\"endpoint\": self.endpoint, \"path_params\": path_params}\n                return Match.FULL, child_scope\n        return Match.NONE, {}\n\n    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath:\n        seen_params = set(path_params.keys())\n        expected_params = set(self.param_convertors.keys())\n\n        if name != self.name or seen_params != expected_params:\n            raise NoMatchFound(name, path_params)\n\n        path, remaining_params = replace_params(self.path_format, self.param_convertors, path_params)\n        assert not remaining_params\n        return URLPath(path=path, protocol=\"websocket\")\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.app(scope, receive, send)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, WebSocketRoute) and self.path == other.path and self.endpoint == other.endpoint\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}(path={self.path!r}, name={self.name!r})\"\n\n\nclass Mount(BaseRoute):\n    def __init__(\n        self,\n        path: str,\n        app: ASGIApp | None = None,\n        routes: Sequence[BaseRoute] | None = None,\n        name: str | None = None,\n        *,\n        middleware: Sequence[Middleware] | None = None,\n    ) -> None:\n        assert path == \"\" or path.startswith(\"/\"), \"Routed paths must start with '/'\"\n        assert app is not None or routes is not None, \"Either 'app=...', or 'routes=' must be specified\"\n        self.path = path.rstrip(\"/\")\n        if app is not None:\n            self._base_app: ASGIApp = app\n        else:\n            self._base_app = Router(routes=routes)\n        self.app = self._base_app\n        if middleware is not None:\n            for cls, args, kwargs in reversed(middleware):\n                self.app = cls(self.app, *args, **kwargs)\n        self.name = name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(self.path + \"/{path:path}\")\n\n    @property\n    def routes(self) -> list[BaseRoute]:\n        return getattr(self._base_app, \"routes\", [])\n\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        path_params: dict[str, Any]\n        if scope[\"type\"] in (\"http\", \"websocket\"):  # pragma: no branch\n            root_path = scope.get(\"root_path\", \"\")\n            route_path = get_route_path(scope)\n            match = self.path_regex.match(route_path)\n            if match:\n                matched_params = match.groupdict()\n                for key, value in matched_params.items():\n                    matched_params[key] = self.param_convertors[key].convert(value)\n                remaining_path = \"/\" + matched_params.pop(\"path\")\n                matched_path = route_path[: -len(remaining_path)]\n                path_params = dict(scope.get(\"path_params\", {}))\n                path_params.update(matched_params)\n                child_scope = {\n                    \"path_params\": path_params,\n                    # app_root_path will only be set at the top level scope,\n                    # initialized with the (optional) value of a root_path\n                    # set above/before Starlette. And even though any\n                    # mount will have its own child scope with its own respective\n                    # root_path, the app_root_path will always be available in all\n                    # the child scopes with the same top level value because it's\n                    # set only once here with a default, any other child scope will\n                    # just inherit that app_root_path default value stored in the\n                    # scope. All this is needed to support Request.url_for(), as it\n                    # uses the app_root_path to build the URL path.\n                    \"app_root_path\": scope.get(\"app_root_path\", root_path),\n                    \"root_path\": root_path + matched_path,\n                    \"endpoint\": self.app,\n                }\n                return Match.FULL, child_scope\n        return Match.NONE, {}\n\n    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath:\n        if self.name is not None and name == self.name and \"path\" in path_params:\n            # 'name' matches \"<mount_name>\".\n            path_params[\"path\"] = path_params[\"path\"].lstrip(\"/\")\n            path, remaining_params = replace_params(self.path_format, self.param_convertors, path_params)\n            if not remaining_params:\n                return URLPath(path=path)\n        elif self.name is None or name.startswith(self.name + \":\"):\n            if self.name is None:\n                # No mount name.\n                remaining_name = name\n            else:\n                # 'name' matches \"<mount_name>:<child_name>\".\n                remaining_name = name[len(self.name) + 1 :]\n            path_kwarg = path_params.get(\"path\")\n            path_params[\"path\"] = \"\"\n            path_prefix, remaining_params = replace_params(self.path_format, self.param_convertors, path_params)\n            if path_kwarg is not None:\n                remaining_params[\"path\"] = path_kwarg\n            for route in self.routes or []:\n                try:\n                    url = route.url_path_for(remaining_name, **remaining_params)\n                    return URLPath(path=path_prefix.rstrip(\"/\") + str(url), protocol=url.protocol)\n                except NoMatchFound:\n                    pass\n        raise NoMatchFound(name, path_params)\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.app(scope, receive, send)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, Mount) and self.path == other.path and self.app == other.app\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        name = self.name or \"\"\n        return f\"{class_name}(path={self.path!r}, name={name!r}, app={self.app!r})\"\n\n\nclass Host(BaseRoute):\n    def __init__(self, host: str, app: ASGIApp, name: str | None = None) -> None:\n        assert not host.startswith(\"/\"), \"Host must not start with '/'\"\n        self.host = host\n        self.app = app\n        self.name = name\n        self.host_regex, self.host_format, self.param_convertors = compile_path(host)\n\n    @property\n    def routes(self) -> list[BaseRoute]:\n        return getattr(self.app, \"routes\", [])\n\n    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n        if scope[\"type\"] in (\"http\", \"websocket\"):  # pragma:no branch\n            headers = Headers(scope=scope)\n            host = headers.get(\"host\", \"\").split(\":\")[0]\n            match = self.host_regex.match(host)\n            if match:\n                matched_params = match.groupdict()\n                for key, value in matched_params.items():\n                    matched_params[key] = self.param_convertors[key].convert(value)\n                path_params = dict(scope.get(\"path_params\", {}))\n                path_params.update(matched_params)\n                child_scope = {\"path_params\": path_params, \"endpoint\": self.app}\n                return Match.FULL, child_scope\n        return Match.NONE, {}\n\n    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath:\n        if self.name is not None and name == self.name and \"path\" in path_params:\n            # 'name' matches \"<mount_name>\".\n            path = path_params.pop(\"path\")\n            host, remaining_params = replace_params(self.host_format, self.param_convertors, path_params)\n            if not remaining_params:\n                return URLPath(path=path, host=host)\n        elif self.name is None or name.startswith(self.name + \":\"):\n            if self.name is None:\n                # No mount name.\n                remaining_name = name\n            else:\n                # 'name' matches \"<mount_name>:<child_name>\".\n                remaining_name = name[len(self.name) + 1 :]\n            host, remaining_params = replace_params(self.host_format, self.param_convertors, path_params)\n            for route in self.routes or []:\n                try:\n                    url = route.url_path_for(remaining_name, **remaining_params)\n                    return URLPath(path=str(url), protocol=url.protocol, host=host)\n                except NoMatchFound:\n                    pass\n        raise NoMatchFound(name, path_params)\n\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.app(scope, receive, send)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, Host) and self.host == other.host and self.app == other.app\n\n    def __repr__(self) -> str:\n        class_name = self.__class__.__name__\n        name = self.name or \"\"\n        return f\"{class_name}(host={self.host!r}, name={name!r}, app={self.app!r})\"\n\n\n_T = TypeVar(\"_T\")\n\n\nclass _AsyncLiftContextManager(AbstractAsyncContextManager[_T]):\n    def __init__(self, cm: AbstractContextManager[_T]):\n        self._cm = cm\n\n    async def __aenter__(self) -> _T:\n        return self._cm.__enter__()\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: types.TracebackType | None,\n    ) -> bool | None:\n        return self._cm.__exit__(exc_type, exc_value, traceback)\n\n\ndef _wrap_gen_lifespan_context(\n    lifespan_context: Callable[[Any], Generator[Any, Any, Any]],\n) -> Callable[[Any], AbstractAsyncContextManager[Any]]:\n    cmgr = contextlib.contextmanager(lifespan_context)\n\n    @functools.wraps(cmgr)\n    def wrapper(app: Any) -> _AsyncLiftContextManager[Any]:\n        return _AsyncLiftContextManager(cmgr(app))\n\n    return wrapper\n\n\nclass _DefaultLifespan:\n    def __init__(self, router: Router):\n        self._router = router\n\n    async def __aenter__(self) -> None:\n        await self._router.startup()\n\n    async def __aexit__(self, *exc_info: object) -> None:\n        await self._router.shutdown()\n\n    def __call__(self: _T, app: object) -> _T:\n        return self\n\n\nclass Router:\n    def __init__(\n        self,\n        routes: Sequence[BaseRoute] | None = None,\n        redirect_slashes: bool = True,\n        default: ASGIApp | None = None,\n        on_startup: Sequence[Callable[[], Any]] | None = None,\n        on_shutdown: Sequence[Callable[[], Any]] | None = None,\n        # the generic to Lifespan[AppType] is the type of the top level application\n        # which the router cannot know statically, so we use Any\n        lifespan: Lifespan[Any] | None = None,\n        *,\n        middleware: Sequence[Middleware] | None = None,\n    ) -> None:\n        self.routes = [] if routes is None else list(routes)\n        self.redirect_slashes = redirect_slashes\n        self.default = self.not_found if default is None else default\n        self.on_startup = [] if on_startup is None else list(on_startup)\n        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)\n\n        if on_startup or on_shutdown:\n            warnings.warn(\n                \"The on_startup and on_shutdown parameters are deprecated, and they \"\n                \"will be removed on version 1.0. Use the lifespan parameter instead. \"\n                \"See more about it on https://www.starlette.io/lifespan/.\",\n                DeprecationWarning,\n            )\n            if lifespan:\n                warnings.warn(\n                    \"The `lifespan` parameter cannot be used with `on_startup` or \"\n                    \"`on_shutdown`. Both `on_startup` and `on_shutdown` will be \"\n                    \"ignored.\"\n                )\n\n        if lifespan is None:\n            self.lifespan_context: Lifespan[Any] = _DefaultLifespan(self)\n\n        elif inspect.isasyncgenfunction(lifespan):\n            warnings.warn(\n                \"async generator function lifespans are deprecated, \"\n                \"use an @contextlib.asynccontextmanager function instead\",\n                DeprecationWarning,\n            )\n            self.lifespan_context = asynccontextmanager(\n                lifespan,\n            )\n        elif inspect.isgeneratorfunction(lifespan):\n            warnings.warn(\n                \"generator function lifespans are deprecated, use an @contextlib.asynccontextmanager function instead\",\n                DeprecationWarning,\n            )\n            self.lifespan_context = _wrap_gen_lifespan_context(\n                lifespan,\n            )\n        else:\n            self.lifespan_context = lifespan\n\n        self.middleware_stack = self.app\n        if middleware:\n            for cls, args, kwargs in reversed(middleware):\n                self.middleware_stack = cls(self.middleware_stack, *args, **kwargs)\n\n    async def not_found(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] == \"websocket\":\n            websocket_close = WebSocketClose()\n            await websocket_close(scope, receive, send)\n            return\n\n        # If we're running inside a starlette application then raise an\n        # exception, so that the configurable exception handler can deal with\n        # returning the response. For plain ASGI apps, just return the response.\n        if \"app\" in scope:\n            raise HTTPException(status_code=404)\n        else:\n            response = PlainTextResponse(\"Not Found\", status_code=404)\n        await response(scope, receive, send)\n\n    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath:\n        for route in self.routes:\n            try:\n                return route.url_path_for(name, **path_params)\n            except NoMatchFound:\n                pass\n        raise NoMatchFound(name, path_params)\n\n    async def startup(self) -> None:\n        \"\"\"\n        Run any `.on_startup` event handlers.\n        \"\"\"\n        for handler in self.on_startup:\n            if is_async_callable(handler):\n                await handler()\n            else:\n                handler()\n\n    async def shutdown(self) -> None:\n        \"\"\"\n        Run any `.on_shutdown` event handlers.\n        \"\"\"\n        for handler in self.on_shutdown:\n            if is_async_callable(handler):\n                await handler()\n            else:\n                handler()\n\n    async def lifespan(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        Handle ASGI lifespan messages, which allows us to manage application\n        startup and shutdown events.\n        \"\"\"\n        started = False\n        app: Any = scope.get(\"app\")\n        await receive()\n        try:\n            async with self.lifespan_context(app) as maybe_state:\n                if maybe_state is not None:\n                    if \"state\" not in scope:\n                        raise RuntimeError('The server does not support \"state\" in the lifespan scope.')\n                    scope[\"state\"].update(maybe_state)\n                await send({\"type\": \"lifespan.startup.complete\"})\n                started = True\n                await receive()\n        except BaseException:\n            exc_text = traceback.format_exc()\n            if started:\n                await send({\"type\": \"lifespan.shutdown.failed\", \"message\": exc_text})\n            else:\n                await send({\"type\": \"lifespan.startup.failed\", \"message\": exc_text})\n            raise\n        else:\n            await send({\"type\": \"lifespan.shutdown.complete\"})\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        The main entry point to the Router class.\n        \"\"\"\n        await self.middleware_stack(scope, receive, send)\n\n    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:\n        assert scope[\"type\"] in (\"http\", \"websocket\", \"lifespan\")\n\n        if \"router\" not in scope:\n            scope[\"router\"] = self\n\n        if scope[\"type\"] == \"lifespan\":\n            await self.lifespan(scope, receive, send)\n            return\n\n        partial = None\n\n        for route in self.routes:\n            # Determine if any route matches the incoming scope,\n            # and hand over to the matching route if found.\n            match, child_scope = route.matches(scope)\n            if match == Match.FULL:\n                scope.update(child_scope)\n                await route.handle(scope, receive, send)\n                return\n            elif match == Match.PARTIAL and partial is None:\n                partial = route\n                partial_scope = child_scope\n\n        if partial is not None:\n            # \u00a0Handle partial matches. These are cases where an endpoint is\n            # able to handle the request, but is not a preferred option.\n            # We use this in particular to deal with \"405 Method Not Allowed\".\n            scope.update(partial_scope)\n            await partial.handle(scope, receive, send)\n            return\n\n        route_path = get_route_path(scope)\n        if scope[\"type\"] == \"http\" and self.redirect_slashes and route_path != \"/\":\n            redirect_scope = dict(scope)\n            if route_path.endswith(\"/\"):\n                redirect_scope[\"path\"] = redirect_scope[\"path\"].rstrip(\"/\")\n            else:\n                redirect_scope[\"path\"] = redirect_scope[\"path\"] + \"/\"\n\n            for route in self.routes:\n                match, child_scope = route.matches(redirect_scope)\n                if match != Match.NONE:\n                    redirect_url = URL(scope=redirect_scope)\n                    response = RedirectResponse(url=str(redirect_url))\n                    await response(scope, receive, send)\n                    return\n\n        await self.default(scope, receive, send)\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, Router) and self.routes == other.routes\n\n    def mount(self, path: str, app: ASGIApp, name: str | None = None) -> None:  # pragma: no cover\n        route = Mount(path, app=app, name=name)\n        self.routes.append(route)\n\n    def host(self, host: str, app: ASGIApp, name: str | None = None) -> None:  # pragma: no cover\n        route = Host(host, app=app, name=name)\n        self.routes.append(route)\n\n    def add_route(\n        self,\n        path: str,\n        endpoint: Callable[[Request], Awaitable[Response] | Response],\n        methods: Collection[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n    ) -> None:  # pragma: no cover\n        route = Route(\n            path,\n            endpoint=endpoint,\n            methods=methods,\n            name=name,\n            include_in_schema=include_in_schema,\n        )\n        self.routes.append(route)\n\n    def add_websocket_route(\n        self,\n        path: str,\n        endpoint: Callable[[WebSocket], Awaitable[None]],\n        name: str | None = None,\n    ) -> None:  # pragma: no cover\n        route = WebSocketRoute(path, endpoint=endpoint, name=name)\n        self.routes.append(route)\n\n    def route(\n        self,\n        path: str,\n        methods: Collection[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n    ) -> Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> routes = [Route(path, endpoint=...), ...]\n        >>> app = Starlette(routes=routes)\n        \"\"\"\n        warnings.warn(\n            \"The `route` decorator is deprecated, and will be removed in version 1.0.0.\"\n            \"Refer to https://www.starlette.io/routing/#http-routing for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: Callable) -> Callable:  # type: ignore[type-arg]\n            self.add_route(\n                path,\n                func,\n                methods=methods,\n                name=name,\n                include_in_schema=include_in_schema,\n            )\n            return func\n\n        return decorator\n\n    def websocket_route(self, path: str, name: str | None = None) -> Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> routes = [WebSocketRoute(path, endpoint=...), ...]\n        >>> app = Starlette(routes=routes)\n        \"\"\"\n        warnings.warn(\n            \"The `websocket_route` decorator is deprecated, and will be removed in version 1.0.0. Refer to \"\n            \"https://www.starlette.io/routing/#websocket-routing for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: Callable) -> Callable:  # type: ignore[type-arg]\n            self.add_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def add_event_handler(self, event_type: str, func: Callable[[], Any]) -> None:  # pragma: no cover\n        assert event_type in (\"startup\", \"shutdown\")\n\n        if event_type == \"startup\":\n            self.on_startup.append(func)\n        else:\n            self.on_shutdown.append(func)\n\n    def on_event(self, event_type: str) -> Callable:  # type: ignore[type-arg]\n        warnings.warn(\n            \"The `on_event` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/lifespan/ for recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: Callable) -> Callable:  # type: ignore[type-arg]\n            self.add_event_handler(event_type, func)\n            return func\n\n        return decorator\n", 876], "/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py": ["from contextlib import AsyncExitStack\n\nfrom starlette.types import ASGIApp, Receive, Scope, Send\n\n\n# Used mainly to close files after the request is done, dependencies are closed\n# in their own AsyncExitStack\nclass AsyncExitStackMiddleware:\n    def __init__(\n        self, app: ASGIApp, context_name: str = \"fastapi_middleware_astack\"\n    ) -> None:\n        self.app = app\n        self.context_name = context_name\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        async with AsyncExitStack() as stack:\n            scope[self.context_name] = stack\n            await self.app(scope, receive, send)\n", 18], "/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py": ["from __future__ import annotations\n\nfrom collections.abc import Mapping\nfrom typing import Any\n\nfrom starlette._exception_handler import (\n    ExceptionHandlers,\n    StatusHandlers,\n    wrap_app_handling_exceptions,\n)\nfrom starlette.exceptions import HTTPException, WebSocketException\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse, Response\nfrom starlette.types import ASGIApp, ExceptionHandler, Receive, Scope, Send\nfrom starlette.websockets import WebSocket\n\n\nclass ExceptionMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        handlers: Mapping[Any, ExceptionHandler] | None = None,\n        debug: bool = False,\n    ) -> None:\n        self.app = app\n        self.debug = debug  # TODO: We ought to handle 404 cases if debug is set.\n        self._status_handlers: StatusHandlers = {}\n        self._exception_handlers: ExceptionHandlers = {\n            HTTPException: self.http_exception,\n            WebSocketException: self.websocket_exception,\n        }\n        if handlers is not None:  # pragma: no branch\n            for key, value in handlers.items():\n                self.add_exception_handler(key, value)\n\n    def add_exception_handler(\n        self,\n        exc_class_or_status_code: int | type[Exception],\n        handler: ExceptionHandler,\n    ) -> None:\n        if isinstance(exc_class_or_status_code, int):\n            self._status_handlers[exc_class_or_status_code] = handler\n        else:\n            assert issubclass(exc_class_or_status_code, Exception)\n            self._exception_handlers[exc_class_or_status_code] = handler\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] not in (\"http\", \"websocket\"):\n            await self.app(scope, receive, send)\n            return\n\n        scope[\"starlette.exception_handlers\"] = (\n            self._exception_handlers,\n            self._status_handlers,\n        )\n\n        conn: Request | WebSocket\n        if scope[\"type\"] == \"http\":\n            conn = Request(scope, receive, send)\n        else:\n            conn = WebSocket(scope, receive, send)\n\n        await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)\n\n    async def http_exception(self, request: Request, exc: Exception) -> Response:\n        assert isinstance(exc, HTTPException)\n        if exc.status_code in {204, 304}:\n            return Response(status_code=exc.status_code, headers=exc.headers)\n        return PlainTextResponse(exc.detail, status_code=exc.status_code, headers=exc.headers)\n\n    async def websocket_exception(self, websocket: WebSocket, exc: Exception) -> None:\n        assert isinstance(exc, WebSocketException)\n        await websocket.close(code=exc.code, reason=exc.reason)  # pragma: no cover\n", 73], "/usr/local/lib/python3.11/site-packages/starlette/middleware/cors.py": ["from __future__ import annotations\n\nimport functools\nimport re\nfrom collections.abc import Sequence\n\nfrom starlette.datastructures import Headers, MutableHeaders\nfrom starlette.responses import PlainTextResponse, Response\nfrom starlette.types import ASGIApp, Message, Receive, Scope, Send\n\nALL_METHODS = (\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\")\nSAFELISTED_HEADERS = {\"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\"}\n\n\nclass CORSMiddleware:\n    def __init__(\n        self,\n        app: ASGIApp,\n        allow_origins: Sequence[str] = (),\n        allow_methods: Sequence[str] = (\"GET\",),\n        allow_headers: Sequence[str] = (),\n        allow_credentials: bool = False,\n        allow_origin_regex: str | None = None,\n        expose_headers: Sequence[str] = (),\n        max_age: int = 600,\n    ) -> None:\n        if \"*\" in allow_methods:\n            allow_methods = ALL_METHODS\n\n        compiled_allow_origin_regex = None\n        if allow_origin_regex is not None:\n            compiled_allow_origin_regex = re.compile(allow_origin_regex)\n\n        allow_all_origins = \"*\" in allow_origins\n        allow_all_headers = \"*\" in allow_headers\n        preflight_explicit_allow_origin = not allow_all_origins or allow_credentials\n\n        simple_headers = {}\n        if allow_all_origins:\n            simple_headers[\"Access-Control-Allow-Origin\"] = \"*\"\n        if allow_credentials:\n            simple_headers[\"Access-Control-Allow-Credentials\"] = \"true\"\n        if expose_headers:\n            simple_headers[\"Access-Control-Expose-Headers\"] = \", \".join(expose_headers)\n\n        preflight_headers = {}\n        if preflight_explicit_allow_origin:\n            # The origin value will be set in preflight_response() if it is allowed.\n            preflight_headers[\"Vary\"] = \"Origin\"\n        else:\n            preflight_headers[\"Access-Control-Allow-Origin\"] = \"*\"\n        preflight_headers.update(\n            {\n                \"Access-Control-Allow-Methods\": \", \".join(allow_methods),\n                \"Access-Control-Max-Age\": str(max_age),\n            }\n        )\n        allow_headers = sorted(SAFELISTED_HEADERS | set(allow_headers))\n        if allow_headers and not allow_all_headers:\n            preflight_headers[\"Access-Control-Allow-Headers\"] = \", \".join(allow_headers)\n        if allow_credentials:\n            preflight_headers[\"Access-Control-Allow-Credentials\"] = \"true\"\n\n        self.app = app\n        self.allow_origins = allow_origins\n        self.allow_methods = allow_methods\n        self.allow_headers = [h.lower() for h in allow_headers]\n        self.allow_all_origins = allow_all_origins\n        self.allow_all_headers = allow_all_headers\n        self.preflight_explicit_allow_origin = preflight_explicit_allow_origin\n        self.allow_origin_regex = compiled_allow_origin_regex\n        self.simple_headers = simple_headers\n        self.preflight_headers = preflight_headers\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] != \"http\":  # pragma: no cover\n            await self.app(scope, receive, send)\n            return\n\n        method = scope[\"method\"]\n        headers = Headers(scope=scope)\n        origin = headers.get(\"origin\")\n\n        if origin is None:\n            await self.app(scope, receive, send)\n            return\n\n        if method == \"OPTIONS\" and \"access-control-request-method\" in headers:\n            response = self.preflight_response(request_headers=headers)\n            await response(scope, receive, send)\n            return\n\n        await self.simple_response(scope, receive, send, request_headers=headers)\n\n    def is_allowed_origin(self, origin: str) -> bool:\n        if self.allow_all_origins:\n            return True\n\n        if self.allow_origin_regex is not None and self.allow_origin_regex.fullmatch(origin):\n            return True\n\n        return origin in self.allow_origins\n\n    def preflight_response(self, request_headers: Headers) -> Response:\n        requested_origin = request_headers[\"origin\"]\n        requested_method = request_headers[\"access-control-request-method\"]\n        requested_headers = request_headers.get(\"access-control-request-headers\")\n\n        headers = dict(self.preflight_headers)\n        failures = []\n\n        if self.is_allowed_origin(origin=requested_origin):\n            if self.preflight_explicit_allow_origin:\n                # The \"else\" case is already accounted for in self.preflight_headers\n                # and the value would be \"*\".\n                headers[\"Access-Control-Allow-Origin\"] = requested_origin\n        else:\n            failures.append(\"origin\")\n\n        if requested_method not in self.allow_methods:\n            failures.append(\"method\")\n\n        # If we allow all headers, then we have to mirror back any requested\n        # headers in the response.\n        if self.allow_all_headers and requested_headers is not None:\n            headers[\"Access-Control-Allow-Headers\"] = requested_headers\n        elif requested_headers is not None:\n            for header in [h.lower() for h in requested_headers.split(\",\")]:\n                if header.strip() not in self.allow_headers:\n                    failures.append(\"headers\")\n                    break\n\n        # We don't strictly need to use 400 responses here, since its up to\n        # the browser to enforce the CORS policy, but its more informative\n        # if we do.\n        if failures:\n            failure_text = \"Disallowed CORS \" + \", \".join(failures)\n            return PlainTextResponse(failure_text, status_code=400, headers=headers)\n\n        return PlainTextResponse(\"OK\", status_code=200, headers=headers)\n\n    async def simple_response(self, scope: Scope, receive: Receive, send: Send, request_headers: Headers) -> None:\n        send = functools.partial(self.send, send=send, request_headers=request_headers)\n        await self.app(scope, receive, send)\n\n    async def send(self, message: Message, send: Send, request_headers: Headers) -> None:\n        if message[\"type\"] != \"http.response.start\":\n            await send(message)\n            return\n\n        message.setdefault(\"headers\", [])\n        headers = MutableHeaders(scope=message)\n        headers.update(self.simple_headers)\n        origin = request_headers[\"Origin\"]\n        has_cookie = \"cookie\" in request_headers\n\n        # If request includes any cookie headers, then we must respond\n        # with the specific origin instead of '*'.\n        if self.allow_all_origins and has_cookie:\n            self.allow_explicit_origin(headers, origin)\n\n        # If we only allow specific origins, then we have to mirror back\n        # the Origin header in the response.\n        elif not self.allow_all_origins and self.is_allowed_origin(origin=origin):\n            self.allow_explicit_origin(headers, origin)\n\n        await send(message)\n\n    @staticmethod\n    def allow_explicit_origin(headers: MutableHeaders, origin: str) -> None:\n        headers[\"Access-Control-Allow-Origin\"] = origin\n        headers.add_vary_header(\"Origin\")\n", 172], "/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py": ["from __future__ import annotations\n\nimport html\nimport inspect\nimport sys\nimport traceback\n\nfrom starlette._utils import is_async_callable\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, PlainTextResponse, Response\nfrom starlette.types import ASGIApp, ExceptionHandler, Message, Receive, Scope, Send\n\nSTYLES = \"\"\"\np {\n    color: #211c1c;\n}\n.traceback-container {\n    border: 1px solid #038BB8;\n}\n.traceback-title {\n    background-color: #038BB8;\n    color: lemonchiffon;\n    padding: 12px;\n    font-size: 20px;\n    margin-top: 0px;\n}\n.frame-line {\n    padding-left: 10px;\n    font-family: monospace;\n}\n.frame-filename {\n    font-family: monospace;\n}\n.center-line {\n    background-color: #038BB8;\n    color: #f9f6e1;\n    padding: 5px 0px 5px 5px;\n}\n.lineno {\n    margin-right: 5px;\n}\n.frame-title {\n    font-weight: unset;\n    padding: 10px 10px 10px 10px;\n    background-color: #E4F4FD;\n    margin-right: 10px;\n    color: #191f21;\n    font-size: 17px;\n    border: 1px solid #c7dce8;\n}\n.collapse-btn {\n    float: right;\n    padding: 0px 5px 1px 5px;\n    border: solid 1px #96aebb;\n    cursor: pointer;\n}\n.collapsed {\n  display: none;\n}\n.source-code {\n  font-family: courier;\n  font-size: small;\n  padding-bottom: 10px;\n}\n\"\"\"\n\nJS = \"\"\"\n<script type=\"text/javascript\">\n    function collapse(element){\n        const frameId = element.getAttribute(\"data-frame-id\");\n        const frame = document.getElementById(frameId);\n\n        if (frame.classList.contains(\"collapsed\")){\n            element.innerHTML = \"&#8210;\";\n            frame.classList.remove(\"collapsed\");\n        } else {\n            element.innerHTML = \"+\";\n            frame.classList.add(\"collapsed\");\n        }\n    }\n</script>\n\"\"\"\n\nTEMPLATE = \"\"\"\n<html>\n    <head>\n        <style type='text/css'>\n            {styles}\n        </style>\n        <title>Starlette Debugger</title>\n    </head>\n    <body>\n        <h1>500 Server Error</h1>\n        <h2>{error}</h2>\n        <div class=\"traceback-container\">\n            <p class=\"traceback-title\">Traceback</p>\n            <div>{exc_html}</div>\n        </div>\n        {js}\n    </body>\n</html>\n\"\"\"\n\nFRAME_TEMPLATE = \"\"\"\n<div>\n    <p class=\"frame-title\">File <span class=\"frame-filename\">{frame_filename}</span>,\n    line <i>{frame_lineno}</i>,\n    in <b>{frame_name}</b>\n    <span class=\"collapse-btn\" data-frame-id=\"{frame_filename}-{frame_lineno}\" onclick=\"collapse(this)\">{collapse_button}</span>\n    </p>\n    <div id=\"{frame_filename}-{frame_lineno}\" class=\"source-code {collapsed}\">{code_context}</div>\n</div>\n\"\"\"  # noqa: E501\n\nLINE = \"\"\"\n<p><span class=\"frame-line\">\n<span class=\"lineno\">{lineno}.</span> {line}</span></p>\n\"\"\"\n\nCENTER_LINE = \"\"\"\n<p class=\"center-line\"><span class=\"frame-line center-line\">\n<span class=\"lineno\">{lineno}.</span> {line}</span></p>\n\"\"\"\n\n\nclass ServerErrorMiddleware:\n    \"\"\"\n    Handles returning 500 responses when a server error occurs.\n\n    If 'debug' is set, then traceback responses will be returned,\n    otherwise the designated 'handler' will be called.\n\n    This middleware class should generally be used to wrap *everything*\n    else up, so that unhandled exceptions anywhere in the stack\n    always result in an appropriate 500 response.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: ASGIApp,\n        handler: ExceptionHandler | None = None,\n        debug: bool = False,\n    ) -> None:\n        self.app = app\n        self.handler = handler\n        self.debug = debug\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        response_started = False\n\n        async def _send(message: Message) -> None:\n            nonlocal response_started, send\n\n            if message[\"type\"] == \"http.response.start\":\n                response_started = True\n            await send(message)\n\n        try:\n            await self.app(scope, receive, _send)\n        except Exception as exc:\n            request = Request(scope)\n            if self.debug:\n                # In debug mode, return traceback responses.\n                response = self.debug_response(request, exc)\n            elif self.handler is None:\n                # Use our default 500 error handler.\n                response = self.error_response(request, exc)\n            else:\n                # Use an installed 500 error handler.\n                if is_async_callable(self.handler):\n                    response = await self.handler(request, exc)\n                else:\n                    response = await run_in_threadpool(self.handler, request, exc)\n\n            if not response_started:\n                await response(scope, receive, send)\n\n            # We always continue to raise the exception.\n            # This allows servers to log the error, or allows test clients\n            # to optionally raise the error within the test case.\n            raise exc\n\n    def format_line(self, index: int, line: str, frame_lineno: int, frame_index: int) -> str:\n        values = {\n            # HTML escape - line could contain < or >\n            \"line\": html.escape(line).replace(\" \", \"&nbsp\"),\n            \"lineno\": (frame_lineno - frame_index) + index,\n        }\n\n        if index != frame_index:\n            return LINE.format(**values)\n        return CENTER_LINE.format(**values)\n\n    def generate_frame_html(self, frame: inspect.FrameInfo, is_collapsed: bool) -> str:\n        code_context = \"\".join(\n            self.format_line(\n                index,\n                line,\n                frame.lineno,\n                frame.index,  # type: ignore[arg-type]\n            )\n            for index, line in enumerate(frame.code_context or [])\n        )\n\n        values = {\n            # HTML escape - filename could contain < or >, especially if it's a virtual\n            # file e.g. <stdin> in the REPL\n            \"frame_filename\": html.escape(frame.filename),\n            \"frame_lineno\": frame.lineno,\n            # HTML escape - if you try very hard it's possible to name a function with <\n            # or >\n            \"frame_name\": html.escape(frame.function),\n            \"code_context\": code_context,\n            \"collapsed\": \"collapsed\" if is_collapsed else \"\",\n            \"collapse_button\": \"+\" if is_collapsed else \"&#8210;\",\n        }\n        return FRAME_TEMPLATE.format(**values)\n\n    def generate_html(self, exc: Exception, limit: int = 7) -> str:\n        traceback_obj = traceback.TracebackException.from_exception(exc, capture_locals=True)\n\n        exc_html = \"\"\n        is_collapsed = False\n        exc_traceback = exc.__traceback__\n        if exc_traceback is not None:\n            frames = inspect.getinnerframes(exc_traceback, limit)\n            for frame in reversed(frames):\n                exc_html += self.generate_frame_html(frame, is_collapsed)\n                is_collapsed = True\n\n        if sys.version_info >= (3, 13):  # pragma: no cover\n            exc_type_str = traceback_obj.exc_type_str\n        else:  # pragma: no cover\n            exc_type_str = traceback_obj.exc_type.__name__\n\n        # escape error class and text\n        error = f\"{html.escape(exc_type_str)}: {html.escape(str(traceback_obj))}\"\n\n        return TEMPLATE.format(styles=STYLES, js=JS, error=error, exc_html=exc_html)\n\n    def generate_plain_text(self, exc: Exception) -> str:\n        return \"\".join(traceback.format_exception(type(exc), exc, exc.__traceback__))\n\n    def debug_response(self, request: Request, exc: Exception) -> Response:\n        accept = request.headers.get(\"accept\", \"\")\n\n        if \"text/html\" in accept:\n            content = self.generate_html(exc)\n            return HTMLResponse(content, status_code=500)\n        content = self.generate_plain_text(exc)\n        return PlainTextResponse(content, status_code=500)\n\n    def error_response(self, request: Request, exc: Exception) -> Response:\n        return PlainTextResponse(\"Internal Server Error\", status_code=500)\n", 259], "/usr/local/lib/python3.11/site-packages/starlette/applications.py": ["from __future__ import annotations\n\nimport sys\nimport warnings\nfrom collections.abc import Awaitable, Mapping, Sequence\nfrom typing import Any, Callable, TypeVar\n\nif sys.version_info >= (3, 10):  # pragma: no cover\n    from typing import ParamSpec\nelse:  # pragma: no cover\n    from typing_extensions import ParamSpec\n\nfrom starlette.datastructures import State, URLPath\nfrom starlette.middleware import Middleware, _MiddlewareFactory\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.middleware.errors import ServerErrorMiddleware\nfrom starlette.middleware.exceptions import ExceptionMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.routing import BaseRoute, Router\nfrom starlette.types import ASGIApp, ExceptionHandler, Lifespan, Receive, Scope, Send\nfrom starlette.websockets import WebSocket\n\nAppType = TypeVar(\"AppType\", bound=\"Starlette\")\nP = ParamSpec(\"P\")\n\n\nclass Starlette:\n    \"\"\"Creates an Starlette application.\"\"\"\n\n    def __init__(\n        self: AppType,\n        debug: bool = False,\n        routes: Sequence[BaseRoute] | None = None,\n        middleware: Sequence[Middleware] | None = None,\n        exception_handlers: Mapping[Any, ExceptionHandler] | None = None,\n        on_startup: Sequence[Callable[[], Any]] | None = None,\n        on_shutdown: Sequence[Callable[[], Any]] | None = None,\n        lifespan: Lifespan[AppType] | None = None,\n    ) -> None:\n        \"\"\"Initializes the application.\n\n        Parameters:\n            debug: Boolean indicating if debug tracebacks should be returned on errors.\n            routes: A list of routes to serve incoming HTTP and WebSocket requests.\n            middleware: A list of middleware to run for every request. A starlette\n                application will always automatically include two middleware classes.\n                `ServerErrorMiddleware` is added as the very outermost middleware, to handle\n                any uncaught errors occurring anywhere in the entire stack.\n                `ExceptionMiddleware` is added as the very innermost middleware, to deal\n                with handled exception cases occurring in the routing or endpoints.\n            exception_handlers: A mapping of either integer status codes,\n                or exception class types onto callables which handle the exceptions.\n                Exception handler callables should be of the form\n                `handler(request, exc) -> response` and may be either standard functions, or\n                async functions.\n            on_startup: A list of callables to run on application startup.\n                Startup handler callables do not take any arguments, and may be either\n                standard functions, or async functions.\n            on_shutdown: A list of callables to run on application shutdown.\n                Shutdown handler callables do not take any arguments, and may be either\n                standard functions, or async functions.\n            lifespan: A lifespan context function, which can be used to perform\n                startup and shutdown tasks. This is a newer style that replaces the\n                `on_startup` and `on_shutdown` handlers. Use one or the other, not both.\n        \"\"\"\n        # The lifespan context function is a newer style that replaces\n        # on_startup / on_shutdown handlers. Use one or the other, not both.\n        assert lifespan is None or (on_startup is None and on_shutdown is None), (\n            \"Use either 'lifespan' or 'on_startup'/'on_shutdown', not both.\"\n        )\n\n        self.debug = debug\n        self.state = State()\n        self.router = Router(routes, on_startup=on_startup, on_shutdown=on_shutdown, lifespan=lifespan)\n        self.exception_handlers = {} if exception_handlers is None else dict(exception_handlers)\n        self.user_middleware = [] if middleware is None else list(middleware)\n        self.middleware_stack: ASGIApp | None = None\n\n    def build_middleware_stack(self) -> ASGIApp:\n        debug = self.debug\n        error_handler = None\n        exception_handlers: dict[Any, ExceptionHandler] = {}\n\n        for key, value in self.exception_handlers.items():\n            if key in (500, Exception):\n                error_handler = value\n            else:\n                exception_handlers[key] = value\n\n        middleware = (\n            [Middleware(ServerErrorMiddleware, handler=error_handler, debug=debug)]\n            + self.user_middleware\n            + [Middleware(ExceptionMiddleware, handlers=exception_handlers, debug=debug)]\n        )\n\n        app = self.router\n        for cls, args, kwargs in reversed(middleware):\n            app = cls(app, *args, **kwargs)\n        return app\n\n    @property\n    def routes(self) -> list[BaseRoute]:\n        return self.router.routes\n\n    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath:\n        return self.router.url_path_for(name, **path_params)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        scope[\"app\"] = self\n        if self.middleware_stack is None:\n            self.middleware_stack = self.build_middleware_stack()\n        await self.middleware_stack(scope, receive, send)\n\n    def on_event(self, event_type: str) -> Callable:  # type: ignore[type-arg]\n        return self.router.on_event(event_type)  # pragma: no cover\n\n    def mount(self, path: str, app: ASGIApp, name: str | None = None) -> None:\n        self.router.mount(path, app=app, name=name)  # pragma: no cover\n\n    def host(self, host: str, app: ASGIApp, name: str | None = None) -> None:\n        self.router.host(host, app=app, name=name)  # pragma: no cover\n\n    def add_middleware(\n        self,\n        middleware_class: _MiddlewareFactory[P],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> None:\n        if self.middleware_stack is not None:  # pragma: no cover\n            raise RuntimeError(\"Cannot add middleware after an application has started\")\n        self.user_middleware.insert(0, Middleware(middleware_class, *args, **kwargs))\n\n    def add_exception_handler(\n        self,\n        exc_class_or_status_code: int | type[Exception],\n        handler: ExceptionHandler,\n    ) -> None:  # pragma: no cover\n        self.exception_handlers[exc_class_or_status_code] = handler\n\n    def add_event_handler(\n        self,\n        event_type: str,\n        func: Callable,  # type: ignore[type-arg]\n    ) -> None:  # pragma: no cover\n        self.router.add_event_handler(event_type, func)\n\n    def add_route(\n        self,\n        path: str,\n        route: Callable[[Request], Awaitable[Response] | Response],\n        methods: list[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n    ) -> None:  # pragma: no cover\n        self.router.add_route(path, route, methods=methods, name=name, include_in_schema=include_in_schema)\n\n    def add_websocket_route(\n        self,\n        path: str,\n        route: Callable[[WebSocket], Awaitable[None]],\n        name: str | None = None,\n    ) -> None:  # pragma: no cover\n        self.router.add_websocket_route(path, route, name=name)\n\n    def exception_handler(self, exc_class_or_status_code: int | type[Exception]) -> Callable:  # type: ignore[type-arg]\n        warnings.warn(\n            \"The `exception_handler` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/exceptions/ for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: Callable) -> Callable:  # type: ignore[type-arg]\n            self.add_exception_handler(exc_class_or_status_code, func)\n            return func\n\n        return decorator\n\n    def route(\n        self,\n        path: str,\n        methods: list[str] | None = None,\n        name: str | None = None,\n        include_in_schema: bool = True,\n    ) -> Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> routes = [Route(path, endpoint=...), ...]\n        >>> app = Starlette(routes=routes)\n        \"\"\"\n        warnings.warn(\n            \"The `route` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/routing/ for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: Callable) -> Callable:  # type: ignore[type-arg]\n            self.router.add_route(\n                path,\n                func,\n                methods=methods,\n                name=name,\n                include_in_schema=include_in_schema,\n            )\n            return func\n\n        return decorator\n\n    def websocket_route(self, path: str, name: str | None = None) -> Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> routes = [WebSocketRoute(path, endpoint=...), ...]\n        >>> app = Starlette(routes=routes)\n        \"\"\"\n        warnings.warn(\n            \"The `websocket_route` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/routing/#websocket-routing for the recommended approach.\",\n            DeprecationWarning,\n        )\n\n        def decorator(func: Callable) -> Callable:  # type: ignore[type-arg]\n            self.router.add_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def middleware(self, middleware_type: str) -> Callable:  # type: ignore[type-arg]\n        \"\"\"\n        We no longer document this decorator style API, and its usage is discouraged.\n        Instead you should use the following approach:\n\n        >>> middleware = [Middleware(...), ...]\n        >>> app = Starlette(middleware=middleware)\n        \"\"\"\n        warnings.warn(\n            \"The `middleware` decorator is deprecated, and will be removed in version 1.0.0. \"\n            \"Refer to https://www.starlette.io/middleware/#using-middleware for recommended approach.\",\n            DeprecationWarning,\n        )\n        assert middleware_type == \"http\", 'Currently only middleware(\"http\") is supported.'\n\n        def decorator(func: Callable) -> Callable:  # type: ignore[type-arg]\n            self.add_middleware(BaseHTTPMiddleware, dispatch=func)\n            return func\n\n        return decorator\n", 250], "/usr/local/lib/python3.11/site-packages/fastapi/applications.py": ["from enum import Enum\nfrom typing import (\n    Any,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Dict,\n    List,\n    Optional,\n    Sequence,\n    Type,\n    TypeVar,\n    Union,\n)\n\nfrom fastapi import routing\nfrom fastapi.datastructures import Default, DefaultPlaceholder\nfrom fastapi.exception_handlers import (\n    http_exception_handler,\n    request_validation_exception_handler,\n    websocket_request_validation_exception_handler,\n)\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.logger import logger\nfrom fastapi.middleware.asyncexitstack import AsyncExitStackMiddleware\nfrom fastapi.openapi.docs import (\n    get_redoc_html,\n    get_swagger_ui_html,\n    get_swagger_ui_oauth2_redirect_html,\n)\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.params import Depends\nfrom fastapi.types import DecoratedCallable, IncEx\nfrom fastapi.utils import generate_unique_id\nfrom starlette.applications import Starlette\nfrom starlette.datastructures import State\nfrom starlette.exceptions import HTTPException\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.middleware.errors import ServerErrorMiddleware\nfrom starlette.middleware.exceptions import ExceptionMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, JSONResponse, Response\nfrom starlette.routing import BaseRoute\nfrom starlette.types import ASGIApp, ExceptionHandler, Lifespan, Receive, Scope, Send\nfrom typing_extensions import Annotated, Doc, deprecated\n\nAppType = TypeVar(\"AppType\", bound=\"FastAPI\")\n\n\nclass FastAPI(Starlette):\n    \"\"\"\n    `FastAPI` app class, the main entrypoint to use FastAPI.\n\n    Read more in the\n    [FastAPI docs for First Steps](https://fastapi.tiangolo.com/tutorial/first-steps/).\n\n    ## Example\n\n    ```python\n    from fastapi import FastAPI\n\n    app = FastAPI()\n    ```\n    \"\"\"\n\n    def __init__(\n        self: AppType,\n        *,\n        debug: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Boolean indicating if debug tracebacks should be returned on server\n                errors.\n\n                Read more in the\n                [Starlette docs for Applications](https://www.starlette.io/applications/#instantiating-the-application).\n                \"\"\"\n            ),\n        ] = False,\n        routes: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                **Note**: you probably shouldn't use this parameter, it is inherited\n                from Starlette and supported for compatibility.\n\n                ---\n\n                A list of routes to serve incoming HTTP and WebSocket requests.\n                \"\"\"\n            ),\n            deprecated(\n                \"\"\"\n                You normally wouldn't use this parameter with FastAPI, it is inherited\n                from Starlette and supported for compatibility.\n\n                In FastAPI, you normally would use the *path operation methods*,\n                like `app.get()`, `app.post()`, etc.\n                \"\"\"\n            ),\n        ] = None,\n        title: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The title of the API.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(title=\"ChimichangApp\")\n                ```\n                \"\"\"\n            ),\n        ] = \"FastAPI\",\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A short summary of the API.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(summary=\"Deadpond's favorite app. Nuff said.\")\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            str,\n            Doc(\n                '''\n                A description of the API. Supports Markdown (using\n                [CommonMark syntax](https://commonmark.org/)).\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(\n                    description=\"\"\"\n                                ChimichangApp API helps you do awesome stuff. \ud83d\ude80\n\n                                ## Items\n\n                                You can **read items**.\n\n                                ## Users\n\n                                You will be able to:\n\n                                * **Create users** (_not implemented_).\n                                * **Read users** (_not implemented_).\n\n                                \"\"\"\n                )\n                ```\n                '''\n            ),\n        ] = \"\",\n        version: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The version of the API.\n\n                **Note** This is the version of your application, not the version of\n                the OpenAPI specification nor the version of FastAPI being used.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(version=\"0.0.1\")\n                ```\n                \"\"\"\n            ),\n        ] = \"0.1.0\",\n        openapi_url: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The URL where the OpenAPI schema will be served from.\n\n                If you set it to `None`, no OpenAPI schema will be served publicly, and\n                the default automatic endpoints `/docs` and `/redoc` will also be\n                disabled.\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#openapi-url).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(openapi_url=\"/api/v1/openapi.json\")\n                ```\n                \"\"\"\n            ),\n        ] = \"/openapi.json\",\n        openapi_tags: Annotated[\n            Optional[List[Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                A list of tags used by OpenAPI, these are the same `tags` you can set\n                in the *path operations*, like:\n\n                * `@app.get(\"/users/\", tags=[\"users\"])`\n                * `@app.get(\"/items/\", tags=[\"items\"])`\n\n                The order of the tags can be used to specify the order shown in\n                tools like Swagger UI, used in the automatic path `/docs`.\n\n                It's not required to specify all the tags used.\n\n                The tags that are not declared MAY be organized randomly or based\n                on the tools' logic. Each tag name in the list MUST be unique.\n\n                The value of each item is a `dict` containing:\n\n                * `name`: The name of the tag.\n                * `description`: A short description of the tag.\n                    [CommonMark syntax](https://commonmark.org/) MAY be used for rich\n                    text representation.\n                * `externalDocs`: Additional external documentation for this tag. If\n                    provided, it would contain a `dict` with:\n                    * `description`: A short description of the target documentation.\n                        [CommonMark syntax](https://commonmark.org/) MAY be used for\n                        rich text representation.\n                    * `url`: The URL for the target documentation. Value MUST be in\n                        the form of a URL.\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-tags).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                tags_metadata = [\n                    {\n                        \"name\": \"users\",\n                        \"description\": \"Operations with users. The **login** logic is also here.\",\n                    },\n                    {\n                        \"name\": \"items\",\n                        \"description\": \"Manage items. So _fancy_ they have their own docs.\",\n                        \"externalDocs\": {\n                            \"description\": \"Items external docs\",\n                            \"url\": \"https://fastapi.tiangolo.com/\",\n                        },\n                    },\n                ]\n\n                app = FastAPI(openapi_tags=tags_metadata)\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        servers: Annotated[\n            Optional[List[Dict[str, Union[str, Any]]]],\n            Doc(\n                \"\"\"\n                A `list` of `dict`s with connectivity information to a target server.\n\n                You would use it, for example, if your application is served from\n                different domains and you want to use the same Swagger UI in the\n                browser to interact with each of them (instead of having multiple\n                browser tabs open). Or if you want to leave fixed the possible URLs.\n\n                If the servers `list` is not provided, or is an empty `list`, the\n                default value would be a `dict` with a `url` value of `/`.\n\n                Each item in the `list` is a `dict` containing:\n\n                * `url`: A URL to the target host. This URL supports Server Variables\n                and MAY be relative, to indicate that the host location is relative\n                to the location where the OpenAPI document is being served. Variable\n                substitutions will be made when a variable is named in `{`brackets`}`.\n                * `description`: An optional string describing the host designated by\n                the URL. [CommonMark syntax](https://commonmark.org/) MAY be used for\n                rich text representation.\n                * `variables`: A `dict` between a variable name and its value. The value\n                    is used for substitution in the server's URL template.\n\n                Read more in the\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#additional-servers).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(\n                    servers=[\n                        {\"url\": \"https://stag.example.com\", \"description\": \"Staging environment\"},\n                        {\"url\": \"https://prod.example.com\", \"description\": \"Production environment\"},\n                    ]\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of global dependencies, they will be applied to each\n                *path operation*, including in sub-routers.\n\n                Read more about it in the\n                [FastAPI docs for Global Dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/).\n\n                **Example**\n\n                ```python\n                from fastapi import Depends, FastAPI\n\n                from .dependencies import func_dep_1, func_dep_2\n\n                app = FastAPI(dependencies=[Depends(func_dep_1), Depends(func_dep_2)])\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        default_response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                The default response class to be used.\n\n                Read more in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n                from fastapi.responses import ORJSONResponse\n\n                app = FastAPI(default_response_class=ORJSONResponse)\n                ```\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        redirect_slashes: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Whether to detect and redirect slashes in URLs when the client doesn't\n                use the same format.\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(redirect_slashes=True)  # the default\n\n                @app.get(\"/items/\")\n                async def read_items():\n                    return [{\"item_id\": \"Foo\"}]\n                ```\n\n                With this app, if a client goes to `/items` (without a trailing slash),\n                they will be automatically redirected with an HTTP status code of 307\n                to `/items/`.\n                \"\"\"\n            ),\n        ] = True,\n        docs_url: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The path to the automatic interactive API documentation.\n                It is handled in the browser by Swagger UI.\n\n                The default URL is `/docs`. You can disable it by setting it to `None`.\n\n                If `openapi_url` is set to `None`, this will be automatically disabled.\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(docs_url=\"/documentation\", redoc_url=None)\n                ```\n                \"\"\"\n            ),\n        ] = \"/docs\",\n        redoc_url: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The path to the alternative automatic interactive API documentation\n                provided by ReDoc.\n\n                The default URL is `/redoc`. You can disable it by setting it to `None`.\n\n                If `openapi_url` is set to `None`, this will be automatically disabled.\n\n                Read more in the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(docs_url=\"/documentation\", redoc_url=\"redocumentation\")\n                ```\n                \"\"\"\n            ),\n        ] = \"/redoc\",\n        swagger_ui_oauth2_redirect_url: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                The OAuth2 redirect endpoint for the Swagger UI.\n\n                By default it is `/docs/oauth2-redirect`.\n\n                This is only used if you use OAuth2 (with the \"Authorize\" button)\n                with Swagger UI.\n                \"\"\"\n            ),\n        ] = \"/docs/oauth2-redirect\",\n        swagger_ui_init_oauth: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                OAuth2 configuration for the Swagger UI, by default shown at `/docs`.\n\n                Read more about the available configuration options in the\n                [Swagger UI docs](https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2/).\n                \"\"\"\n            ),\n        ] = None,\n        middleware: Annotated[\n            Optional[Sequence[Middleware]],\n            Doc(\n                \"\"\"\n                List of middleware to be added when creating the application.\n\n                In FastAPI you would normally do this with `app.add_middleware()`\n                instead.\n\n                Read more in the\n                [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).\n                \"\"\"\n            ),\n        ] = None,\n        exception_handlers: Annotated[\n            Optional[\n                Dict[\n                    Union[int, Type[Exception]],\n                    Callable[[Request, Any], Coroutine[Any, Any, Response]],\n                ]\n            ],\n            Doc(\n                \"\"\"\n                A dictionary with handlers for exceptions.\n\n                In FastAPI, you would normally use the decorator\n                `@app.exception_handler()`.\n\n                Read more in the\n                [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).\n                \"\"\"\n            ),\n        ] = None,\n        on_startup: Annotated[\n            Optional[Sequence[Callable[[], Any]]],\n            Doc(\n                \"\"\"\n                A list of startup event handler functions.\n\n                You should instead use the `lifespan` handlers.\n\n                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        on_shutdown: Annotated[\n            Optional[Sequence[Callable[[], Any]]],\n            Doc(\n                \"\"\"\n                A list of shutdown event handler functions.\n\n                You should instead use the `lifespan` handlers.\n\n                Read more in the\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        lifespan: Annotated[\n            Optional[Lifespan[AppType]],\n            Doc(\n                \"\"\"\n                A `Lifespan` context manager handler. This replaces `startup` and\n                `shutdown` functions with a single context manager.\n\n                Read more in the\n                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).\n                \"\"\"\n            ),\n        ] = None,\n        terms_of_service: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A URL to the Terms of Service for your API.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more at the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                app = FastAPI(terms_of_service=\"http://example.com/terms/\")\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        contact: Annotated[\n            Optional[Dict[str, Union[str, Any]]],\n            Doc(\n                \"\"\"\n                A dictionary with the contact information for the exposed API.\n\n                It can contain several fields.\n\n                * `name`: (`str`) The name of the contact person/organization.\n                * `url`: (`str`) A URL pointing to the contact information. MUST be in\n                    the format of a URL.\n                * `email`: (`str`) The email address of the contact person/organization.\n                    MUST be in the format of an email address.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more at the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                app = FastAPI(\n                    contact={\n                        \"name\": \"Deadpoolio the Amazing\",\n                        \"url\": \"http://x-force.example.com/contact/\",\n                        \"email\": \"dp@x-force.example.com\",\n                    }\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        license_info: Annotated[\n            Optional[Dict[str, Union[str, Any]]],\n            Doc(\n                \"\"\"\n                A dictionary with the license information for the exposed API.\n\n                It can contain several fields.\n\n                * `name`: (`str`) **REQUIRED** (if a `license_info` is set). The\n                    license name used for the API.\n                * `identifier`: (`str`) An [SPDX](https://spdx.dev/) license expression\n                    for the API. The `identifier` field is mutually exclusive of the `url`\n                    field. Available since OpenAPI 3.1.0, FastAPI 0.99.0.\n                * `url`: (`str`) A URL to the license used for the API. This MUST be\n                    the format of a URL.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more at the\n                [FastAPI docs for Metadata and Docs URLs](https://fastapi.tiangolo.com/tutorial/metadata/#metadata-for-api).\n\n                **Example**\n\n                ```python\n                app = FastAPI(\n                    license_info={\n                        \"name\": \"Apache 2.0\",\n                        \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n                    }\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        openapi_prefix: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                A URL prefix for the OpenAPI URL.\n                \"\"\"\n            ),\n            deprecated(\n                \"\"\"\n                \"openapi_prefix\" has been deprecated in favor of \"root_path\", which\n                follows more closely the ASGI standard, is simpler, and more\n                automatic.\n                \"\"\"\n            ),\n        ] = \"\",\n        root_path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                A path prefix handled by a proxy that is not seen by the application\n                but is seen by external clients, which affects things like Swagger UI.\n\n                Read more about it at the\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(root_path=\"/api/v1\")\n                ```\n                \"\"\"\n            ),\n        ] = \"\",\n        root_path_in_servers: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                To disable automatically generating the URLs in the `servers` field\n                in the autogenerated OpenAPI using the `root_path`.\n\n                Read more about it in the\n                [FastAPI docs for Behind a Proxy](https://fastapi.tiangolo.com/advanced/behind-a-proxy/#disable-automatic-server-from-root_path).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI(root_path_in_servers=False)\n                ```\n                \"\"\"\n            ),\n        ] = True,\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses to be shown in OpenAPI.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\n\n                And in the\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                OpenAPI callbacks that should apply to all *path operations*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        webhooks: Annotated[\n            Optional[routing.APIRouter],\n            Doc(\n                \"\"\"\n                Add OpenAPI webhooks. This is similar to `callbacks` but it doesn't\n                depend on specific *path operations*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                **Note**: This is available since OpenAPI 3.1.0, FastAPI 0.99.0.\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark all *path operations* as deprecated. You probably don't need it,\n                but it's available.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                To include (or not) all the *path operations* in the generated OpenAPI.\n                You probably don't need it, but it's available.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        swagger_ui_parameters: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Parameters to configure Swagger UI, the autogenerated interactive API\n                documentation (by default at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs about how to Configure Swagger UI](https://fastapi.tiangolo.com/how-to/configure-swagger-ui/).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n        separate_input_output_schemas: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Whether to generate separate OpenAPI schemas for request body and\n                response body when the results would be more precise.\n\n                This is particularly useful when automatically generating clients.\n\n                For example, if you have a model like:\n\n                ```python\n                from pydantic import BaseModel\n\n                class Item(BaseModel):\n                    name: str\n                    tags: list[str] = []\n                ```\n\n                When `Item` is used for input, a request body, `tags` is not required,\n                the client doesn't have to provide it.\n\n                But when using `Item` for output, for a response body, `tags` is always\n                available because it has a default value, even if it's just an empty\n                list. So, the client should be able to always expect it.\n\n                In this case, there would be two different schemas, one for input and\n                another one for output.\n                \"\"\"\n            ),\n        ] = True,\n        openapi_external_docs: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                This field allows you to provide additional external documentation links.\n                If provided, it must be a dictionary containing:\n\n                * `description`: A brief description of the external documentation.\n                * `url`: The URL pointing to the external documentation. The value **MUST**\n                be a valid URL format.\n\n                **Example**:\n\n                ```python\n                from fastapi import FastAPI\n\n                external_docs = {\n                    \"description\": \"Detailed API Reference\",\n                    \"url\": \"https://example.com/api-docs\",\n                }\n\n                app = FastAPI(openapi_external_docs=external_docs)\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        **extra: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                Extra keyword arguments to be stored in the app, not used by FastAPI\n                anywhere.\n                \"\"\"\n            ),\n        ],\n    ) -> None:\n        self.debug = debug\n        self.title = title\n        self.summary = summary\n        self.description = description\n        self.version = version\n        self.terms_of_service = terms_of_service\n        self.contact = contact\n        self.license_info = license_info\n        self.openapi_url = openapi_url\n        self.openapi_tags = openapi_tags\n        self.root_path_in_servers = root_path_in_servers\n        self.docs_url = docs_url\n        self.redoc_url = redoc_url\n        self.swagger_ui_oauth2_redirect_url = swagger_ui_oauth2_redirect_url\n        self.swagger_ui_init_oauth = swagger_ui_init_oauth\n        self.swagger_ui_parameters = swagger_ui_parameters\n        self.servers = servers or []\n        self.separate_input_output_schemas = separate_input_output_schemas\n        self.openapi_external_docs = openapi_external_docs\n        self.extra = extra\n        self.openapi_version: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The version string of OpenAPI.\n\n                FastAPI will generate OpenAPI version 3.1.0, and will output that as\n                the OpenAPI version. But some tools, even though they might be\n                compatible with OpenAPI 3.1.0, might not recognize it as a valid.\n\n                So you could override this value to trick those tools into using\n                the generated OpenAPI. Have in mind that this is a hack. But if you\n                avoid using features added in OpenAPI 3.1.0, it might work for your\n                use case.\n\n                This is not passed as a parameter to the `FastAPI` class to avoid\n                giving the false idea that FastAPI would generate a different OpenAPI\n                schema. It is only available as an attribute.\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                app = FastAPI()\n\n                app.openapi_version = \"3.0.2\"\n                ```\n                \"\"\"\n            ),\n        ] = \"3.1.0\"\n        self.openapi_schema: Optional[Dict[str, Any]] = None\n        if self.openapi_url:\n            assert self.title, \"A title must be provided for OpenAPI, e.g.: 'My API'\"\n            assert self.version, \"A version must be provided for OpenAPI, e.g.: '2.1.0'\"\n        # TODO: remove when discarding the openapi_prefix parameter\n        if openapi_prefix:\n            logger.warning(\n                '\"openapi_prefix\" has been deprecated in favor of \"root_path\", which '\n                \"follows more closely the ASGI standard, is simpler, and more \"\n                \"automatic. Check the docs at \"\n                \"https://fastapi.tiangolo.com/advanced/sub-applications/\"\n            )\n        self.webhooks: Annotated[\n            routing.APIRouter,\n            Doc(\n                \"\"\"\n                The `app.webhooks` attribute is an `APIRouter` with the *path\n                operations* that will be used just for documentation of webhooks.\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Webhooks](https://fastapi.tiangolo.com/advanced/openapi-webhooks/).\n                \"\"\"\n            ),\n        ] = webhooks or routing.APIRouter()\n        self.root_path = root_path or openapi_prefix\n        self.state: Annotated[\n            State,\n            Doc(\n                \"\"\"\n                A state object for the application. This is the same object for the\n                entire application, it doesn't change from request to request.\n\n                You normally wouldn't use this in FastAPI, for most of the cases you\n                would instead use FastAPI dependencies.\n\n                This is simply inherited from Starlette.\n\n                Read more about it in the\n                [Starlette docs for Applications](https://www.starlette.io/applications/#storing-state-on-the-app-instance).\n                \"\"\"\n            ),\n        ] = State()\n        self.dependency_overrides: Annotated[\n            Dict[Callable[..., Any], Callable[..., Any]],\n            Doc(\n                \"\"\"\n                A dictionary with overrides for the dependencies.\n\n                Each key is the original dependency callable, and the value is the\n                actual dependency that should be called.\n\n                This is for testing, to replace expensive dependencies with testing\n                versions.\n\n                Read more about it in the\n                [FastAPI docs for Testing Dependencies with Overrides](https://fastapi.tiangolo.com/advanced/testing-dependencies/).\n                \"\"\"\n            ),\n        ] = {}\n        self.router: routing.APIRouter = routing.APIRouter(\n            routes=routes,\n            redirect_slashes=redirect_slashes,\n            dependency_overrides_provider=self,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n            lifespan=lifespan,\n            default_response_class=default_response_class,\n            dependencies=dependencies,\n            callbacks=callbacks,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            responses=responses,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n        self.exception_handlers: Dict[\n            Any, Callable[[Request, Any], Union[Response, Awaitable[Response]]]\n        ] = {} if exception_handlers is None else dict(exception_handlers)\n        self.exception_handlers.setdefault(HTTPException, http_exception_handler)\n        self.exception_handlers.setdefault(\n            RequestValidationError, request_validation_exception_handler\n        )\n        self.exception_handlers.setdefault(\n            WebSocketRequestValidationError,\n            # Starlette still has incorrect type specification for the handlers\n            websocket_request_validation_exception_handler,  # type: ignore\n        )\n\n        self.user_middleware: List[Middleware] = (\n            [] if middleware is None else list(middleware)\n        )\n        self.middleware_stack: Union[ASGIApp, None] = None\n        self.setup()\n\n    def build_middleware_stack(self) -> ASGIApp:\n        # Duplicate/override from Starlette to add AsyncExitStackMiddleware\n        # inside of ExceptionMiddleware, inside of custom user middlewares\n        debug = self.debug\n        error_handler = None\n        exception_handlers: dict[Any, ExceptionHandler] = {}\n\n        for key, value in self.exception_handlers.items():\n            if key in (500, Exception):\n                error_handler = value\n            else:\n                exception_handlers[key] = value\n\n        middleware = (\n            [Middleware(ServerErrorMiddleware, handler=error_handler, debug=debug)]\n            + self.user_middleware\n            + [\n                Middleware(\n                    ExceptionMiddleware, handlers=exception_handlers, debug=debug\n                ),\n                # Add FastAPI-specific AsyncExitStackMiddleware for closing files.\n                # Before this was also used for closing dependencies with yield but\n                # those now have their own AsyncExitStack, to properly support\n                # streaming responses while keeping compatibility with the previous\n                # versions (as of writing 0.117.1) that allowed doing\n                # except HTTPException inside a dependency with yield.\n                # This needs to happen after user middlewares because those create a\n                # new contextvars context copy by using a new AnyIO task group.\n                # This AsyncExitStack preserves the context for contextvars, not\n                # strictly necessary for closing files but it was one of the original\n                # intentions.\n                # If the AsyncExitStack lived outside of the custom middlewares and\n                # contextvars were set, for example in a dependency with 'yield'\n                # in that internal contextvars context, the values would not be\n                # available in the outer context of the AsyncExitStack.\n                # By placing the middleware and the AsyncExitStack here, inside all\n                # user middlewares, the same context is used.\n                # This is currently not needed, only for closing files, but used to be\n                # important when dependencies with yield were closed here.\n                Middleware(AsyncExitStackMiddleware),\n            ]\n        )\n\n        app = self.router\n        for cls, args, kwargs in reversed(middleware):\n            app = cls(app, *args, **kwargs)\n        return app\n\n    def openapi(self) -> Dict[str, Any]:\n        \"\"\"\n        Generate the OpenAPI schema of the application. This is called by FastAPI\n        internally.\n\n        The first time it is called it stores the result in the attribute\n        `app.openapi_schema`, and next times it is called, it just returns that same\n        result. To avoid the cost of generating the schema every time.\n\n        If you need to modify the generated OpenAPI schema, you could modify it.\n\n        Read more in the\n        [FastAPI docs for OpenAPI](https://fastapi.tiangolo.com/how-to/extending-openapi/).\n        \"\"\"\n        if not self.openapi_schema:\n            self.openapi_schema = get_openapi(\n                title=self.title,\n                version=self.version,\n                openapi_version=self.openapi_version,\n                summary=self.summary,\n                description=self.description,\n                terms_of_service=self.terms_of_service,\n                contact=self.contact,\n                license_info=self.license_info,\n                routes=self.routes,\n                webhooks=self.webhooks.routes,\n                tags=self.openapi_tags,\n                servers=self.servers,\n                separate_input_output_schemas=self.separate_input_output_schemas,\n                external_docs=self.openapi_external_docs,\n            )\n        return self.openapi_schema\n\n    def setup(self) -> None:\n        if self.openapi_url:\n            urls = (server_data.get(\"url\") for server_data in self.servers)\n            server_urls = {url for url in urls if url}\n\n            async def openapi(req: Request) -> JSONResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                if root_path not in server_urls:\n                    if root_path and self.root_path_in_servers:\n                        self.servers.insert(0, {\"url\": root_path})\n                        server_urls.add(root_path)\n                return JSONResponse(self.openapi())\n\n            self.add_route(self.openapi_url, openapi, include_in_schema=False)\n        if self.openapi_url and self.docs_url:\n\n            async def swagger_ui_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n                if oauth2_redirect_url:\n                    oauth2_redirect_url = root_path + oauth2_redirect_url\n                return get_swagger_ui_html(\n                    openapi_url=openapi_url,\n                    title=f\"{self.title} - Swagger UI\",\n                    oauth2_redirect_url=oauth2_redirect_url,\n                    init_oauth=self.swagger_ui_init_oauth,\n                    swagger_ui_parameters=self.swagger_ui_parameters,\n                )\n\n            self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n\n            if self.swagger_ui_oauth2_redirect_url:\n\n                async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                    return get_swagger_ui_oauth2_redirect_html()\n\n                self.add_route(\n                    self.swagger_ui_oauth2_redirect_url,\n                    swagger_ui_redirect,\n                    include_in_schema=False,\n                )\n        if self.openapi_url and self.redoc_url:\n\n            async def redoc_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                return get_redoc_html(\n                    openapi_url=openapi_url, title=f\"{self.title} - ReDoc\"\n                )\n\n            self.add_route(self.redoc_url, redoc_html, include_in_schema=False)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.root_path:\n            scope[\"root_path\"] = self.root_path\n        await super().__call__(scope, receive, send)\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Callable[[routing.APIRoute], str] = Default(\n            generate_unique_id\n        ),\n    ) -> None:\n        self.router.add_api_route(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Any = Default(None),\n        status_code: Optional[int] = None,\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[IncEx] = None,\n        response_model_exclude: Optional[IncEx] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        openapi_extra: Optional[Dict[str, Any]] = None,\n        generate_unique_id_function: Callable[[routing.APIRoute], str] = Default(\n            generate_unique_id\n        ),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                openapi_extra=openapi_extra,\n                generate_unique_id_function=generate_unique_id_function,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        name: Optional[str] = None,\n        *,\n        dependencies: Optional[Sequence[Depends]] = None,\n    ) -> None:\n        self.router.add_api_websocket_route(\n            path,\n            endpoint,\n            name=name,\n            dependencies=dependencies,\n        )\n\n    def websocket(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                WebSocket path.\n                \"\"\"\n            ),\n        ],\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A name for the WebSocket. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        *,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be used for this\n                WebSocket.\n\n                Read more about it in the\n                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n                \"\"\"\n            ),\n        ] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Decorate a WebSocket function.\n\n        Read more about it in the\n        [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).\n\n        **Example**\n\n        ```python\n        from fastapi import FastAPI, WebSocket\n\n        app = FastAPI()\n\n        @app.websocket(\"/ws\")\n        async def websocket_endpoint(websocket: WebSocket):\n            await websocket.accept()\n            while True:\n                data = await websocket.receive_text()\n                await websocket.send_text(f\"Message text was: {data}\")\n        ```\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(\n                path,\n                func,\n                name=name,\n                dependencies=dependencies,\n            )\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: Annotated[routing.APIRouter, Doc(\"The `APIRouter` to include.\")],\n        *,\n        prefix: Annotated[str, Doc(\"An optional path prefix for the router.\")] = \"\",\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to all the *path operations* in this\n                router.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to all the\n                *path operations* in this router.\n\n                Read more about it in the\n                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n\n                **Example**\n\n                ```python\n                from fastapi import Depends, FastAPI\n\n                from .dependencies import get_token_header\n                from .internal import admin\n\n                app = FastAPI()\n\n                app.include_router(\n                    admin.router,\n                    dependencies=[Depends(get_token_header)],\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses to be shown in OpenAPI.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).\n\n                And in the\n                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark all the *path operations* in this router as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                from .internal import old_api\n\n                app = FastAPI()\n\n                app.include_router(\n                    old_api.router,\n                    deprecated=True,\n                )\n                ```\n                \"\"\"\n            ),\n        ] = None,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include (or not) all the *path operations* in this router in the\n                generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n\n                from .internal import old_api\n\n                app = FastAPI()\n\n                app.include_router(\n                    old_api.router,\n                    include_in_schema=False,\n                )\n                ```\n                \"\"\"\n            ),\n        ] = True,\n        default_response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Default response class to be used for the *path operations* in this\n                router.\n\n                Read more in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).\n\n                **Example**\n\n                ```python\n                from fastapi import FastAPI\n                from fastapi.responses import ORJSONResponse\n\n                from .internal import old_api\n\n                app = FastAPI()\n\n                app.include_router(\n                    old_api.router,\n                    default_response_class=ORJSONResponse,\n                )\n                ```\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> None:\n        \"\"\"\n        Include an `APIRouter` in the same app.\n\n        Read more about it in the\n        [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        from .users import users_router\n\n        app = FastAPI()\n\n        app.include_router(users_router)\n        ```\n        \"\"\"\n        self.router.include_router(\n            router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            responses=responses,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            default_response_class=default_response_class,\n            callbacks=callbacks,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def get(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP GET operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.get(\"/items/\")\n        def read_items():\n            return [{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}]\n        ```\n        \"\"\"\n        return self.router.get(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def put(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP PUT operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.put(\"/items/{item_id}\")\n        def replace_item(item_id: str, item: Item):\n            return {\"message\": \"Item replaced\", \"id\": item_id}\n        ```\n        \"\"\"\n        return self.router.put(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def post(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP POST operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.post(\"/items/\")\n        def create_item(item: Item):\n            return {\"message\": \"Item created\"}\n        ```\n        \"\"\"\n        return self.router.post(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def delete(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP DELETE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.delete(\"/items/{item_id}\")\n        def delete_item(item_id: str):\n            return {\"message\": \"Item deleted\"}\n        ```\n        \"\"\"\n        return self.router.delete(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def options(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP OPTIONS operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.options(\"/items/\")\n        def get_item_options():\n            return {\"additions\": [\"Aji\", \"Guacamole\"]}\n        ```\n        \"\"\"\n        return self.router.options(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def head(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP HEAD operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI, Response\n\n        app = FastAPI()\n\n        @app.head(\"/items/\", status_code=204)\n        def get_items_headers(response: Response):\n            response.headers[\"X-Cat-Dog\"] = \"Alone in the world\"\n        ```\n        \"\"\"\n        return self.router.head(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def patch(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP PATCH operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n        from pydantic import BaseModel\n\n        class Item(BaseModel):\n            name: str\n            description: str | None = None\n\n        app = FastAPI()\n\n        @app.patch(\"/items/\")\n        def update_item(item: Item):\n            return {\"message\": \"Item updated in place\"}\n        ```\n        \"\"\"\n        return self.router.patch(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def trace(\n        self,\n        path: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The URL path to be used for this *path operation*.\n\n                For example, in `http://example.com/items`, the path is `/items`.\n                \"\"\"\n            ),\n        ],\n        *,\n        response_model: Annotated[\n            Any,\n            Doc(\n                \"\"\"\n                The type to use for the response.\n\n                It could be any valid Pydantic *field* type. So, it doesn't have to\n                be a Pydantic model, it could be other things, like a `list`, `dict`,\n                etc.\n\n                It will be used for:\n\n                * Documentation: the generated OpenAPI (and the UI at `/docs`) will\n                    show it as the response (JSON Schema).\n                * Serialization: you could return an arbitrary object and the\n                    `response_model` would be used to serialize that object into the\n                    corresponding JSON.\n                * Filtering: the JSON sent to the client will only contain the data\n                    (fields) defined in the `response_model`. If you returned an object\n                    that contains an attribute `password` but the `response_model` does\n                    not include that field, the JSON sent to the client would not have\n                    that `password`.\n                * Validation: whatever you return will be serialized with the\n                    `response_model`, converting any data as necessary to generate the\n                    corresponding JSON. But if the data in the object returned is not\n                    valid, that would mean a violation of the contract with the client,\n                    so it's an error from the API developer. So, FastAPI will raise an\n                    error and return a 500 error code (Internal Server Error).\n\n                Read more about it in the\n                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).\n                \"\"\"\n            ),\n        ] = Default(None),\n        status_code: Annotated[\n            Optional[int],\n            Doc(\n                \"\"\"\n                The default status code to be used for the response.\n\n                You could override the status code by returning a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).\n                \"\"\"\n            ),\n        ] = None,\n        tags: Annotated[\n            Optional[List[Union[str, Enum]]],\n            Doc(\n                \"\"\"\n                A list of tags to be applied to the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).\n                \"\"\"\n            ),\n        ] = None,\n        dependencies: Annotated[\n            Optional[Sequence[Depends]],\n            Doc(\n                \"\"\"\n                A list of dependencies (using `Depends()`) to be applied to the\n                *path operation*.\n\n                Read more about it in the\n                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).\n                \"\"\"\n            ),\n        ] = None,\n        summary: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A summary for the *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        description: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                A description for the *path operation*.\n\n                If not provided, it will be extracted automatically from the docstring\n                of the *path operation function*.\n\n                It can contain Markdown.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).\n                \"\"\"\n            ),\n        ] = None,\n        response_description: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The description for the default response.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = \"Successful Response\",\n        responses: Annotated[\n            Optional[Dict[Union[int, str], Dict[str, Any]]],\n            Doc(\n                \"\"\"\n                Additional responses that could be returned by this *path operation*.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        deprecated: Annotated[\n            Optional[bool],\n            Doc(\n                \"\"\"\n                Mark this *path operation* as deprecated.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n                \"\"\"\n            ),\n        ] = None,\n        operation_id: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Custom operation ID to be used by this *path operation*.\n\n                By default, it is generated automatically.\n\n                If you provide a custom operation ID, you need to make sure it is\n                unique for the whole API.\n\n                You can customize the\n                operation ID generation with the parameter\n                `generate_unique_id_function` in the `FastAPI` class.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_include: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to include only certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_exclude: Annotated[\n            Optional[IncEx],\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to exclude certain fields in the\n                response data.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = None,\n        response_model_by_alias: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response model\n                should be serialized by alias when an alias is used.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).\n                \"\"\"\n            ),\n        ] = True,\n        response_model_exclude_unset: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that were not set and\n                have their default values. This is different from\n                `response_model_exclude_defaults` in that if the fields are set,\n                they will be included in the response, even if the value is the same\n                as the default.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_defaults: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data\n                should have all the fields, including the ones that have the same value\n                as the default. This is different from `response_model_exclude_unset`\n                in that if the fields are set but contain the same default values,\n                they will be excluded from the response.\n\n                When `True`, default values are omitted from the response.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).\n                \"\"\"\n            ),\n        ] = False,\n        response_model_exclude_none: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Configuration passed to Pydantic to define if the response data should\n                exclude fields set to `None`.\n\n                This is much simpler (less smart) than `response_model_exclude_unset`\n                and `response_model_exclude_defaults`. You probably want to use one of\n                those two instead of this one, as those allow returning `None` values\n                when it makes sense.\n\n                Read more about it in the\n                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).\n                \"\"\"\n            ),\n        ] = False,\n        include_in_schema: Annotated[\n            bool,\n            Doc(\n                \"\"\"\n                Include this *path operation* in the generated OpenAPI schema.\n\n                This affects the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-parameters-from-openapi).\n                \"\"\"\n            ),\n        ] = True,\n        response_class: Annotated[\n            Type[Response],\n            Doc(\n                \"\"\"\n                Response class to be used for this *path operation*.\n\n                This will not be used if you return a response directly.\n\n                Read more about it in the\n                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).\n                \"\"\"\n            ),\n        ] = Default(JSONResponse),\n        name: Annotated[\n            Optional[str],\n            Doc(\n                \"\"\"\n                Name for this *path operation*. Only used internally.\n                \"\"\"\n            ),\n        ] = None,\n        callbacks: Annotated[\n            Optional[List[BaseRoute]],\n            Doc(\n                \"\"\"\n                List of *path operations* that will be used as OpenAPI callbacks.\n\n                This is only for OpenAPI documentation, the callbacks won't be used\n                directly.\n\n                It will be added to the generated OpenAPI (e.g. visible at `/docs`).\n\n                Read more about it in the\n                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).\n                \"\"\"\n            ),\n        ] = None,\n        openapi_extra: Annotated[\n            Optional[Dict[str, Any]],\n            Doc(\n                \"\"\"\n                Extra metadata to be included in the OpenAPI schema for this *path\n                operation*.\n\n                Read more about it in the\n                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).\n                \"\"\"\n            ),\n        ] = None,\n        generate_unique_id_function: Annotated[\n            Callable[[routing.APIRoute], str],\n            Doc(\n                \"\"\"\n                Customize the function used to generate unique IDs for the *path\n                operations* shown in the generated OpenAPI.\n\n                This is particularly useful when automatically generating clients or\n                SDKs for your API.\n\n                Read more about it in the\n                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).\n                \"\"\"\n            ),\n        ] = Default(generate_unique_id),\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a *path operation* using an HTTP TRACE operation.\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI\n\n        app = FastAPI()\n\n        @app.trace(\"/items/{item_id}\")\n        def trace_item(item_id: str):\n            return None\n        ```\n        \"\"\"\n        return self.router.trace(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n            openapi_extra=openapi_extra,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    def websocket_route(\n        self, path: str, name: Union[str, None] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.router.add_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    @deprecated(\n        \"\"\"\n        on_event is deprecated, use lifespan event handlers instead.\n\n        Read more about it in the\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).\n        \"\"\"\n    )\n    def on_event(\n        self,\n        event_type: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The type of event. `startup` or `shutdown`.\n                \"\"\"\n            ),\n        ],\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add an event handler for the application.\n\n        `on_event` is deprecated, use `lifespan` event handlers instead.\n\n        Read more about it in the\n        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).\n        \"\"\"\n        return self.router.on_event(event_type)\n\n    def middleware(\n        self,\n        middleware_type: Annotated[\n            str,\n            Doc(\n                \"\"\"\n                The type of middleware. Currently only supports `http`.\n                \"\"\"\n            ),\n        ],\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add a middleware to the application.\n\n        Read more about it in the\n        [FastAPI docs for Middleware](https://fastapi.tiangolo.com/tutorial/middleware/).\n\n        ## Example\n\n        ```python\n        import time\n        from typing import Awaitable, Callable\n\n        from fastapi import FastAPI, Request, Response\n\n        app = FastAPI()\n\n\n        @app.middleware(\"http\")\n        async def add_process_time_header(\n            request: Request, call_next: Callable[[Request], Awaitable[Response]]\n        ) -> Response:\n            start_time = time.time()\n            response = await call_next(request)\n            process_time = time.time() - start_time\n            response.headers[\"X-Process-Time\"] = str(process_time)\n            return response\n        ```\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_middleware(BaseHTTPMiddleware, dispatch=func)\n            return func\n\n        return decorator\n\n    def exception_handler(\n        self,\n        exc_class_or_status_code: Annotated[\n            Union[int, Type[Exception]],\n            Doc(\n                \"\"\"\n                The Exception class this would handle, or a status code.\n                \"\"\"\n            ),\n        ],\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        \"\"\"\n        Add an exception handler to the app.\n\n        Read more about it in the\n        [FastAPI docs for Handling Errors](https://fastapi.tiangolo.com/tutorial/handling-errors/).\n\n        ## Example\n\n        ```python\n        from fastapi import FastAPI, Request\n        from fastapi.responses import JSONResponse\n\n\n        class UnicornException(Exception):\n            def __init__(self, name: str):\n                self.name = name\n\n\n        app = FastAPI()\n\n\n        @app.exception_handler(UnicornException)\n        async def unicorn_exception_handler(request: Request, exc: UnicornException):\n            return JSONResponse(\n                status_code=418,\n                content={\"message\": f\"Oops! {exc.name} did something. There goes a rainbow...\"},\n            )\n        ```\n        \"\"\"\n\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_exception_handler(exc_class_or_status_code, func)\n            return func\n\n        return decorator\n", 4667], "/usr/local/lib/python3.11/site-packages/uvicorn/middleware/proxy_headers.py": ["from __future__ import annotations\n\nimport ipaddress\n\nfrom uvicorn._types import ASGI3Application, ASGIReceiveCallable, ASGISendCallable, Scope\n\n\nclass ProxyHeadersMiddleware:\n    \"\"\"Middleware for handling known proxy headers\n\n    This middleware can be used when a known proxy is fronting the application,\n    and is trusted to be properly setting the `X-Forwarded-Proto` and\n    `X-Forwarded-For` headers with the connecting client information.\n\n    Modifies the `client` and `scheme` information so that they reference\n    the connecting client, rather that the connecting proxy.\n\n    References:\n    - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#Proxies>\n    - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For>\n    \"\"\"\n\n    def __init__(self, app: ASGI3Application, trusted_hosts: list[str] | str = \"127.0.0.1\") -> None:\n        self.app = app\n        self.trusted_hosts = _TrustedHosts(trusted_hosts)\n\n    async def __call__(self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n        if scope[\"type\"] == \"lifespan\":\n            return await self.app(scope, receive, send)\n\n        client_addr = scope.get(\"client\")\n        client_host = client_addr[0] if client_addr else None\n\n        if client_host in self.trusted_hosts:\n            headers = dict(scope[\"headers\"])\n\n            if b\"x-forwarded-proto\" in headers:\n                x_forwarded_proto = headers[b\"x-forwarded-proto\"].decode(\"latin1\").strip()\n\n                if x_forwarded_proto in {\"http\", \"https\", \"ws\", \"wss\"}:\n                    if scope[\"type\"] == \"websocket\":\n                        scope[\"scheme\"] = x_forwarded_proto.replace(\"http\", \"ws\")\n                    else:\n                        scope[\"scheme\"] = x_forwarded_proto\n\n            if b\"x-forwarded-for\" in headers:\n                x_forwarded_for = headers[b\"x-forwarded-for\"].decode(\"latin1\")\n                host = self.trusted_hosts.get_trusted_client_host(x_forwarded_for)\n\n                if host:\n                    # If the x-forwarded-for header is empty then host is an empty string.\n                    # Only set the client if we actually got something usable.\n                    # See: https://github.com/Kludex/uvicorn/issues/1068\n\n                    # We've lost the connecting client's port information by now,\n                    # so only include the host.\n                    port = 0\n                    scope[\"client\"] = (host, port)\n\n        return await self.app(scope, receive, send)\n\n\ndef _parse_raw_hosts(value: str) -> list[str]:\n    return [item.strip() for item in value.split(\",\")]\n\n\nclass _TrustedHosts:\n    \"\"\"Container for trusted hosts and networks\"\"\"\n\n    def __init__(self, trusted_hosts: list[str] | str) -> None:\n        self.always_trust: bool = trusted_hosts in (\"*\", [\"*\"])\n\n        self.trusted_literals: set[str] = set()\n        self.trusted_hosts: set[ipaddress.IPv4Address | ipaddress.IPv6Address] = set()\n        self.trusted_networks: set[ipaddress.IPv4Network | ipaddress.IPv6Network] = set()\n\n        # Notes:\n        # - We separate hosts from literals as there are many ways to write\n        #   an IPv6 Address so we need to compare by object.\n        # - We don't convert IP Address to single host networks (e.g. /32 / 128) as\n        #   it more efficient to do an address lookup in a set than check for\n        #   membership in each network.\n        # - We still allow literals as it might be possible that we receive a\n        #   something that isn't an IP Address e.g. a unix socket.\n\n        if not self.always_trust:\n            if isinstance(trusted_hosts, str):\n                trusted_hosts = _parse_raw_hosts(trusted_hosts)\n\n            for host in trusted_hosts:\n                # Note: because we always convert invalid IP types to literals it\n                # is not possible for the user to know they provided a malformed IP\n                # type - this may lead to unexpected / difficult to debug behaviour.\n\n                if \"/\" in host:\n                    # Looks like a network\n                    try:\n                        self.trusted_networks.add(ipaddress.ip_network(host))\n                    except ValueError:\n                        # Was not a valid IP Network\n                        self.trusted_literals.add(host)\n                else:\n                    try:\n                        self.trusted_hosts.add(ipaddress.ip_address(host))\n                    except ValueError:\n                        # Was not a valid IP Address\n                        self.trusted_literals.add(host)\n\n    def __contains__(self, host: str | None) -> bool:\n        if self.always_trust:\n            return True\n\n        if not host:\n            return False\n\n        try:\n            ip = ipaddress.ip_address(host)\n            if ip in self.trusted_hosts:\n                return True\n            return any(ip in net for net in self.trusted_networks)\n\n        except ValueError:\n            return host in self.trusted_literals\n\n    def get_trusted_client_host(self, x_forwarded_for: str) -> str:\n        \"\"\"Extract the client host from x_forwarded_for header\n\n        In general this is the first \"untrusted\" host in the forwarded for list.\n        \"\"\"\n        x_forwarded_for_hosts = _parse_raw_hosts(x_forwarded_for)\n\n        if self.always_trust:\n            return x_forwarded_for_hosts[0]\n\n        # Note: each proxy appends to the header list so check it in reverse order\n        for host in reversed(x_forwarded_for_hosts):\n            if host not in self:\n                return host\n\n        # All hosts are trusted meaning that the client was also a trusted proxy\n        # See https://github.com/Kludex/uvicorn/issues/1068#issuecomment-855371576\n        return x_forwarded_for_hosts[0]\n", 142], "/usr/local/lib/python3.11/site-packages/uvicorn/protocols/http/httptools_impl.py": ["from __future__ import annotations\n\nimport asyncio\nimport http\nimport logging\nimport re\nimport urllib\nfrom asyncio.events import TimerHandle\nfrom collections import deque\nfrom typing import Any, Callable, Literal, cast\n\nimport httptools\n\nfrom uvicorn._types import (\n    ASGI3Application,\n    ASGIReceiveEvent,\n    ASGISendEvent,\n    HTTPRequestEvent,\n    HTTPResponseStartEvent,\n    HTTPScope,\n)\nfrom uvicorn.config import Config\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.protocols.http.flow_control import CLOSE_HEADER, HIGH_WATER_LIMIT, FlowControl, service_unavailable\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_path_with_query_string, get_remote_addr, is_ssl\nfrom uvicorn.server import ServerState\n\nHEADER_RE = re.compile(b'[\\x00-\\x1f\\x7f()<>@,;:[]={} \\t\\\\\"]')\nHEADER_VALUE_RE = re.compile(b\"[\\x00-\\x08\\x0a-\\x1f\\x7f]\")\n\n\ndef _get_status_line(status_code: int) -> bytes:\n    try:\n        phrase = http.HTTPStatus(status_code).phrase.encode()\n    except ValueError:\n        phrase = b\"\"\n    return b\"\".join([b\"HTTP/1.1 \", str(status_code).encode(), b\" \", phrase, b\"\\r\\n\"])\n\n\nSTATUS_LINE = {status_code: _get_status_line(status_code) for status_code in range(100, 600)}\n\n\nclass HttpToolsProtocol(asyncio.Protocol):\n    def __init__(\n        self,\n        config: Config,\n        server_state: ServerState,\n        app_state: dict[str, Any],\n        _loop: asyncio.AbstractEventLoop | None = None,\n    ) -> None:\n        if not config.loaded:\n            config.load()\n\n        self.config = config\n        self.app = config.loaded_app\n        self.loop = _loop or asyncio.get_event_loop()\n        self.logger = logging.getLogger(\"uvicorn.error\")\n        self.access_logger = logging.getLogger(\"uvicorn.access\")\n        self.access_log = self.access_logger.hasHandlers()\n        self.parser = httptools.HttpRequestParser(self)\n\n        try:\n            # Enable dangerous leniencies to allow server to a response on the first request from a pipelined request.\n            self.parser.set_dangerous_leniencies(lenient_data_after_close=True)\n        except AttributeError:  # pragma: no cover\n            # httptools < 0.6.3\n            pass\n\n        self.ws_protocol_class = config.ws_protocol_class\n        self.root_path = config.root_path\n        self.limit_concurrency = config.limit_concurrency\n        self.app_state = app_state\n\n        # Timeouts\n        self.timeout_keep_alive_task: TimerHandle | None = None\n        self.timeout_keep_alive = config.timeout_keep_alive\n\n        # Global state\n        self.server_state = server_state\n        self.connections = server_state.connections\n        self.tasks = server_state.tasks\n\n        # Per-connection state\n        self.transport: asyncio.Transport = None  # type: ignore[assignment]\n        self.flow: FlowControl = None  # type: ignore[assignment]\n        self.server: tuple[str, int] | None = None\n        self.client: tuple[str, int] | None = None\n        self.scheme: Literal[\"http\", \"https\"] | None = None\n        self.pipeline: deque[tuple[RequestResponseCycle, ASGI3Application]] = deque()\n\n        # Per-request state\n        self.scope: HTTPScope = None  # type: ignore[assignment]\n        self.headers: list[tuple[bytes, bytes]] = None  # type: ignore[assignment]\n        self.expect_100_continue = False\n        self.cycle: RequestResponseCycle = None  # type: ignore[assignment]\n\n    # Protocol interface\n    def connection_made(  # type: ignore[override]\n        self, transport: asyncio.Transport\n    ) -> None:\n        self.connections.add(self)\n\n        self.transport = transport\n        self.flow = FlowControl(transport)\n        self.server = get_local_addr(transport)\n        self.client = get_remote_addr(transport)\n        self.scheme = \"https\" if is_ssl(transport) else \"http\"\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection made\", prefix)\n\n    def connection_lost(self, exc: Exception | None) -> None:\n        self.connections.discard(self)\n\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sHTTP connection lost\", prefix)\n\n        if self.cycle and not self.cycle.response_complete:\n            self.cycle.disconnected = True\n        if self.cycle is not None:\n            self.cycle.message_event.set()\n        if self.flow is not None:\n            self.flow.resume_writing()\n        if exc is None:\n            self.transport.close()\n            self._unset_keepalive_if_required()\n\n        self.parser = None\n\n    def eof_received(self) -> None:\n        pass\n\n    def _unset_keepalive_if_required(self) -> None:\n        if self.timeout_keep_alive_task is not None:\n            self.timeout_keep_alive_task.cancel()\n            self.timeout_keep_alive_task = None\n\n    def _get_upgrade(self) -> bytes | None:\n        connection = []\n        upgrade = None\n        for name, value in self.headers:\n            if name == b\"connection\":\n                connection = [token.lower().strip() for token in value.split(b\",\")]\n            if name == b\"upgrade\":\n                upgrade = value.lower()\n        if b\"upgrade\" in connection:\n            return upgrade\n        return None  # pragma: full coverage\n\n    def _should_upgrade_to_ws(self) -> bool:\n        if self.ws_protocol_class is None:\n            return False\n        return True\n\n    def _unsupported_upgrade_warning(self) -> None:\n        self.logger.warning(\"Unsupported upgrade request.\")\n        if not self._should_upgrade_to_ws():\n            msg = \"No supported WebSocket library detected. Please use \\\"pip install 'uvicorn[standard]'\\\", or install 'websockets' or 'wsproto' manually.\"  # noqa: E501\n            self.logger.warning(msg)\n\n    def _should_upgrade(self) -> bool:\n        upgrade = self._get_upgrade()\n        return upgrade == b\"websocket\" and self._should_upgrade_to_ws()\n\n    def data_received(self, data: bytes) -> None:\n        self._unset_keepalive_if_required()\n\n        try:\n            self.parser.feed_data(data)\n        except httptools.HttpParserError:\n            msg = \"Invalid HTTP request received.\"\n            self.logger.warning(msg)\n            self.send_400_response(msg)\n            return\n        except httptools.HttpParserUpgrade:\n            if self._should_upgrade():\n                self.handle_websocket_upgrade()\n            else:\n                self._unsupported_upgrade_warning()\n\n    def handle_websocket_upgrade(self) -> None:\n        if self.logger.level <= TRACE_LOG_LEVEL:\n            prefix = \"%s:%d - \" % self.client if self.client else \"\"\n            self.logger.log(TRACE_LOG_LEVEL, \"%sUpgrading to WebSocket\", prefix)\n\n        self.connections.discard(self)\n        method = self.scope[\"method\"].encode()\n        output = [method, b\" \", self.url, b\" HTTP/1.1\\r\\n\"]\n        for name, value in self.scope[\"headers\"]:\n            output += [name, b\": \", value, b\"\\r\\n\"]\n        output.append(b\"\\r\\n\")\n        protocol = self.ws_protocol_class(  # type: ignore[call-arg, misc]\n            config=self.config,\n            server_state=self.server_state,\n            app_state=self.app_state,\n        )\n        protocol.connection_made(self.transport)\n        protocol.data_received(b\"\".join(output))\n        self.transport.set_protocol(protocol)\n\n    def send_400_response(self, msg: str) -> None:\n        content = [STATUS_LINE[400]]\n        for name, value in self.server_state.default_headers:\n            content.extend([name, b\": \", value, b\"\\r\\n\"])  # pragma: full coverage\n        content.extend(\n            [\n                b\"content-type: text/plain; charset=utf-8\\r\\n\",\n                b\"content-length: \" + str(len(msg)).encode(\"ascii\") + b\"\\r\\n\",\n                b\"connection: close\\r\\n\",\n                b\"\\r\\n\",\n                msg.encode(\"ascii\"),\n            ]\n        )\n        self.transport.write(b\"\".join(content))\n        self.transport.close()\n\n    def on_message_begin(self) -> None:\n        self.url = b\"\"\n        self.expect_100_continue = False\n        self.headers = []\n        self.scope = {  # type: ignore[typeddict-item]\n            \"type\": \"http\",\n            \"asgi\": {\"version\": self.config.asgi_version, \"spec_version\": \"2.3\"},\n            \"http_version\": \"1.1\",\n            \"server\": self.server,\n            \"client\": self.client,\n            \"scheme\": self.scheme,  # type: ignore[typeddict-item]\n            \"root_path\": self.root_path,\n            \"headers\": self.headers,\n            \"state\": self.app_state.copy(),\n        }\n\n    # Parser callbacks\n    def on_url(self, url: bytes) -> None:\n        self.url += url\n\n    def on_header(self, name: bytes, value: bytes) -> None:\n        name = name.lower()\n        if name == b\"expect\" and value.lower() == b\"100-continue\":\n            self.expect_100_continue = True\n        self.headers.append((name, value))\n\n    def on_headers_complete(self) -> None:\n        http_version = self.parser.get_http_version()\n        method = self.parser.get_method()\n        self.scope[\"method\"] = method.decode(\"ascii\")\n        if http_version != \"1.1\":\n            self.scope[\"http_version\"] = http_version\n        if self.parser.should_upgrade() and self._should_upgrade():\n            return\n        parsed_url = httptools.parse_url(self.url)\n        raw_path = parsed_url.path\n        path = raw_path.decode(\"ascii\")\n        if \"%\" in path:\n            path = urllib.parse.unquote(path)\n        full_path = self.root_path + path\n        full_raw_path = self.root_path.encode(\"ascii\") + raw_path\n        self.scope[\"path\"] = full_path\n        self.scope[\"raw_path\"] = full_raw_path\n        self.scope[\"query_string\"] = parsed_url.query or b\"\"\n\n        # Handle 503 responses when 'limit_concurrency' is exceeded.\n        if self.limit_concurrency is not None and (\n            len(self.connections) >= self.limit_concurrency or len(self.tasks) >= self.limit_concurrency\n        ):\n            app = service_unavailable\n            message = \"Exceeded concurrency limit.\"\n            self.logger.warning(message)\n        else:\n            app = self.app\n\n        existing_cycle = self.cycle\n        self.cycle = RequestResponseCycle(\n            scope=self.scope,\n            transport=self.transport,\n            flow=self.flow,\n            logger=self.logger,\n            access_logger=self.access_logger,\n            access_log=self.access_log,\n            default_headers=self.server_state.default_headers,\n            message_event=asyncio.Event(),\n            expect_100_continue=self.expect_100_continue,\n            keep_alive=http_version != \"1.0\",\n            on_response=self.on_response_complete,\n        )\n        if existing_cycle is None or existing_cycle.response_complete:\n            # Standard case - start processing the request.\n            task = self.loop.create_task(self.cycle.run_asgi(app))\n            task.add_done_callback(self.tasks.discard)\n            self.tasks.add(task)\n        else:\n            # Pipelined HTTP requests need to be queued up.\n            self.flow.pause_reading()\n            self.pipeline.appendleft((self.cycle, app))\n\n    def on_body(self, body: bytes) -> None:\n        if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete:\n            return\n        self.cycle.body += body\n        if len(self.cycle.body) > HIGH_WATER_LIMIT:\n            self.flow.pause_reading()\n        self.cycle.message_event.set()\n\n    def on_message_complete(self) -> None:\n        if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete:\n            return\n        self.cycle.more_body = False\n        self.cycle.message_event.set()\n\n    def on_response_complete(self) -> None:\n        # Callback for pipelined HTTP requests to be started.\n        self.server_state.total_requests += 1\n\n        if self.transport.is_closing():\n            return\n\n        self._unset_keepalive_if_required()\n\n        # Unpause data reads if needed.\n        self.flow.resume_reading()\n\n        # Unblock any pipelined events. If there are none, arm the\n        # Keep-Alive timeout instead.\n        if self.pipeline:\n            cycle, app = self.pipeline.pop()\n            task = self.loop.create_task(cycle.run_asgi(app))\n            task.add_done_callback(self.tasks.discard)\n            self.tasks.add(task)\n        else:\n            self.timeout_keep_alive_task = self.loop.call_later(\n                self.timeout_keep_alive, self.timeout_keep_alive_handler\n            )\n\n    def shutdown(self) -> None:\n        \"\"\"\n        Called by the server to commence a graceful shutdown.\n        \"\"\"\n        if self.cycle is None or self.cycle.response_complete:\n            self.transport.close()\n        else:\n            self.cycle.keep_alive = False\n\n    def pause_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer exceeds the high water mark.\n        \"\"\"\n        self.flow.pause_writing()  # pragma: full coverage\n\n    def resume_writing(self) -> None:\n        \"\"\"\n        Called by the transport when the write buffer drops below the low water mark.\n        \"\"\"\n        self.flow.resume_writing()  # pragma: full coverage\n\n    def timeout_keep_alive_handler(self) -> None:\n        \"\"\"\n        Called on a keep-alive connection if no new data is received after a short\n        delay.\n        \"\"\"\n        if not self.transport.is_closing():\n            self.transport.close()\n\n\nclass RequestResponseCycle:\n    def __init__(\n        self,\n        scope: HTTPScope,\n        transport: asyncio.Transport,\n        flow: FlowControl,\n        logger: logging.Logger,\n        access_logger: logging.Logger,\n        access_log: bool,\n        default_headers: list[tuple[bytes, bytes]],\n        message_event: asyncio.Event,\n        expect_100_continue: bool,\n        keep_alive: bool,\n        on_response: Callable[..., None],\n    ):\n        self.scope = scope\n        self.transport = transport\n        self.flow = flow\n        self.logger = logger\n        self.access_logger = access_logger\n        self.access_log = access_log\n        self.default_headers = default_headers\n        self.message_event = message_event\n        self.on_response = on_response\n\n        # Connection state\n        self.disconnected = False\n        self.keep_alive = keep_alive\n        self.waiting_for_100_continue = expect_100_continue\n\n        # Request state\n        self.body = b\"\"\n        self.more_body = True\n\n        # Response state\n        self.response_started = False\n        self.response_complete = False\n        self.chunked_encoding: bool | None = None\n        self.expected_content_length = 0\n\n    # ASGI exception wrapper\n    async def run_asgi(self, app: ASGI3Application) -> None:\n        try:\n            result = await app(  # type: ignore[func-returns-value]\n                self.scope, self.receive, self.send\n            )\n        except BaseException as exc:\n            msg = \"Exception in ASGI application\\n\"\n            self.logger.error(msg, exc_info=exc)\n            if not self.response_started:\n                await self.send_500_response()\n            else:\n                self.transport.close()\n        else:\n            if result is not None:\n                msg = \"ASGI callable should return None, but returned '%s'.\"\n                self.logger.error(msg, result)\n                self.transport.close()\n            elif not self.response_started and not self.disconnected:\n                msg = \"ASGI callable returned without starting response.\"\n                self.logger.error(msg)\n                await self.send_500_response()\n            elif not self.response_complete and not self.disconnected:\n                msg = \"ASGI callable returned without completing response.\"\n                self.logger.error(msg)\n                self.transport.close()\n        finally:\n            self.on_response = lambda: None\n\n    async def send_500_response(self) -> None:\n        await self.send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 500,\n                \"headers\": [\n                    (b\"content-type\", b\"text/plain; charset=utf-8\"),\n                    (b\"content-length\", b\"21\"),\n                    (b\"connection\", b\"close\"),\n                ],\n            }\n        )\n        await self.send({\"type\": \"http.response.body\", \"body\": b\"Internal Server Error\", \"more_body\": False})\n\n    # ASGI interface\n    async def send(self, message: ASGISendEvent) -> None:\n        message_type = message[\"type\"]\n\n        if self.flow.write_paused and not self.disconnected:\n            await self.flow.drain()  # pragma: full coverage\n\n        if self.disconnected:\n            return  # pragma: full coverage\n\n        if not self.response_started:\n            # Sending response status line and headers\n            if message_type != \"http.response.start\":\n                msg = \"Expected ASGI message 'http.response.start', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n            message = cast(\"HTTPResponseStartEvent\", message)\n\n            self.response_started = True\n            self.waiting_for_100_continue = False\n\n            status_code = message[\"status\"]\n            headers = self.default_headers + list(message.get(\"headers\", []))\n\n            if CLOSE_HEADER in self.scope[\"headers\"] and CLOSE_HEADER not in headers:\n                headers = headers + [CLOSE_HEADER]\n\n            if self.access_log:\n                self.access_logger.info(\n                    '%s - \"%s %s HTTP/%s\" %d',\n                    get_client_addr(self.scope),\n                    self.scope[\"method\"],\n                    get_path_with_query_string(self.scope),\n                    self.scope[\"http_version\"],\n                    status_code,\n                )\n\n            # Write response status line and headers\n            content = [STATUS_LINE[status_code]]\n\n            for name, value in headers:\n                if HEADER_RE.search(name):\n                    raise RuntimeError(\"Invalid HTTP header name.\")  # pragma: full coverage\n                if HEADER_VALUE_RE.search(value):\n                    raise RuntimeError(\"Invalid HTTP header value.\")\n\n                name = name.lower()\n                if name == b\"content-length\" and self.chunked_encoding is None:\n                    self.expected_content_length = int(value.decode())\n                    self.chunked_encoding = False\n                elif name == b\"transfer-encoding\" and value.lower() == b\"chunked\":\n                    self.expected_content_length = 0\n                    self.chunked_encoding = True\n                elif name == b\"connection\" and value.lower() == b\"close\":\n                    self.keep_alive = False\n                content.extend([name, b\": \", value, b\"\\r\\n\"])\n\n            if self.chunked_encoding is None and self.scope[\"method\"] != \"HEAD\" and status_code not in (204, 304):\n                # Neither content-length nor transfer-encoding specified\n                self.chunked_encoding = True\n                content.append(b\"transfer-encoding: chunked\\r\\n\")\n\n            content.append(b\"\\r\\n\")\n            self.transport.write(b\"\".join(content))\n\n        elif not self.response_complete:\n            # Sending response body\n            if message_type != \"http.response.body\":\n                msg = \"Expected ASGI message 'http.response.body', but got '%s'.\"\n                raise RuntimeError(msg % message_type)\n\n            body = cast(bytes, message.get(\"body\", b\"\"))\n            more_body = message.get(\"more_body\", False)\n\n            # Write response body\n            if self.scope[\"method\"] == \"HEAD\":\n                self.expected_content_length = 0\n            elif self.chunked_encoding:\n                if body:\n                    content = [b\"%x\\r\\n\" % len(body), body, b\"\\r\\n\"]\n                else:\n                    content = []\n                if not more_body:\n                    content.append(b\"0\\r\\n\\r\\n\")\n                self.transport.write(b\"\".join(content))\n            else:\n                num_bytes = len(body)\n                if num_bytes > self.expected_content_length:\n                    raise RuntimeError(\"Response content longer than Content-Length\")\n                else:\n                    self.expected_content_length -= num_bytes\n                self.transport.write(body)\n\n            # Handle response completion\n            if not more_body:\n                if self.expected_content_length != 0:\n                    raise RuntimeError(\"Response content shorter than Content-Length\")\n                self.response_complete = True\n                self.message_event.set()\n                if not self.keep_alive:\n                    self.transport.close()\n                self.on_response()\n\n        else:\n            # Response already sent\n            msg = \"Unexpected ASGI message '%s' sent, after response already completed.\"\n            raise RuntimeError(msg % message_type)\n\n    async def receive(self) -> ASGIReceiveEvent:\n        if self.waiting_for_100_continue and not self.transport.is_closing():\n            self.transport.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")\n            self.waiting_for_100_continue = False\n\n        if not self.disconnected and not self.response_complete:\n            self.flow.resume_reading()\n            await self.message_event.wait()\n            self.message_event.clear()\n\n        if self.disconnected or self.response_complete:\n            return {\"type\": \"http.disconnect\"}\n        message: HTTPRequestEvent = {\"type\": \"http.request\", \"body\": self.body, \"more_body\": self.more_body}\n        self.body = b\"\"\n        return message\n", 570]}, "functions": {"sleep (/usr/local/lib/python3.11/asyncio/tasks.py:637)": ["/usr/local/lib/python3.11/asyncio/tasks.py", 637], "FinnhubProvider.get_company_profile (/app/app/providers/finnhub_provider.py:124)": ["/app/app/providers/finnhub_provider.py", 124], "MarketDataService.get_company_profile (/app/app/services/market_data.py:280)": ["/app/app/services/market_data.py", 280], "_set_result_unless_cancelled (/usr/local/lib/python3.11/asyncio/futures.py:311)": ["/usr/local/lib/python3.11/asyncio/futures.py", 311], "Server.on_tick (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:233)": ["/usr/local/lib/python3.11/site-packages/uvicorn/server.py", 233], "Server.main_loop (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:224)": ["/usr/local/lib/python3.11/site-packages/uvicorn/server.py", 224], "Server._serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:73)": ["/usr/local/lib/python3.11/site-packages/uvicorn/server.py", 73], "Server.serve (/usr/local/lib/python3.11/site-packages/uvicorn/server.py:69)": ["/usr/local/lib/python3.11/site-packages/uvicorn/server.py", 69], "_format_timetuple_and_zone (/usr/local/lib/python3.11/email/utils.py:233)": ["/usr/local/lib/python3.11/email/utils.py", 233], "format_datetime (/usr/local/lib/python3.11/email/utils.py:271)": ["/usr/local/lib/python3.11/email/utils.py", 271], "formatdate (/usr/local/lib/python3.11/email/utils.py:242)": ["/usr/local/lib/python3.11/email/utils.py", 242], "ABCMeta.__instancecheck__ (<frozen abc>:117)": ["<frozen abc>", 117], "iscoroutine (/usr/local/lib/python3.11/asyncio/coroutines.py:34)": ["/usr/local/lib/python3.11/asyncio/coroutines.py", 34], "ismethod (/usr/local/lib/python3.11/inspect.py:300)": ["/usr/local/lib/python3.11/inspect.py", 300], "_unwrap_partial (/usr/local/lib/python3.11/functools.py:421)": ["/usr/local/lib/python3.11/functools.py", 421], "isfunction (/usr/local/lib/python3.11/inspect.py:378)": ["/usr/local/lib/python3.11/inspect.py", 378], "isclass (/usr/local/lib/python3.11/inspect.py:292)": ["/usr/local/lib/python3.11/inspect.py", 292], "_signature_is_functionlike (/usr/local/lib/python3.11/inspect.py:2075)": ["/usr/local/lib/python3.11/inspect.py", 2075], "_has_code_flag (/usr/local/lib/python3.11/inspect.py:391)": ["/usr/local/lib/python3.11/inspect.py", 391], "iscoroutinefunction (/usr/local/lib/python3.11/inspect.py:409)": ["/usr/local/lib/python3.11/inspect.py", 409], "iscoroutinefunction (/usr/local/lib/python3.11/asyncio/coroutines.py:21)": ["/usr/local/lib/python3.11/asyncio/coroutines.py", 21], "RLock (/usr/local/lib/python3.11/threading.py:90)": ["/usr/local/lib/python3.11/threading.py", 90], "Condition.__init__ (/usr/local/lib/python3.11/threading.py:243)": ["/usr/local/lib/python3.11/threading.py", 243], "Future.__init__ (/usr/local/lib/python3.11/concurrent/futures/_base.py:328)": ["/usr/local/lib/python3.11/concurrent/futures/_base.py", 328], "_WorkItem.__init__ (/usr/local/lib/python3.11/concurrent/futures/thread.py:47)": ["/usr/local/lib/python3.11/concurrent/futures/thread.py", 47], "Condition.__enter__ (/usr/local/lib/python3.11/threading.py:271)": ["/usr/local/lib/python3.11/threading.py", 271], "Condition.__exit__ (/usr/local/lib/python3.11/threading.py:274)": ["/usr/local/lib/python3.11/threading.py", 274], "Semaphore.acquire (/usr/local/lib/python3.11/threading.py:440)": ["/usr/local/lib/python3.11/threading.py", 440], "ThreadPoolExecutor._adjust_thread_count (/usr/local/lib/python3.11/concurrent/futures/thread.py:180)": ["/usr/local/lib/python3.11/concurrent/futures/thread.py", 180], "ThreadPoolExecutor.submit (/usr/local/lib/python3.11/concurrent/futures/thread.py:161)": ["/usr/local/lib/python3.11/concurrent/futures/thread.py", 161], "isfuture (/usr/local/lib/python3.11/asyncio/base_futures.py:14)": ["/usr/local/lib/python3.11/asyncio/base_futures.py", 14], "_get_loop (/usr/local/lib/python3.11/asyncio/futures.py:299)": ["/usr/local/lib/python3.11/asyncio/futures.py", 299], "Future.add_done_callback (/usr/local/lib/python3.11/concurrent/futures/_base.py:408)": ["/usr/local/lib/python3.11/concurrent/futures/_base.py", 408], "_chain_future (/usr/local/lib/python3.11/asyncio/futures.py:365)": ["/usr/local/lib/python3.11/asyncio/futures.py", 365], "wrap_future (/usr/local/lib/python3.11/asyncio/futures.py:409)": ["/usr/local/lib/python3.11/asyncio/futures.py", 409], "to_thread (/usr/local/lib/python3.11/asyncio/threads.py:12)": ["/usr/local/lib/python3.11/asyncio/threads.py", 12], "get_company_profile (/app/app/main.py:596)": ["/app/app/main.py", 596], "run_endpoint_function (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:280)": ["/usr/local/lib/python3.11/site-packages/fastapi/routing.py", 280], "get_request_handler.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:316)": ["/usr/local/lib/python3.11/site-packages/fastapi/routing.py", 316], "request_response.<locals>.app.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:103)": ["/usr/local/lib/python3.11/site-packages/fastapi/routing.py", 103], "wrap_app_handling_exceptions.<locals>.wrapped_app (/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py:31)": ["/usr/local/lib/python3.11/site-packages/starlette/_exception_handler.py", 31], "request_response.<locals>.app (/usr/local/lib/python3.11/site-packages/fastapi/routing.py:100)": ["/usr/local/lib/python3.11/site-packages/fastapi/routing.py", 100], "Route.handle (/usr/local/lib/python3.11/site-packages/starlette/routing.py:281)": ["/usr/local/lib/python3.11/site-packages/starlette/routing.py", 281], "Router.app (/usr/local/lib/python3.11/site-packages/starlette/routing.py:718)": ["/usr/local/lib/python3.11/site-packages/starlette/routing.py", 718], "Router.__call__ (/usr/local/lib/python3.11/site-packages/starlette/routing.py:712)": ["/usr/local/lib/python3.11/site-packages/starlette/routing.py", 712], "AsyncExitStackMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py:15)": ["/usr/local/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py", 15], "ExceptionMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py:47)": ["/usr/local/lib/python3.11/site-packages/starlette/middleware/exceptions.py", 47], "CORSMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/cors.py:75)": ["/usr/local/lib/python3.11/site-packages/starlette/middleware/cors.py", 75], "ServerErrorMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py:149)": ["/usr/local/lib/python3.11/site-packages/starlette/middleware/errors.py", 149], "Starlette.__call__ (/usr/local/lib/python3.11/site-packages/starlette/applications.py:109)": ["/usr/local/lib/python3.11/site-packages/starlette/applications.py", 109], "FastAPI.__call__ (/usr/local/lib/python3.11/site-packages/fastapi/applications.py:1130)": ["/usr/local/lib/python3.11/site-packages/fastapi/applications.py", 1130], "ProxyHeadersMiddleware.__call__ (/usr/local/lib/python3.11/site-packages/uvicorn/middleware/proxy_headers.py:27)": ["/usr/local/lib/python3.11/site-packages/uvicorn/middleware/proxy_headers.py", 27], "RequestResponseCycle.run_asgi (/usr/local/lib/python3.11/site-packages/uvicorn/protocols/http/httptools_impl.py:407)": ["/usr/local/lib/python3.11/site-packages/uvicorn/protocols/http/httptools_impl.py", 407], "Future.done (/usr/local/lib/python3.11/concurrent/futures/_base.py:393)": ["/usr/local/lib/python3.11/concurrent/futures/_base.py", 393], "Future.cancelled (/usr/local/lib/python3.11/concurrent/futures/_base.py:383)": ["/usr/local/lib/python3.11/concurrent/futures/_base.py", 383], "Future.exception (/usr/local/lib/python3.11/concurrent/futures/_base.py:463)": ["/usr/local/lib/python3.11/concurrent/futures/_base.py", 463], "Future.__get_result (/usr/local/lib/python3.11/concurrent/futures/_base.py:398)": ["/usr/local/lib/python3.11/concurrent/futures/_base.py", 398], "Future.result (/usr/local/lib/python3.11/concurrent/futures/_base.py:428)": ["/usr/local/lib/python3.11/concurrent/futures/_base.py", 428], "_copy_future_state (/usr/local/lib/python3.11/asyncio/futures.py:345)": ["/usr/local/lib/python3.11/asyncio/futures.py", 345], "_chain_future.<locals>._set_state (/usr/local/lib/python3.11/asyncio/futures.py:381)": ["/usr/local/lib/python3.11/asyncio/futures.py", 381], "_chain_future.<locals>._call_check_cancel (/usr/local/lib/python3.11/asyncio/futures.py:387)": ["/usr/local/lib/python3.11/asyncio/futures.py", 387]}}}